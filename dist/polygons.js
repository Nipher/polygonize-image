!function(t,n){if("object"==typeof exports&&"object"==typeof module)module.exports=n();else if("function"==typeof define&&define.amd)define([],n);else{var e=n();for(var a in e)("object"==typeof exports?exports:t)[a]=e[a]}}(window,(function(){return function(t){var n={};function e(a){if(n[a])return n[a].exports;var r=n[a]={i:a,l:!1,exports:{}};return t[a].call(r.exports,r,r.exports,e),r.l=!0,r.exports}return e.m=t,e.c=n,e.d=function(t,n,a){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:a})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var a=Object.create(null);if(e.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var r in t)e.d(a,r,function(n){return t[n]}.bind(null,r));return a},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=2)}([function(t,n,e){(function(n){var e;e=function(){"use strict";function t(t,n,e){return t<n?n:t>e?e:t}var e=function(t,n){void 0===t&&(t=300),void 0===n&&(n=150),"undefined"==typeof window?(this.canvasEl={width:t,height:n},this.ctx=null):(this.canvasEl=document.createElement("canvas"),this.canvasEl.width=t,this.canvasEl.height=n,this.ctx=this.canvasEl.getContext("2d"))},a={width:{configurable:!0},height:{configurable:!0}};function r(t,n,a,r){var o=!(!n||!n.backgroundColor)&&n.backgroundColor,i=new e(t.width*a,t.height*a,r),s=i.getContext("2d");return o&&(s.fillStyle=o,s.fillRect(0,0,t.width*a,t.height*a),s.fillStyle="transparent"),{canvas:i,ctx:s}}e.prototype.getContext=function(){return this.ctx},e.prototype.toDataURL=function(t,n,e){if("function"!=typeof e)return this.canvasEl.toDataURL(t,n);e(this.canvasEl.toDataURL(t,n))},a.width.get=function(){return this.canvasEl.width},a.width.set=function(t){this.canvasEl.width=t},a.height.get=function(){return this.canvasEl.height},a.height.set=function(t){this.canvasEl.height=t},Object.defineProperties(e.prototype,a),"undefined"!=typeof window&&(e.Image=Image);var o=.7,i=4,s=!0,l=!0,u=.5,c="miter",d=700,p=50,g=!1,h=["miter","round","bevel"];function m(n){return"object"!=typeof(n=function(t){var n=!1;if(void 0!==t)try{n=JSON.parse(JSON.stringify(t))}catch(t){}return n}(n))&&(n={}),"number"!=typeof n.accuracy||isNaN(n.accuracy)?n.accuracy=o:n.accuracy=t(n.accuracy,0,1),("number"!=typeof n.blur||isNaN(n.blur))&&(n.blur=i),n.blur<=0&&(n.blur=1),"string"!=typeof n.fill&&"boolean"!=typeof n.fill&&(n.fill=s),"string"!=typeof n.stroke&&"boolean"!=typeof n.stroke&&(n.stroke=l),("number"!=typeof n.strokeWidth||isNaN(n.strokeWidth))&&(n.strokeWidth=u),"number"!=typeof n.threshold||isNaN(n.threshold)?n.threshold=p:n.threshold=t(n.threshold,1,100),"string"==typeof n.lineJoin&&-1!==h.indexOf(n.lineJoin)||(n.lineJoin=c),n.gradients&&n.fill?n.gradients=!0:n.gradients=!1,n.gradients&&(("number"!=typeof n.gradientStops||isNaN(n.gradientStops)||n.gradientStops<2)&&(n.gradientStops=2),n.gradientStops=Math.round(n.gradientStops)),("number"!=typeof n.vertexCount||isNaN(n.vertexCount))&&(n.vertexCount=d),n.vertexCount<=0&&(n.vertexCount=1),"string"!=typeof n.transparentColor&&"boolean"!=typeof n.transparentColor&&(n.transparentColor=g),!0===typeof n.transparentColor&&(n.transparentColor=!1),"string"==typeof n.transparentColor&&(n.transparentColor=function(t){var n=r({width:1,height:1},{},1,!0).ctx;n.fillStyle=t,n.fillRect(0,0,1,1);var e=n.getImageData(0,0,1,1).data;return{r:e[0],g:e[1],b:e[2],a:e[3]/255}}(n.transparentColor)),n}function y(t){if(t instanceof HTMLImageElement){if(!t.naturalWidth||!t.naturalHeight||!1===t.complete)throw new Error("This this image hasn't finished loading: "+t.src);var n=new e(t.naturalWidth,t.naturalHeight),a=n.getContext("2d");a.drawImage(t,0,0,n.width,n.height);var r=a.getImageData(0,0,n.width,n.height);return r.data&&r.data.length&&(void 0===r.width&&(r.width=t.naturalWidth),void 0===r.height&&(r.height=t.naturalHeight)),r}throw new Error("This object does not seem to be an image.")}var f=Object.assign;function x(t){var n=f({a:1},t);return"rgba("+n.r+", "+n.g+", "+n.b+", "+n.a+")"}function b(t,n,e,a){return a=a||1,n.forEach((function(n,e){if(t.beginPath(),t.moveTo(n.a.x*a,n.a.y*a),t.lineTo(n.b.x*a,n.b.y*a),t.lineTo(n.c.x*a,n.c.y*a),t.lineTo(n.a.x*a,n.a.y*a),n.gradient){var r=t.createLinearGradient(n.gradient.x1*a,n.gradient.y1*a,n.gradient.x2*a,n.gradient.y2*a),o=n.gradient.colors.length-1;n.gradient.colors.forEach((function(t,n){var e=x(t);console.log(t),r.addColorStop(n/o,e)})),t.fillStyle=r,t.fill(),n.strokeWidth>0&&(t.strokeStyle=r,t.lineWidth=n.strokeWidth*a,t.lineJoin=n.lineJoin,t.stroke())}else n.fill&&(t.fillStyle=x(n.fill),t.fill()),n.strokeColor&&(t.strokeStyle=x(n.strokeColor),t.lineWidth=n.strokeWidth*a,t.lineJoin=n.lineJoin,t.stroke());t.closePath()})),t}function v(t,n,e){var a=e&&e.dpr?e.dpr:1,o=r(n,e,a,!0).ctx;return b(o,t,0,a),o.getImageData(0,0,n.width*a,n.height*a)}function w(t,n,e){var a=e&&e.dpr?e.dpr:1,o=r(n,e,a);return b(o.ctx,t,0,a),o.canvas.toDataURL()}function _(t){var n=t.toString(16);return 1==n.length?"0"+n:n}function k(t){var n=t.r,e=t.g,a=t.b;return"#"+_(n)+_(e)+_(a)}function D(t,n){var e="";t.length&&t[0].gradient&&(e="<defs>");var a="";return t.forEach((function(t,n){var r=t.a,o=t.b,i=t.c;if(a+='<polygon points="'+r.x+","+r.y+" "+o.x+","+o.y+" "+i.x+","+i.y+'"',t.gradient){var s=t.boundingBox,l=((t.gradient.x1-s.x)/s.width*100).toFixed(3),u=((t.gradient.y1-s.y)/s.height*100).toFixed(3),c=((t.gradient.x2-s.x)/s.width*100).toFixed(3),d=((t.gradient.y2-s.y)/s.height*100).toFixed(3);e+='\n\t<linearGradient id="gradient-'+n+'" x1="'+l+'%" y1="'+u+'%" x2="'+c+'%" y2="'+d+'%">';var p=t.gradient.colors.length-1;t.gradient.colors.forEach((function(t,n){var a=k(t),r=t.a<1?' stop-opacity="'+t.a+'"':"",o=(n/p*100).toFixed(3);e+='\n\t\t\t\t\t<stop offset="'+o+'%" stop-color="'+a+'"'+r+"/>\n\t\t\t\t"})),e+="</linearGradient>",a+=' fill="url(#gradient-'+n+')"',t.strokeWidth>0&&(a+=' stroke="url(#gradient-'+n+')" stroke-width="'+t.strokeWidth+'" stroke-linejoin="'+t.lineJoin+'"')}else{if(t.fill){var g=k(t.fill),h=t.fill.a<1?' fill-opacity="'+t.fill.a+'"':"";a+=' fill="'+g+'"'+h}else a+=' fill="transparent"';if(t.strokeColor){var m=k(t.strokeColor),y=t.strokeColor.a<1?' stroke-opacity="'+t.strokeColor.a+'"':"";a+=' stroke="'+m+'" stroke-width="'+t.strokeWidth+'" stroke-linejoin="'+t.lineJoin+'"'+y}}a+="/>\n\t"})),e.length&&(e+="\n\t\t</defs>"),'<?xml version="1.0" standalone="yes"?>\n<svg width="'+n.width+'" height="'+n.height+'" xmlns="http://www.w3.org/2000/svg" version="1.1" >\n\t'+e+"\n\t"+a+"\n</svg>"}function I(t,n){return t(n={exports:{}},n.exports),n.exports}"undefined"!=typeof window?window:void 0!==n||"undefined"!=typeof self&&self;var C=I((function(t){function n(t,n,e){this.a=t,this.b=n,this.c=e;var a,r,o,i,s=n.x-t.x,l=n.y-t.y,u=e.x-t.x,c=e.y-t.y,d=s*(t.x+n.x)+l*(t.y+n.y),p=u*(t.x+e.x)+c*(t.y+e.y),g=2*(s*(e.y-n.y)-l*(e.x-n.x));Math.abs(g)<1e-6?(a=Math.min(t.x,n.x,e.x),r=Math.min(t.y,n.y,e.y),o=.5*(Math.max(t.x,n.x,e.x)-a),i=.5*(Math.max(t.y,n.y,e.y)-r),this.x=a+o,this.y=r+i,this.r=o*o+i*i):(this.x=(c*d-l*p)/g,this.y=(s*p-u*d)/g,o=this.x-t.x,i=this.y-t.y,this.r=o*o+i*i)}function e(t,n){return n.x-t.x}function a(t){var n,e,a,r,o,i=t.length;t:for(;i;)for(e=t[--i],n=t[--i],a=i;a;)if(o=t[--a],n===(r=t[--a])&&e===o||n===o&&e===r){t.splice(i,2),t.splice(a,2),i-=2;continue t}}n.prototype.draw=function(t){t.beginPath(),t.moveTo(this.a.x,this.a.y),t.lineTo(this.b.x,this.b.y),t.lineTo(this.c.x,this.c.y),t.closePath(),t.stroke()},t.exports={Triangle:n,triangulate:function(t){if(t.length<3)return[];t.sort(e);for(var r=t.length-1,o=t[r].x,i=t[0].x,s=t[r].y,l=s;r--;)t[r].y<s&&(s=t[r].y),t[r].y>l&&(l=t[r].y);var u,c,d,p=i-o,g=l-s,h=p>g?p:g,m=.5*(i+o),y=.5*(l+s),f=[new n({x:m-20*h,y:y-h,__sentinel:!0},{x:m,y:y+20*h,__sentinel:!0},{x:m+20*h,y:y-h,__sentinel:!0})],x=[],b=[];for(r=t.length;r--;){for(b.length=0,u=f.length;u--;)(p=t[r].x-f[u].x)>0&&p*p>f[u].r?(x.push(f[u]),f.splice(u,1)):p*p+(g=t[r].y-f[u].y)*g>f[u].r||(b.push(f[u].a,f[u].b,f[u].b,f[u].c,f[u].c,f[u].a),f.splice(u,1));for(a(b),u=b.length;u;)d=b[--u],c=b[--u],f.push(new n(c,d,t[r]))}for(Array.prototype.push.apply(x,f),r=x.length;r--;)(x[r].a.__sentinel||x[r].b.__sentinel||x[r].c.__sentinel)&&x.splice(r,1);return x}}})),P=(C.Triangle,C.triangulate),S=I((function(t,n){!function(e){function a(t){if(!(this instanceof a))return new a(t);var n=t.width,e=t.height,r=[[-1,0,1],[-2,0,2],[-1,0,1]],o=[[-1,-2,-1],[0,0,0],[1,2,1]],i=[],s=[];function l(t){return function(e,a,r){return t[4*(n*a+e)+(r=r||0)]}}var u,c,d=l(t.data);for(c=0;c<e;c++)for(u=0;u<n;u++){var p=(d(u,c,0)+d(u,c,1)+d(u,c,2))/3;s.push(p,p,p,255)}for(d=l(s),c=0;c<e;c++)for(u=0;u<n;u++){var g=r[0][0]*d(u-1,c-1)+r[0][1]*d(u,c-1)+r[0][2]*d(u+1,c-1)+r[1][0]*d(u-1,c)+r[1][1]*d(u,c)+r[1][2]*d(u+1,c)+r[2][0]*d(u-1,c+1)+r[2][1]*d(u,c+1)+r[2][2]*d(u+1,c+1),h=o[0][0]*d(u-1,c-1)+o[0][1]*d(u,c-1)+o[0][2]*d(u+1,c-1)+o[1][0]*d(u-1,c)+o[1][1]*d(u,c)+o[1][2]*d(u+1,c)+o[2][0]*d(u-1,c+1)+o[2][1]*d(u,c+1)+o[2][2]*d(u+1,c+1),m=Math.sqrt(g*g+h*h)>>>0;i.push(m,m,m,255)}var y=i;return"function"==typeof Uint8ClampedArray&&(y=new Uint8ClampedArray(i)),y.toImageData=function(){return a.toImageData(y,n,e)},y}function r(t,n,e){return{width:n,height:e,data:t}}a.toImageData=function(t,n,e){if("function"==typeof ImageData&&"[object Uint16Array]"===Object.prototype.toString.call(t))return new ImageData(t,n,e);if("object"==typeof window&&"object"==typeof window.document){var a=document.createElement("canvas");if("function"==typeof a.getContext){var o=a.getContext("2d").createImageData(n,e);return o.data.set(t),o}return new r(t,n,e)}return new r(t,n,e)},t.exports&&(n=t.exports=a),n.Sobel=a}()}));function A(t){return t&&"number"==typeof t.width&&"number"==typeof t.height&&t.data&&"number"==typeof t.data.length&&"object"==typeof t.data}function E(t){if(A(t)){if("undefined"==typeof Uint8ClampedArray){if("undefined"==typeof window)throw new Error("Can't copy imageData in webworker without Uint8ClampedArray support.");return j(t)}var n,e=new Uint8ClampedArray(t.data);if("undefined"==typeof ImageData)return{width:t.width,height:t.height,data:e};try{n=new ImageData(e,t.width,t.height)}catch(e){if("undefined"==typeof window)throw new Error("Can't copy imageData in webworker without proper ImageData() support.");n=j(t)}return n}throw new Error("Given imageData object is not useable.")}function j(t){var n=new e(t.width,t.height).getContext("2d");return n.putImageData(t,0,0),n.getImageData(0,0,t.width,t.height)}S.Sobel;var O=[512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,289,287,285,282,280,278,275,273,271,269,267,265,263,261,259],M=[9,11,12,13,13,14,14,15,15,15,15,16,16,16,16,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24];function T(){this.r=0,this.g=0,this.b=0,this.a=0,this.next=null}function R(t,n,e){var a=t+"|"+n;e[a]||(e[a]={x:t,y:n}),a=null}function B(n,e,a){var r=(0|t(n.x,1,e.width-2))+(0|t(n.y,1,e.height-2))*e.width<<2;r>=e.data.length&&(r=e.data.length-5);var o=e.data[r+3]/255;return a&&0===o?a:{r:e.data[r],g:e.data[r+1],b:e.data[r+2],a:o}}function N(t){return{x:.33333*(t.a.x+t.b.x+t.c.x),y:.33333*(t.a.y+t.b.y+t.c.y)}}function W(t){return 0===t.a}function L(t){var n=function(t){if("string"==typeof t){var n=[0,0,0,0];return"#"===t[0]&&(t.length<7&&(t="#"+t[1]+t[1]+t[2]+t[2]+t[3]+t[3]+(t.length>4?t[4]+t[4]:"")),n=[parseInt(t.substr(1,2),16),parseInt(t.substr(3,2),16),parseInt(t.substr(5,2),16),t.length>7?parseInt(t.substr(7,2),16)/255:1]),0===t.indexOf("rgb")&&(t.includes("rgba")||(t+=",1"),n=t.match(/[\.\d]+/g).map((function(t){return+t}))),n}}(t);return n?{r:n[0],g:n[1],b:n[2],a:n[3]}:void 0}function F(t){var n=[t.r,t.g,t.b].map((function(t){return(t/=255)<=.03928?t/12.92:Math.pow((t+.055)/1.055,2.4)}));return.2126*n[0]+.7152*n[1]+.0722*n[2]}function H(t,n,e){return t.forEach((function(t){var a={};"abc".split("").forEach((function(r){var o=B(t[r],n,e.transparentColor);a[r]={key:r,color:o,x:t[r].x,y:t[r].y},a[r].luminance=F(a[r].color);var i="abc".replace(r,"").split("");a[r].median={x:(t[i[0]].x+t[i[1]].x)/2,y:(t[i[0]].y+t[i[1]].y)/2},a[r].medianColor=B(a[r].median,n,e.transparentColor),a[r].medianLuminance=F(a[r].medianColor)}));for(var r,o,i,s,l=[a.a,a.b,a.c].sort((function(t,n){return Math.abs(t.luminance-t.medianLuminance)-Math.abs(n.luminance-n.medianLuminance)})),u=l[0],c=l[0],d=u.median,p=[c],g=(r=c,i=(o=d).x-r.x,s=o.y-r.y,Math.sqrt(i*i+s*s)),h=1,m=e.gradientStops-2;h<m;h++){var y=h*(g/e.gradientStops)/g,f={x:c.x+y*(d.x-c.x),y:c.y+y*(d.y-c.y)};p.push(f)}p.push(d),t.gradient={x1:u.x,y1:u.y,x2:u.median.x,y2:u.median.y,colors:p.map((function(t){return B(t,n,e.transparentColor)}))},e.stroke&&(t.strokeWidth=e.strokeWidth,t.lineJoin=e.lineJoin),a=null})),t}function G(t,n){if(A(t)){var e={width:t.width,height:t.height},a=E(t),r=E(t),o=function(t){for(var n,e=t.data.length,a=0;a<e;a+=4)n=.34*t.data[a]+.5*t.data[a+1]+.16*t.data[a+2],t.data[a]=n,t.data[a+1]=n,t.data[a+2]=n;return t}(function(t,n,e,a,r,o){var i,s,l,u,c,d,p,g,h,m,y,f,x,b,v,w,_,k,D,I,C,P,S,A,E=t.data,j=o+o+1,R=a-1,B=r-1,N=o+1,W=N*(N+1)/2,L=new T,F=L;for(l=1;l<j;l++)if(F=F.next=new T,l==N)var H=F;F.next=L;var G=null,U=null;p=d=0;var J=O[o],Y=M[o];for(s=0;s<r;s++){for(w=_=k=D=g=h=m=y=0,f=N*(I=E[d]),x=N*(C=E[d+1]),b=N*(P=E[d+2]),v=N*(S=E[d+3]),g+=W*I,h+=W*C,m+=W*P,y+=W*S,F=L,l=0;l<N;l++)F.r=I,F.g=C,F.b=P,F.a=S,F=F.next;for(l=1;l<N;l++)u=d+((R<l?R:l)<<2),g+=(F.r=I=E[u])*(A=N-l),h+=(F.g=C=E[u+1])*A,m+=(F.b=P=E[u+2])*A,y+=(F.a=S=E[u+3])*A,w+=I,_+=C,k+=P,D+=S,F=F.next;for(G=L,U=H,i=0;i<a;i++)E[d+3]=S=y*J>>Y,0!=S?(S=255/S,E[d]=(g*J>>Y)*S,E[d+1]=(h*J>>Y)*S,E[d+2]=(m*J>>Y)*S):E[d]=E[d+1]=E[d+2]=0,g-=f,h-=x,m-=b,y-=v,f-=G.r,x-=G.g,b-=G.b,v-=G.a,u=p+((u=i+o+1)<R?u:R)<<2,g+=w+=G.r=E[u],h+=_+=G.g=E[u+1],m+=k+=G.b=E[u+2],y+=D+=G.a=E[u+3],G=G.next,f+=I=U.r,x+=C=U.g,b+=P=U.b,v+=S=U.a,w-=I,_-=C,k-=P,D-=S,U=U.next,d+=4;p+=a}for(i=0;i<a;i++){for(_=k=D=w=h=m=y=g=0,f=N*(I=E[d=i<<2]),x=N*(C=E[d+1]),b=N*(P=E[d+2]),v=N*(S=E[d+3]),g+=W*I,h+=W*C,m+=W*P,y+=W*S,F=L,l=0;l<N;l++)F.r=I,F.g=C,F.b=P,F.a=S,F=F.next;for(c=a,l=1;l<=o;l++)d=c+i<<2,g+=(F.r=I=E[d])*(A=N-l),h+=(F.g=C=E[d+1])*A,m+=(F.b=P=E[d+2])*A,y+=(F.a=S=E[d+3])*A,w+=I,_+=C,k+=P,D+=S,F=F.next,l<B&&(c+=a);for(d=i,G=L,U=H,s=0;s<r;s++)E[3+(u=d<<2)]=S=y*J>>Y,S>0?(S=255/S,E[u]=(g*J>>Y)*S,E[u+1]=(h*J>>Y)*S,E[u+2]=(m*J>>Y)*S):E[u]=E[u+1]=E[u+2]=0,g-=f,h-=x,m-=b,y-=v,f-=G.r,x-=G.g,b-=G.b,v-=G.a,u=i+((u=s+N)<B?u:B)*a<<2,g+=w+=G.r=E[u],h+=_+=G.g=E[u+1],m+=k+=G.b=E[u+2],y+=D+=G.a=E[u+3],G=G.next,f+=I=U.r,x+=C=U.g,b+=P=U.b,v+=S=U.a,w-=I,_-=C,k-=P,D-=S,U=U.next,d+=a}return t}(a,0,0,e.width,e.height,n.blur)),i=function(t,n,e,a,r){var o={},i=Math.max(~~(n*(1-e)),5),s=Math.round(Math.sqrt(i)),l=~~(a/s),u=~~(r/Math.round(Math.ceil(i/s))),c=0,d=0,p=0;for(p=0;p<r;p+=u)for(d=++c%2==0?~~(l/2):0;d<a;d+=l)d<a&&p<r&&R(~~(d+Math.cos(p)*u),~~(p+Math.sin(d)*l),o);R(0,0,o),R(a-1,0,o),R(a-1,r-1,o),R(0,r-1,o);var g=n-Object.keys(o).length,h=t.length,m=~~(h/g);if(n>0&&m>0){var y=0;for(y=0;y<h;y+=m)R(t[y].x,t[y].y,o)}return t=null,Object.keys(o).map((function(t){return o[t]}))}(function(t,n){var e,a,r,o,i,s,l,u,c,d=t.width,p=t.height,g=t.data,h=[];for(a=0;a<p;a+=2)for(e=0;e<d;e+=2){for(u=c=0,r=-1;r<=1;r++)if(l=(s=a+r)*d,s>=0&&s<p)for(o=-1;o<=1;o++)(i=e+o)>=0&&i<d&&(u+=g[i+l<<2],c++);c&&(u/=c),u>n&&h.push({x:e,y:a})}return h}(S(o).toImageData(),n.threshold),n.vertexCount,n.accuracy,e.width,e.height),s=P(i);return s=function(t,n,e){return t.forEach((function(t){var n,e,a,r,o;t.boundingBox=(n=[t.a,t.b,t.c],e=1/0,a=-1/0,r=1/0,o=-1/0,n.forEach((function(t){t.x<e&&(e=t.x),t.y<r&&(r=t.y),t.x>a&&(a=t.x),t.y>o&&(o=t.y)})),{x:e,y:r,width:a-e,height:o-r})})),t.filter((function(t){return t.boundingBox.width>0&&t.boundingBox.height>0}))}(s),n.transparentColor||(s=function(t,n){return t.filter((function(t){return!W(B(N(t),n))}))}(s,r)),s=!0===n.fill&&!0===n.gradients?H(s,r,n):function(t,n,e){var a=e.fill,r=e.stroke,o=e.strokeWidth,i=e.lineJoin,s=e.transparentColor,l=!!a&&L(a),u=!!r&&L(r),c=function(t,n){var e=W(t)&&s;return n&&!e?n:e?s:t};return t.forEach((function(t){var e=B(N(t),n);a&&(t.fill=c(e,l)),r&&(t.strokeColor=c(e,u),t.strokeWidth=o,t.lineJoin=i)})),t}(s,r,n)}throw new Error("Can't work with the imageData provided. It seems to be corrupt.")}return function(t){t=m(t);var n,e,a=!1,r=!1,o=new Worker(URL.createObjectURL(new Blob(["var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar delaunay = createCommonjsModule(function (module) {\nfunction Triangle(a, b, c) {\n  this.a = a;\n  this.b = b;\n  this.c = c;\n\n  var A = b.x - a.x,\n      B = b.y - a.y,\n      C = c.x - a.x,\n      D = c.y - a.y,\n      E = A * (a.x + b.x) + B * (a.y + b.y),\n      F = C * (a.x + c.x) + D * (a.y + c.y),\n      G = 2 * (A * (c.y - b.y) - B * (c.x - b.x)),\n      minx, miny, dx, dy;\n\n  /* If the points of the triangle are collinear, then just find the\n   * extremes and use the midpoint as the center of the circumcircle. */\n  if(Math.abs(G) < 0.000001) {\n    minx = Math.min(a.x, b.x, c.x);\n    miny = Math.min(a.y, b.y, c.y);\n    dx   = (Math.max(a.x, b.x, c.x) - minx) * 0.5;\n    dy   = (Math.max(a.y, b.y, c.y) - miny) * 0.5;\n\n    this.x = minx + dx;\n    this.y = miny + dy;\n    this.r = dx * dx + dy * dy;\n  }\n\n  else {\n    this.x = (D*E - B*F) / G;\n    this.y = (A*F - C*E) / G;\n    dx = this.x - a.x;\n    dy = this.y - a.y;\n    this.r = dx * dx + dy * dy;\n  }\n}\n\nTriangle.prototype.draw = function(ctx) {\n  ctx.beginPath();\n  ctx.moveTo(this.a.x, this.a.y);\n  ctx.lineTo(this.b.x, this.b.y);\n  ctx.lineTo(this.c.x, this.c.y);\n  ctx.closePath();\n  ctx.stroke();\n};\n\nfunction byX(a, b) {\n  return b.x - a.x\n}\n\nfunction dedup(edges) {\n  var j = edges.length,\n      a, b, i, m, n;\n\n  outer: while(j) {\n    b = edges[--j];\n    a = edges[--j];\n    i = j;\n    while(i) {\n      n = edges[--i];\n      m = edges[--i];\n      if((a === m && b === n) || (a === n && b === m)) {\n        edges.splice(j, 2);\n        edges.splice(i, 2);\n        j -= 2;\n        continue outer\n      }\n    }\n  }\n}\n\nfunction triangulate(vertices) {\n  /* Bail if there aren't enough vertices to form any triangles. */\n  if(vertices.length < 3)\n    { return [] }\n\n  /* Ensure the vertex array is in order of descending X coordinate\n   * (which is needed to ensure a subquadratic runtime), and then find\n   * the bounding box around the points. */\n  vertices.sort(byX);\n\n  var i    = vertices.length - 1,\n      xmin = vertices[i].x,\n      xmax = vertices[0].x,\n      ymin = vertices[i].y,\n      ymax = ymin;\n\n  while(i--) {\n    if(vertices[i].y < ymin) { ymin = vertices[i].y; }\n    if(vertices[i].y > ymax) { ymax = vertices[i].y; }\n  }\n\n  /* Find a supertriangle, which is a triangle that surrounds all the\n   * vertices. This is used like something of a sentinel value to remove\n   * cases in the main algorithm, and is removed before we return any\n   * results.\n   *\n   * Once found, put it in the \"open\" list. (The \"open\" list is for\n   * triangles who may still need to be considered; the \"closed\" list is\n   * for triangles which do not.) */\n  var dx     = xmax - xmin,\n      dy     = ymax - ymin,\n      dmax   = (dx > dy) ? dx : dy,\n      xmid   = (xmax + xmin) * 0.5,\n      ymid   = (ymax + ymin) * 0.5,\n      open   = [\n        new Triangle(\n          {x: xmid - 20 * dmax, y: ymid -      dmax, __sentinel: true},\n          {x: xmid            , y: ymid + 20 * dmax, __sentinel: true},\n          {x: xmid + 20 * dmax, y: ymid -      dmax, __sentinel: true}\n        )\n      ],\n      closed = [],\n      edges = [],\n      j, a, b;\n\n  /* Incrementally add each vertex to the mesh. */\n  i = vertices.length;\n  while(i--) {\n    /* For each open triangle, check to see if the current point is\n     * inside it's circumcircle. If it is, remove the triangle and add\n     * it's edges to an edge list. */\n    edges.length = 0;\n    j = open.length;\n    while(j--) {\n      /* If this point is to the right of this triangle's circumcircle,\n       * then this triangle should never get checked again. Remove it\n       * from the open list, add it to the closed list, and skip. */\n      dx = vertices[i].x - open[j].x;\n      if(dx > 0 && dx * dx > open[j].r) {\n        closed.push(open[j]);\n        open.splice(j, 1);\n        continue\n      }\n\n      /* If not, skip this triangle. */\n      dy = vertices[i].y - open[j].y;\n      if(dx * dx + dy * dy > open[j].r)\n        { continue }\n\n      /* Remove the triangle and add it's edges to the edge list. */\n      edges.push(\n        open[j].a, open[j].b,\n        open[j].b, open[j].c,\n        open[j].c, open[j].a\n      );\n      open.splice(j, 1);\n    }\n\n    /* Remove any doubled edges. */\n    dedup(edges);\n\n    /* Add a new triangle for each edge. */\n    j = edges.length;\n    while(j) {\n      b = edges[--j];\n      a = edges[--j];\n      open.push(new Triangle(a, b, vertices[i]));\n    }\n  }\n\n  /* Copy any remaining open triangles to the closed list, and then\n   * remove any triangles that share a vertex with the supertriangle. */\n  Array.prototype.push.apply(closed, open);\n\n  i = closed.length;\n  while(i--)\n    { if(closed[i].a.__sentinel ||\n       closed[i].b.__sentinel ||\n       closed[i].c.__sentinel)\n      { closed.splice(i, 1); } }\n\n  /* Yay, we're done! */\n  return closed\n}\n\n{\n    module.exports = {\n        Triangle: Triangle,\n        triangulate: triangulate\n    };\n}\n});\nvar delaunay_1 = delaunay.Triangle;\nvar delaunay_2 = delaunay.triangulate;\n\nvar sobel = createCommonjsModule(function (module, exports) {\n(function(root) {\n\n  function Sobel(imageData) {\n    if (!(this instanceof Sobel)) {\n      return new Sobel(imageData);\n    }\n\n    var width = imageData.width;\n    var height = imageData.height;\n\n    var kernelX = [\n      [-1,0,1],\n      [-2,0,2],\n      [-1,0,1]\n    ];\n\n    var kernelY = [\n      [-1,-2,-1],\n      [0,0,0],\n      [1,2,1]\n    ];\n\n    var sobelData = [];\n    var grayscaleData = [];\n\n    function bindPixelAt(data) {\n      return function(x, y, i) {\n        i = i || 0;\n        return data[((width * y) + x) * 4 + i];\n      };\n    }\n\n    var data = imageData.data;\n    var pixelAt = bindPixelAt(data);\n    var x, y;\n\n    for (y = 0; y < height; y++) {\n      for (x = 0; x < width; x++) {\n        var r = pixelAt(x, y, 0);\n        var g = pixelAt(x, y, 1);\n        var b = pixelAt(x, y, 2);\n\n        var avg = (r + g + b) / 3;\n        grayscaleData.push(avg, avg, avg, 255);\n      }\n    }\n\n    pixelAt = bindPixelAt(grayscaleData);\n\n    for (y = 0; y < height; y++) {\n      for (x = 0; x < width; x++) {\n        var pixelX = (\n            (kernelX[0][0] * pixelAt(x - 1, y - 1)) +\n            (kernelX[0][1] * pixelAt(x, y - 1)) +\n            (kernelX[0][2] * pixelAt(x + 1, y - 1)) +\n            (kernelX[1][0] * pixelAt(x - 1, y)) +\n            (kernelX[1][1] * pixelAt(x, y)) +\n            (kernelX[1][2] * pixelAt(x + 1, y)) +\n            (kernelX[2][0] * pixelAt(x - 1, y + 1)) +\n            (kernelX[2][1] * pixelAt(x, y + 1)) +\n            (kernelX[2][2] * pixelAt(x + 1, y + 1))\n        );\n\n        var pixelY = (\n          (kernelY[0][0] * pixelAt(x - 1, y - 1)) +\n          (kernelY[0][1] * pixelAt(x, y - 1)) +\n          (kernelY[0][2] * pixelAt(x + 1, y - 1)) +\n          (kernelY[1][0] * pixelAt(x - 1, y)) +\n          (kernelY[1][1] * pixelAt(x, y)) +\n          (kernelY[1][2] * pixelAt(x + 1, y)) +\n          (kernelY[2][0] * pixelAt(x - 1, y + 1)) +\n          (kernelY[2][1] * pixelAt(x, y + 1)) +\n          (kernelY[2][2] * pixelAt(x + 1, y + 1))\n        );\n\n        var magnitude = Math.sqrt((pixelX * pixelX) + (pixelY * pixelY))>>>0;\n\n        sobelData.push(magnitude, magnitude, magnitude, 255);\n      }\n    }\n\n    var clampedArray = sobelData;\n\n    if (typeof Uint8ClampedArray === 'function') {\n      clampedArray = new Uint8ClampedArray(sobelData);\n    }\n\n    clampedArray.toImageData = function() {\n      return Sobel.toImageData(clampedArray, width, height);\n    };\n\n    return clampedArray;\n  }\n\n  Sobel.toImageData = function toImageData(data, width, height) {\n    if (typeof ImageData === 'function' && Object.prototype.toString.call(data) === '[object Uint16Array]') {\n      return new ImageData(data, width, height);\n    } else {\n      if (typeof window === 'object' && typeof window.document === 'object') {\n        var canvas = document.createElement('canvas');\n\n        if (typeof canvas.getContext === 'function') {\n          var context = canvas.getContext('2d');\n          var imageData = context.createImageData(width, height);\n          imageData.data.set(data);\n          return imageData;\n        } else {\n          return new FakeImageData(data, width, height);\n        }\n      } else {\n        return new FakeImageData(data, width, height);\n      }\n    }\n  };\n\n  function FakeImageData(data, width, height) {\n    return {\n      width: width,\n      height: height,\n      data: data\n    };\n  }\n\n  {\n    if (module.exports) {\n      exports = module.exports = Sobel;\n    }\n    exports.Sobel = Sobel;\n  }\n\n})(commonjsGlobal);\n});\nvar sobel_1 = sobel.Sobel;\n\nfunction isImageData (imageData) {\n\treturn (\n\t\timageData && \n\t\ttypeof imageData.width === 'number' &&\n\t\ttypeof imageData.height === 'number' &&\n\t\timageData.data &&\n\t\ttypeof imageData.data.length === 'number' &&\n\t\ttypeof imageData.data === 'object'\n\t);\n}\n\nvar Canvas = function Canvas ( width, height ) {\n\tif ( width === void 0 ) width = 300;\n\tif ( height === void 0 ) height = 150;\n\n\tif ( typeof window === 'undefined' ) {\n\t\tthis.canvasEl = { width: width, height: height };\n\t\tthis.ctx = null;\n\t} else {\n\t\tthis.canvasEl = document.createElement( 'canvas' );\n\t\tthis.canvasEl.width = width;\n\t\tthis.canvasEl.height = height;\n\t\tthis.ctx = this.canvasEl.getContext( '2d' );\n\t} \n};\n\nvar prototypeAccessors = { width: { configurable: true },height: { configurable: true } };\n\nCanvas.prototype.getContext = function getContext () {\n\treturn this.ctx;\n};\n\nCanvas.prototype.toDataURL = function toDataURL ( type, encoderOptions, cb ) {\n\tif ( typeof cb === 'function' ) {\n\t\tcb( this.canvasEl.toDataURL( type, encoderOptions ) );\n\t} else {\n\t\treturn this.canvasEl.toDataURL( type, encoderOptions );\n\t}\n};\n\t\nprototypeAccessors.width.get = function () {\n\treturn this.canvasEl.width;\n};\n\t\nprototypeAccessors.width.set = function ( newWidth ) {\n\tthis.canvasEl.width = newWidth;\n};\n\nprototypeAccessors.height.get = function () {\n\treturn this.canvasEl.height;\n};\n\nprototypeAccessors.height.set = function ( newHeight ) {\n\tthis.canvasEl.height = newHeight;\n};\n\nObject.defineProperties( Canvas.prototype, prototypeAccessors );\n\nif ( typeof window !== 'undefined' ) {\n\tCanvas.Image = Image;\n}\n\n// import Canvas from 'canvas';\n\nfunction copyImageData (imageData) {\n\tif ( isImageData ( imageData ) ) {\n\t\tif ( typeof Uint8ClampedArray === 'undefined' ) {\n\t\t\tif ( typeof window === 'undefined' ) {\n\t\t\t\tthrow new Error( \"Can't copy imageData in webworker without Uint8ClampedArray support.\" );\n\t\t\t\treturn imageData;\n\t\t\t} else {\n\t\t\t\treturn copyImageDataWithCanvas( imageData );\n\t\t\t}\n\t\t} else {\n\t\t\tvar clampedArray = new Uint8ClampedArray( imageData.data );\n\n\t\t\tif ( typeof ImageData === 'undefined' ) {\n\t\t\t\t// http://stackoverflow.com/a/15238036/229189\n\t\t\t\treturn {\n\t\t\t\t\twidth: imageData.width,\n\t\t\t\t\theight: imageData.height,\n\t\t\t\t\tdata: clampedArray\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// http://stackoverflow.com/a/15908922/229189#comment57192591_15908922\n\t\t\t\tvar result;\n\n\t\t\t\ttry {\n\t\t\t\t\tresult = new ImageData( clampedArray, imageData.width, imageData.height );\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\tif ( typeof window === 'undefined' ) {\n\t\t\t\t\t\tthrow new Error( \"Can't copy imageData in webworker without proper ImageData() support.\" );\n\t\t\t\t\t\tresult = imageData;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = copyImageDataWithCanvas( imageData );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tthrow new Error( 'Given imageData object is not useable.' );\n\t\treturn;\n\t}\n}\n\n// http://stackoverflow.com/a/11918126/229189\nfunction copyImageDataWithCanvas ( imageData ) {\n\tvar canvas = new Canvas( imageData.width, imageData.height );\n\tvar ctx = canvas.getContext( '2d' );\n\n\tctx.putImageData( imageData, 0, 0 );\n\t\t\t\t\n\treturn ctx.getImageData( 0, 0, imageData.width, imageData.height );\n}\n\n/*\n    StackBlur - a fast almost Gaussian Blur For Canvas\n\n    Version:     0.5\n    Author:        Mario Klingemann\n    Contact:     mario@quasimondo.com\n    Website:    http://www.quasimondo.com/StackBlurForCanvas\n    Twitter:    @quasimondo\n\n    In case you find this class useful - especially in commercial projects -\n    I am not totally unhappy for a small donation to my PayPal account\n    mario@quasimondo.de\n\n    Or support me on flattr:\n    https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript\n\n    Copyright (c) 2010 Mario Klingemann\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n    */\n\nvar mul_table = [\n    512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,\n    454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,\n    482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,\n    437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,\n    497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,\n    320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,\n    446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,\n    329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,\n    505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,\n    399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,\n    324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,\n    268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,\n    451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,\n    385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,\n    332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,\n    289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];\n\n\nvar shg_table = [\n    9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,\n    17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,\n    19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,\n    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,\n    21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n    21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,\n    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,\n    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n    23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];\n\nfunction BlurStack () {\n\tthis.r = 0;\n\tthis.g = 0;\n\tthis.b = 0;\n\tthis.a = 0;\n\tthis.next = null;\n}\n\nfunction stackblur ( imageData, top_x, top_y, width, height, radius ) {\n\tvar pixels = imageData.data;\n\n\tvar x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum,\n\t\tr_out_sum, g_out_sum, b_out_sum, a_out_sum,\n\t\tr_in_sum, g_in_sum, b_in_sum, a_in_sum,\n\t\tpr, pg, pb, pa, rbs;\n\n\tvar div = radius + radius + 1;\n\tvar widthMinus1  = width - 1;\n\tvar heightMinus1 = height - 1;\n\tvar radiusPlus1  = radius + 1;\n\tvar sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;\n\n\tvar stackStart = new BlurStack();\n\tvar stack = stackStart;\n\t\n\tfor ( i = 1; i < div; i++ ) {\n\t\tstack = stack.next = new BlurStack();\n\t\tif (i == radiusPlus1) { var stackEnd = stack; }\n\t}\n\tstack.next = stackStart;\n\t\n\tvar stackIn = null;\n\tvar stackOut = null;\n\n\tyw = yi = 0;\n\n\tvar mul_sum = mul_table[radius];\n\tvar shg_sum = shg_table[radius];\n\n\tfor ( y = 0; y < height; y++ ) {\n\t\tr_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;\n\n\t\tr_out_sum = radiusPlus1 * ( pr = pixels[yi] );\n\t\tg_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );\n\t\tb_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );\n\t\ta_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );\n\n\t\tr_sum += sumFactor * pr;\n\t\tg_sum += sumFactor * pg;\n\t\tb_sum += sumFactor * pb;\n\t\ta_sum += sumFactor * pa;\n\n\t\tstack = stackStart;\n\n\t\tfor ( i = 0; i < radiusPlus1; i++ ) {\n\t\t\tstack.r = pr;\n\t\t\tstack.g = pg;\n\t\t\tstack.b = pb;\n\t\t\tstack.a = pa;\n\t\t\tstack = stack.next;\n\t\t}\n\n\t\tfor ( i = 1; i < radiusPlus1; i++ ) {\n\t\t\tp = yi + ( ( widthMinus1 < i ? widthMinus1 : i ) << 2 );\n\t\t\tr_sum += ( stack.r = ( pr = pixels[p] ) ) * ( rbs = radiusPlus1 - i );\n\t\t\tg_sum += ( stack.g = ( pg = pixels[p+1] ) ) * rbs;\n\t\t\tb_sum += ( stack.b = ( pb = pixels[p+2] ) ) * rbs;\n\t\t\ta_sum += ( stack.a = ( pa = pixels[p+3] ) ) * rbs;\n\n\t\t\tr_in_sum += pr;\n\t\t\tg_in_sum += pg;\n\t\t\tb_in_sum += pb;\n\t\t\ta_in_sum += pa;\n\n\t\t\tstack = stack.next;\n\t\t}\n\n\n\t\tstackIn = stackStart;\n\t\tstackOut = stackEnd;\n\n\t\tfor (x = 0; x < width; x++) {\n\t\t\tpixels[yi+3] = pa = (a_sum * mul_sum) >> shg_sum;\n\t\t\t\n\t\t\tif (pa != 0) {\n\t\t\t\tpa = 255 / pa;\n\t\t\t\tpixels[yi]   = ( ( r_sum * mul_sum ) >> shg_sum ) * pa;\n\t\t\t\tpixels[yi+1] = ( ( g_sum * mul_sum ) >> shg_sum ) * pa;\n\t\t\t\tpixels[yi+2] = ( ( b_sum * mul_sum ) >> shg_sum ) * pa;\n\t\t\t} else {\n\t\t\t\tpixels[yi] = pixels[yi+1] = pixels[yi+2] = 0;\n\t\t\t}\n\n\t\t\tr_sum -= r_out_sum;\n\t\t\tg_sum -= g_out_sum;\n\t\t\tb_sum -= b_out_sum;\n\t\t\ta_sum -= a_out_sum;\n\n\t\t\tr_out_sum -= stackIn.r;\n\t\t\tg_out_sum -= stackIn.g;\n\t\t\tb_out_sum -= stackIn.b;\n\t\t\ta_out_sum -= stackIn.a;\n\n\t\t\tp =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;\n\n\t\t\tr_in_sum += ( stackIn.r = pixels[p] );\n\t\t\tg_in_sum += ( stackIn.g = pixels[p+1] );\n\t\t\tb_in_sum += ( stackIn.b = pixels[p+2] );\n\t\t\ta_in_sum += ( stackIn.a = pixels[p+3] );\n\n\t\t\tr_sum += r_in_sum;\n\t\t\tg_sum += g_in_sum;\n\t\t\tb_sum += b_in_sum;\n\t\t\ta_sum += a_in_sum;\n\n\t\t\tstackIn = stackIn.next;\n\n\t\t\tr_out_sum += ( pr = stackOut.r );\n\t\t\tg_out_sum += ( pg = stackOut.g );\n\t\t\tb_out_sum += ( pb = stackOut.b );\n\t\t\ta_out_sum += ( pa = stackOut.a );\n\n\t\t\tr_in_sum -= pr;\n\t\t\tg_in_sum -= pg;\n\t\t\tb_in_sum -= pb;\n\t\t\ta_in_sum -= pa;\n\n\t\t\tstackOut = stackOut.next;\n\n\t\t\tyi += 4;\n\t\t}\n\t\tyw += width;\n\t}\n\n\n\tfor ( x = 0; x < width; x++ ) {\n\t\tg_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;\n\n\t\tyi = x << 2;\n\t\tr_out_sum = radiusPlus1 * ( pr = pixels[yi] );\n\t\tg_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );\n\t\tb_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );\n\t\ta_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );\n\n\t\tr_sum += sumFactor * pr;\n\t\tg_sum += sumFactor * pg;\n\t\tb_sum += sumFactor * pb;\n\t\ta_sum += sumFactor * pa;\n\n\t\tstack = stackStart;\n\n\t\tfor ( i = 0; i < radiusPlus1; i++) {\n\t\t\tstack.r = pr;\n\t\t\tstack.g = pg;\n\t\t\tstack.b = pb;\n\t\t\tstack.a = pa;\n\t\t\tstack = stack.next;\n\t\t}\n\n\t\typ = width;\n\n\t\tfor ( i = 1; i <= radius; i++ ) {\n\t\t\tyi = ( yp + x ) << 2;\n\n\t\t\tr_sum += ( stack.r = ( pr = pixels[yi] ) ) * (rbs = radiusPlus1 - i);\n\t\t\tg_sum += ( stack.g = ( pg = pixels[yi+1] ) ) * rbs;\n\t\t\tb_sum += ( stack.b = ( pb = pixels[yi+2] ) ) * rbs;\n\t\t\ta_sum += ( stack.a = ( pa = pixels[yi+3] ) ) * rbs;\n\n\t\t\tr_in_sum += pr;\n\t\t\tg_in_sum += pg;\n\t\t\tb_in_sum += pb;\n\t\t\ta_in_sum += pa;\n\n\t\t\tstack = stack.next;\n\n\t\t\tif ( i < heightMinus1 ) {\n\t\t\t\typ += width;\n\t\t\t}\n\t\t}\n\n\t\tyi = x;\n\t\tstackIn = stackStart;\n\t\tstackOut = stackEnd;\n\n\t\tfor ( y = 0; y < height; y++ ) {\n\t\t\tp = yi << 2;\n\t\t\tpixels[p+3] = pa = ( a_sum * mul_sum ) >> shg_sum;\n\t\t\t\n\t\t\tif ( pa > 0 ) {\n\t\t\t\tpa = 255 / pa;\n\t\t\t\tpixels[p]   = ( ( r_sum * mul_sum ) >> shg_sum) * pa;\n\t\t\t\tpixels[p+1] = ( ( g_sum * mul_sum ) >> shg_sum) * pa;\n\t\t\t\tpixels[p+2] = ( ( b_sum * mul_sum ) >> shg_sum) * pa;\n\t\t\t} else {\n\t\t\t\tpixels[p] = pixels[p+1] = pixels[p+2] = 0;\n\t\t\t}\n\n\t\t\tr_sum -= r_out_sum;\n\t\t\tg_sum -= g_out_sum;\n\t\t\tb_sum -= b_out_sum;\n\t\t\ta_sum -= a_out_sum;\n\n\t\t\tr_out_sum -= stackIn.r;\n\t\t\tg_out_sum -= stackIn.g;\n\t\t\tb_out_sum -= stackIn.b;\n\t\t\ta_out_sum -= stackIn.a;\n\n\t\t\tp = ( x + ( ( ( p = y + radiusPlus1 ) < heightMinus1 ? p : heightMinus1 ) * width ) ) << 2;\n\n\t\t\tr_sum += ( r_in_sum += ( stackIn.r = pixels[p] ) );\n\t\t\tg_sum += ( g_in_sum += ( stackIn.g = pixels[p+1] ) );\n\t\t\tb_sum += ( b_in_sum += ( stackIn.b = pixels[p+2] ) );\n\t\t\ta_sum += ( a_in_sum += ( stackIn.a = pixels[p+3] ) );\n\n\t\t\tstackIn = stackIn.next;\n\n\t\t\tr_out_sum += ( pr = stackOut.r );\n\t\t\tg_out_sum += ( pg = stackOut.g );\n\t\t\tb_out_sum += ( pb = stackOut.b );\n\t\t\ta_out_sum += ( pa = stackOut.a );\n\n\t\t\tr_in_sum -= pr;\n\t\t\tg_in_sum -= pg;\n\t\t\tb_in_sum -= pb;\n\t\t\ta_in_sum -= pa;\n\n\t\t\tstackOut = stackOut.next;\n\n\t\t\tyi += width;\n\t\t}\n\t}\n\n\treturn imageData;\n}\n\nfunction greyscale (imageData) {\n\tvar len = imageData.data.length;\n\tvar brightness;\n\n\tfor ( var i = 0; i < len; i += 4 ) {\n\t\tbrightness = 0.34 * imageData.data[i] + 0.5 * imageData.data[i + 1] + 0.16 * imageData.data[i + 2];\n\n\t\timageData.data[i] = brightness;\n\t\timageData.data[i + 1] = brightness;\n\t\timageData.data[i + 2] = brightness;\n\t}\n\t\t\n\treturn imageData;\n}\n\n// most parts taken from http://jsdo.it/akm2/xoYx\n// (starting line 293++)\nfunction getEdgePoints ( imageData, threshold ) {\n\t// only check every 2nd pixel in imageData to save some time.\n\tvar multiplier = 2;\n\tvar width = imageData.width;\n\tvar height = imageData.height;\n\tvar data = imageData.data;\n\tvar points = [ ];\n\tvar x, y, row, col, sx, sy, step, sum, total;\n\n\tfor ( y = 0; y < height; y += multiplier ) {\n\t\tfor ( x = 0; x < width; x += multiplier ) {\n\t\t\tsum = total = 0;\n\n\t\t\tfor ( row = -1; row <= 1; row++ ) {\n\t\t\t\tsy = y + row;\n\t\t\t\tstep = sy * width;\n\n\t\t\t\tif ( sy >= 0 && sy < height ) {\n\t\t\t\t\tfor ( col = -1; col <= 1; col++ ) {\n\t\t\t\t\t\tsx = x + col;\n\n\t\t\t\t\t\tif ( sx >= 0 && sx < width ) {\n\t\t\t\t\t\t\tsum += data[( sx + step ) << 2];\n\t\t\t\t\t\t\ttotal++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( total ) {\n\t\t\t\tsum /= total;\n\t\t\t}\n\n\t\t\tif ( sum > threshold ) {\n\t\t\t\tpoints.push( { x: x, y: y } );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn points;\n}\n\nfunction clamp ( value, min, max ) {\n\treturn value < min ? min : value > max ? max : value;\n}\n\nfunction addVertex ( x, y, hash ) {\n\tvar resultKey = x + '|' + y;\n\n\tif ( ! hash[resultKey] ) {\n\t\thash[resultKey] = { x: x, y: y };\n\t}\n\n\tresultKey = null;\n}\n\nfunction getVerticesFromPoints ( points, maxPointCount, accuracy, width, height ) {\n\t// using hash for all points to make sure we have a set of unique vertices.\n\tvar resultHash = { };\n\n\t// use 25% of max point count to create a background grid.\n\t// this avoids having too many \"big\" triangles in areas of the image with low contrast \n\t// next to very small ones in areas with high contrast\n\t// for every other row, start the x value at > 0, so the grid doesn't look too regular\n\tvar gridPointCount = Math.max( ~~( maxPointCount * ( 1 - accuracy ) ), 5 );\n\n\t// http://stackoverflow.com/a/4107092/229189\n\tvar gridColumns = Math.round( Math.sqrt( gridPointCount ) );\n\tvar gridRows = Math.round( Math.ceil( gridPointCount / gridColumns ) );\n\t\n\tvar xIncrement = ~~( width / gridColumns );\n\tvar yIncrement = ~~( height / gridRows );\n\n\tvar rowIndex = 0;\n\tvar startX = 0;\n\n\tvar x = 0;\n\tvar y = 0;\n\n\tfor ( y = 0; y < height; y+= yIncrement ) {\n\t\trowIndex++;\n\n\t\tstartX = rowIndex % 2 === 0 ? ~~( xIncrement / 2 ) : 0; \n\n\t\tfor ( x = startX; x < width; x += xIncrement ) {\n\t\t\tif ( x < width && y < height ) {\n\t\t\t\t// \"distorting\" the grid a little bit so that the\n\t\t\t\t// background vertices don't appear to be on a straight line (which looks boring)\n\t\t\t\taddVertex(\n\t\t\t\t\t~~( x + ( Math.cos( y ) * ( yIncrement ) ) ),\n\t\t\t\t\t~~( y + ( Math.sin( x ) * ( xIncrement ) ) ),\n\t\t\t\t\tresultHash\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// add points in the corners\n\taddVertex( 0, 0, resultHash );\n\taddVertex( width - 1, 0, resultHash );\n\taddVertex( width - 1, height - 1, resultHash );\n\taddVertex( 0, height - 1, resultHash );\n\n\t// add points from all edge points\n\tvar remainingPointCount = maxPointCount - Object.keys( resultHash ).length;\n\tvar edgePointCount = points.length;\n\tvar increment = ~~( edgePointCount / remainingPointCount );\n\n\tif ( maxPointCount > 0 && increment > 0 ) {\n\t\tvar i = 0;\n\n\t\tfor ( i = 0; i < edgePointCount; i += increment ) {\n\t\t\taddVertex( points[i].x, points[i].y, resultHash );\n\t\t}\n\t}\n\n\tpoints = null;\n\n\treturn Object.keys( resultHash ).map( function (key) {\n\t\treturn resultHash[key];\n\t} );\n}\n\nfunction getBoundingBox (points) {\n\tvar xMin = Infinity;\n\tvar xMax = -Infinity;\n\tvar yMin = Infinity;\n\tvar yMax = -Infinity;\n\n\tpoints.forEach( function (p) {\n\t\tif ( p.x < xMin ) {\n\t\t\txMin = p.x;\n\t\t}\n\n\t\tif ( p.y < yMin ) {\n\t\t\tyMin = p.y;\n\t\t}\n\n\t\tif ( p.x > xMax ) {\n\t\t\txMax = p.x;\n\t\t}\n\n\t\tif ( p.y > yMax ) {\n\t\t\tyMax = p.y;\n\t\t}\n\t} );\n\n\treturn {\n\t\tx: xMin,\n\t\ty: yMin,\n\t\twidth: xMax - xMin,\n\t\theight: yMax - yMin\n\t};\n}\n\nfunction addBoundingBoxesToPolygons ( polygons, colorData, params ) {\n\tpolygons.forEach( function (polygon) {\n\t\tpolygon.boundingBox = getBoundingBox( [ polygon.a, polygon.b, polygon.c ] );\n\t} );\n\n\treturn polygons.filter( function (polygon) {\n\t\treturn polygon.boundingBox.width > 0 && polygon.boundingBox.height > 0;\n\t} );\n}\n\n/**\n * Get color object by position\n * @param  {Object} pos         {x,y} object\n * @param  {Object} colorData   Image color data object\n * @param  {Object} [transparentColor] (optional) RGBA color object. Used to set specific color to transparent pixels\n * @return {Object}             RGBA color object\n */\nfunction getColorByPos ( pos, colorData, transparentColor ) {\n\tvar x = clamp( pos.x, 1, colorData.width - 2 );\n\tvar y = clamp( pos.y, 1, colorData.height - 2 );\n\tvar index = ( ( x | 0 ) + ( y | 0 ) * colorData.width ) << 2;\n\n\tif ( index >= colorData.data.length ) {\n\t\tindex = colorData.data.length - 5;\n\t}\n\n\tvar alpha = colorData.data[index + 3] / 255;\n\n\t// Return RGBA color object\n\treturn ( transparentColor && alpha === 0 ) ? transparentColor : {\n\t\tr: colorData.data[index],\n\t\tg: colorData.data[index + 1],\n\t\tb: colorData.data[index + 2],\n\t\ta: alpha\n\t};\n}\n\n/**\n * Get polygon's center point\n * @param  {Object} polygon Polygon object\n * @return {Object}         Point coordinates {x,y}\n */\nfunction polygonCenter (polygon) {\n\treturn {\n\t\tx: ( polygon.a.x + polygon.b.x + polygon.c.x ) * 0.33333,\n\t\ty: ( polygon.a.y + polygon.b.y + polygon.c.y ) * 0.33333\n\t};\n}\n\n/**\n * Is color transparent ?\n * @param  {Object} color Color object\n * @return {Boolean}      Is transparent?\n */\nfunction isTransparent (color) {\n\treturn color.a === 0;\n}\n\n// import objectAssign from 'object-assign'\n\n// https://gist.githubusercontent.com/oriadam/396a4beaaad465ca921618f2f2444d49/raw/76b0de6caffaac59f8af2b4dfa0e0b6397cf447d/colorValues.js\n// return array of [r,g,b,a] from any valid color. if failed returns undefined\nfunction strToColorArr ( color ) {\n\tif ( typeof color === 'string' ) {\n\t\tvar result = [ 0, 0, 0, 0 ];\n\t\t\n\t\tif ( color[0] === '#' )\t{\n\t\t\t// convert #RGB and #RGBA to #RRGGBB and #RRGGBBAA\n\t\t\tif ( color.length < 7 ) {\n\t\t\t\tcolor = \"#\" + (color[1]) + (color[1]) + (color[2]) + (color[2]) + (color[3]) + (color[3]) + (color.length > 4 ? color[4] + color[4] : '');\n\t\t\t}\n\n\t\t\tresult = [\n\t\t\t\tparseInt(color.substr( 1, 2 ), 16),\n\t\t\t\tparseInt(color.substr( 3, 2 ), 16),\n\t\t\t\tparseInt(color.substr( 5, 2 ), 16),\n\t\t\t\tcolor.length > 7 ? parseInt( color.substr( 7, 2 ), 16 ) / 255 : 1\n\t\t\t];\n\t\t}\n\n\t\tif ( color.indexOf('rgb') === 0 ) {\n\t\t\t// convert 'rgb(R,G,B)' to 'rgb(R,G,B)A' which looks awful but will pass the regxep below\n\t\t\tif ( ! color.includes( 'rgba' ) ) {\n\t\t\t\tcolor += ',1';\n\t\t\t}\n\n\t\t\tresult = color\n\t\t\t\t.match( /[\\.\\d]+/g )\n\t\t\t\t.map( function (a) { return +a; } );\n\t\t}\n\t\t\n\t\treturn result;\n\t} else {\n\t\treturn;\n\t}\n\n}\n\nfunction strToColor ( str ) {\n\tvar color = strToColorArr( str );\n\n\tif ( color ) {\n\t\tvar r = color[0];\n\t\tvar g = color[1];\n\t\tvar b = color[2];\n\t\tvar a = color[3];\n\t\treturn { r: r, g: g, b: b, a: a };\n\t} else {\n\t\treturn;\n\t}\n}\n\nfunction addColorToPolygons ( polygons, colorData, params ) {\n\tvar fill = params.fill;\n\tvar stroke = params.stroke;\n\tvar strokeWidth = params.strokeWidth;\n\tvar lineJoin = params.lineJoin;\n\tvar transparentColor = params.transparentColor;\n\tvar fillColor = fill ? strToColor( fill ) : false;\n\tvar strokeColor = stroke ? strToColor( stroke ) : false;\n\n\t/**\n\t * Color override logic\n\t * @param  {Object} color    Color object\n\t * @param  {String} override Override color (fillColor/strokeColor)\n\t * @return {String}          CSS formatted color (rgba,..)\n\t */\n\tvar getColor = function ( color, override ) {\n\t\tvar t = ( isTransparent( color ) && transparentColor );\t// Color is transparent, and transparentColor override is defined\n\t\tvar c = t ? transparentColor : color;\n\t\treturn ( override && !t ) ? override : c;\t\t// Priority: transparentColor -> override -> supplied color\n\t};\n\n\tpolygons.forEach( function (polygon) {\n\t\tvar color = getColorByPos( polygonCenter( polygon ), colorData );\n\n\t\tif ( fill ) {\n\t\t\tpolygon.fill = getColor( color, fillColor );\n\t\t}\n\n\t\tif ( stroke ) {\n\t\t\tpolygon.strokeColor = getColor(color, strokeColor);\n\t\t\tpolygon.strokeWidth = strokeWidth;\n\t\t\tpolygon.lineJoin = lineJoin;\n\t\t}\n\t} );\n\n\treturn polygons;\n}\n\n//  http://stackoverflow.com/a/9733420/229189\nfunction luminance (color) {\n\tvar a = [ color.r, color.g, color.b ].map( function (v) {\n\t\tv /= 255;\n\t\treturn ( v <= 0.03928 ) ? v / 12.92 : Math.pow( ( ( v + 0.055 ) / 1.055 ), 2.4 );\n\t} );\n\n\treturn a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;\n}\n\nfunction distance ( a, b ) {\n\tvar dx = b.x - a.x;\n\tvar dy = b.y - a.y;\n\n\treturn Math.sqrt( ( dx * dx ) + ( dy * dy ) );\n}\n\nfunction addGradientsToPolygons ( polygons, colorData, params ) {\n\tpolygons.forEach( function (polygon) {\n\t\tvar data = { };\n\n\t\t'abc'.split( '' ).forEach( function (key) {\n\t\t\tvar color = getColorByPos( polygon[key], colorData, params.transparentColor );\n\t\t\t\n\t\t\tdata[key] = {\n\t\t\t\tkey: key,\n\t\t\t\tcolor: color,\n\t\t\t\tx: polygon[key].x,\n\t\t\t\ty: polygon[key].y\n\t\t\t};\n\n\t\t\tdata[key].luminance = luminance( data[key].color );\n\n\t\t\tvar otherKeys = 'abc'.replace( key, '' ).split( '' );\n\n\t\t\tdata[key].median = {\n\t\t\t\tx: ( polygon[otherKeys[0]].x + polygon[otherKeys[1]].x ) / 2,\n\t\t\t\ty: ( polygon[otherKeys[0]].y + polygon[otherKeys[1]].y ) / 2\n\t\t\t};\n\n\t\t\tdata[key].medianColor = getColorByPos( data[key].median, colorData, params.transparentColor );\n\t\t\tdata[key].medianLuminance = luminance( data[key].medianColor );\n\t\t} );\n\n\t\t// sort by axis of most difference in luminance\n\t\tvar pointsByDeltaInLuminance = [ data.a, data.b, data.c ].sort( function ( u, v ) {\n\t\t\treturn Math.abs( u.luminance - u.medianLuminance ) - Math.abs( v.luminance - v.medianLuminance );\n\t\t} );\n\n\t\tvar pointWithMostDeltaInLuminance = pointsByDeltaInLuminance[0];\n\t\tvar startPoint = pointsByDeltaInLuminance[0];\n\t\tvar endPoint = pointWithMostDeltaInLuminance.median;\n\n\t\tvar gradienStopPositions = [ startPoint ];\n\n\t\tvar startToEndDistance = distance( startPoint, endPoint );\n\n\t\tfor ( var i = 1, len = params.gradientStops - 2; i < len; i++ ) {\n\t\t\tvar pointDistance = i * ( startToEndDistance / params.gradientStops );\n\t\t\tvar pointPercent = pointDistance / startToEndDistance;\n\t\t\t\n\t\t\tvar point = {\n\t\t\t\tx: startPoint.x + pointPercent * ( endPoint.x - startPoint.x ), \n\t\t\t\ty: startPoint.y + pointPercent * ( endPoint.y - startPoint.y )\n\t\t\t};\n\n\t\t\tgradienStopPositions.push( point );\n\t\t}\n\n\t\tgradienStopPositions.push( endPoint );\n\n\t\tpolygon.gradient = {\n\t\t\tx1: pointWithMostDeltaInLuminance.x,\n\t\t\ty1: pointWithMostDeltaInLuminance.y,\n\t\t\tx2: pointWithMostDeltaInLuminance.median.x,\n\t\t\ty2: pointWithMostDeltaInLuminance.median.y,\n\t\t\tcolors: gradienStopPositions.map( function (pos) {\n\t\t\t\treturn getColorByPos( pos, colorData, params.transparentColor );\n\t\t\t} )\n\t\t};\n\n\t\tif ( params.stroke ) {\n\t\t\tpolygon.strokeWidth = params.strokeWidth;\n\t\t\tpolygon.lineJoin = params.lineJoin;\n\t\t}\n\n\t\tdata = null;\n\t} );\n\n\treturn polygons;\n}\n\n/**\n * Filter polygons with transparent color\n * @param  {Array} polygons    Polygons array\n * @param  {Object} colorData  Color data\n * @return {Array}             Filtered polygons array\n */\nfunction filterTransparentPolygons ( polygons, colorData ) {\n\treturn polygons.filter( function (polygon) {\n\t\tvar color = getColorByPos( polygonCenter( polygon ), colorData );\n\t\treturn ! isTransparent( color );\n\t});\n}\n\nfunction imageDataToPolygons ( imageData, params ) {\n\tif ( isImageData( imageData ) ) {\n\t\tvar imageSize = { width: imageData.width, height: imageData.height };\n\t\tvar tmpImageData = copyImageData( imageData );\n\t\tvar colorImageData = copyImageData( imageData );\n\t\tvar blurredImageData = stackblur( tmpImageData, 0, 0, imageSize.width, imageSize.height, params.blur );\n\t\tvar greyscaleImageData = greyscale( blurredImageData );\n\t\tvar edgesImageData = sobel( greyscaleImageData ).toImageData();\n\t\tvar edgePoints = getEdgePoints( edgesImageData, params.threshold );\n\t\tvar edgeVertices = getVerticesFromPoints( edgePoints, params.vertexCount, params.accuracy, imageSize.width, imageSize.height );\n\t\tvar polygons = delaunay_2( edgeVertices );\n\t\t\n\t\tpolygons = addBoundingBoxesToPolygons( polygons );\n\t\t\n\t\tif ( ! params.transparentColor ) {\n\t\t\tpolygons = filterTransparentPolygons( polygons, colorImageData );\n\t\t}\n\t\t\n\t\tif ( params.fill === true && params.gradients === true ) {\n\t\t\tpolygons = addGradientsToPolygons( polygons, colorImageData, params );\n\t\t} else {\n\t\t\tpolygons = addColorToPolygons( polygons, colorImageData, params );\n\t\t}\n\n\t\treturn polygons;\n\t} else {\n\t\tthrow new Error( \"Can't work with the imageData provided. It seems to be corrupt.\" );\n\t\treturn;\n\t}\n}\n\nonmessage = function (msg) {\n\tif ( msg.data.imageData && msg.data.params ) {\n\t\ttry {\n\t\t\tvar imageData = msg.data.imageData;\n\n\t\t\t// phantomjs seems to have some memory loss so we need to make sure\n\t\t\tif ( typeof imageData.width === 'undefined' && typeof msg.data.imageDataWidth === 'number' ) {\n\t\t\t\timageData.width = msg.data.imageDataWidth;\n\t\t\t}\n\n\t\t\tif ( typeof imageData.height === 'undefined' && typeof msg.data.imageDataHeight === 'number' ) {\n\t\t\t\timageData.height = msg.data.imageDataHeight;\n\t\t\t}\n\t\t\t\n\t\t\tvar polygons = imageDataToPolygons( msg.data.imageData, msg.data.params );\n\t\t\t\t\t\t\n\t\t\tself.postMessage( {\n\t\t\t\tpolygonJSONStr: JSON.stringify( polygons )\n\t\t\t} );\n\t\t} catch ( err ) {\n\t\t\tself.postMessage( { err: err.message || err } );\n\t\t}\n\n\t} else {\n\t\tif ( msg.data.imageData ) {\n\t\t\tself.postMessage( { err: 'Parameters are missing.' } );\n\t\t} else {\n\t\t\tself.postMessage( { err: 'ImageData is missing.' } );\n\t\t}\n\t}\n\t\n\tself.close();\n};\n"],{type:"text/javascript"}))),i={getParams:function(){return t},getInput:u,getOutput:c},s={fromImage:function(t){return d(y,t)},fromImageSync:function(t){return d(y,t,!0)},fromImageData:function(t){return d((function(t){return t}),t)},fromImageDataSync:function(t){return d((function(t){return t}),t,!0)}},l={toData:function(t){return p((function(t){return t}),t)},toDataSync:function(t){return p((function(t){return t}),t,!0)},toDataURL:function(t){return p(w,t)},toDataURLSync:function(t){return p(w,t,!0)},toImageData:function(t){return p(v,t)},toImageDataSync:function(t){return p(v,t,!0)},toSVG:function(t){return p(D,t)},toSVGSync:function(t){return p(D,t,!0)}};function u(){var t=f({},i);return n||f(t,s),t}function c(){var t=f({},i);return e||f(t,l),t}function d(t,e,r){return a=!!r,n=function(){return a?t(e):new Promise((function(n,a){try{n(t(e))}catch(t){a(t)}}))},g()?h():c()}function p(t,n,a){return r=!!a,e=function(e,a){return r?t(e,a,n):new Promise((function(r,o){try{r(t(e,a,n))}catch(t){o(t)}}))},g()?h():u()}function g(){return n&&e}function h(){if(a&&r){var i=n(t),s=G(i,t);return e(s,i)}return new Promise((function(i,s){var l,u;new Promise((function(t,e){if(a)try{t(n(u))}catch(t){e(t)}else n(u).then(t,e)})).then((function(n){return function(t,n){return new Promise((function(e,a){o.addEventListener("message",(function(t){if(t.data&&t.data.polygonJSONStr){var n=JSON.parse(t.data.polygonJSONStr);e(n)}else t.data&&t.data.err?a(t.data.err):a(t)})),o.postMessage({params:n,imageData:t,imageDataWidth:t.width,imageDataHeight:t.height})}))}(l=n,t)}),s).then((function(t){return function(t,n){return new Promise((function(a,o){if(r)try{a(e(t,n))}catch(t){o(t)}else e(t,n).then(a,o)}))}(t,l)}),s).then((function(t){i(t)}),s)}))}return u()}},t.exports=e()}).call(this,e(1))},function(t,n){var e;e=function(){return this}();try{e=e||new Function("return this")()}catch(t){"object"==typeof window&&(e=window)}t.exports=e},function(t,n,e){"use strict";e.r(n),e.d(n,"getTriangulationData",(function(){return i})),e.d(n,"invokePolygons",(function(){return l}));var a=e(0),r=e.n(a);const o=t=>{const n=document.createElement("div");return n.innerHTML=t.trim(),n.firstElementChild};var i=({image:t,params:n})=>r()(n).fromImage(t).toSVG().then(o).then(t=>({height:t.getAttribute("height"),width:t.getAttribute("width"),polygons:t.querySelectorAll("polygon")})).then(t=>({...t,polygons:Array.from(t.polygons).map(n=>({points:n.getAttribute("points").split(" ").map(t=>t.split(",")).map(([n,e])=>`${n/t.width*100}% ${e/t.height*100}%`).join(","),color:n.getAttribute("fill")}))}));const s={fade:{pre:({duration:t,color:n,points:e})=>`\n      clip-path: polygon(${e});\n      background: ${n};\n      left: 0;\n      right: 0;\n      top: 0;\n      bottom: 0;\n      position: absolute;\n      opacity: 0;\n      transition: opacity ${t}s cubic-bezier(.7,.3,0,1);`,post:()=>"opacity: 1;"},fly:{pre:({duration:t,points:n})=>`\n        clip-path: polygon(${n.split(",").map(t=>t.split(" ")).map(([t,n])=>`${1*t.replace("%","")+30*Math.random()}% ${n}`).join(",")});\n        background: transparent;\n        left: 0;\n        right: 0;\n        top: 0;\n        bottom: 0;\n        position: absolute;\n        transition: -webkit-clip-path ${t}s cubic-bezier(.7, .3, 0, 1), clip-path ${t}s cubic-bezier(.7, .3, 0, 1), background-color ${t}s cubic-bezier(.7, .3, 0, 1);`,post:({points:t,color:n})=>`\n      clip-path: polygon(${t});\n      background-color: ${n};`}};var l=({data:t,animation:n,container:e})=>Promise.all(t.polygons.map((t,a)=>{const{polygon:r,promise:o}=(({points:t,color:n,idx:e,type:a="fade",duration:r=.5})=>{const o=document.createElement("div");o.classList.add("polygon"),o.style=s[a].pre({duration:r,color:n,points:t});const i=new Promise(i=>setTimeout(()=>{o.style=o.getAttribute("style")+s[a].post({duration:r,color:n,points:t}),i(o)},100*e/20));return{polygon:o,promise:i}})({...t,idx:a,duration:n.duration,type:n.type});return e.append(r),o}))}])}));