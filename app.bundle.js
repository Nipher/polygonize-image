/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/polygonize-image/dist/polygons.js":
/*!********************************************************!*\
  !*** ./node_modules/polygonize-image/dist/polygons.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,n){if(true)module.exports=n();else { var a, e; }}(window,(function(){return function(t){var n={};function e(a){if(n[a])return n[a].exports;var r=n[a]={i:a,l:!1,exports:{}};return t[a].call(r.exports,r,r.exports,e),r.l=!0,r.exports}return e.m=t,e.c=n,e.d=function(t,n,a){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:a})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var a=Object.create(null);if(e.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var r in t)e.d(a,r,function(n){return t[n]}.bind(null,r));return a},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=2)}([function(t,n,e){(function(n){var e;e=function(){"use strict";function t(t,n,e){return t<n?n:t>e?e:t}var e=function(t,n){void 0===t&&(t=300),void 0===n&&(n=150),"undefined"==typeof window?(this.canvasEl={width:t,height:n},this.ctx=null):(this.canvasEl=document.createElement("canvas"),this.canvasEl.width=t,this.canvasEl.height=n,this.ctx=this.canvasEl.getContext("2d"))},a={width:{configurable:!0},height:{configurable:!0}};function r(t,n,a,r){var o=!(!n||!n.backgroundColor)&&n.backgroundColor,i=new e(t.width*a,t.height*a,r),s=i.getContext("2d");return o&&(s.fillStyle=o,s.fillRect(0,0,t.width*a,t.height*a),s.fillStyle="transparent"),{canvas:i,ctx:s}}e.prototype.getContext=function(){return this.ctx},e.prototype.toDataURL=function(t,n,e){if("function"!=typeof e)return this.canvasEl.toDataURL(t,n);e(this.canvasEl.toDataURL(t,n))},a.width.get=function(){return this.canvasEl.width},a.width.set=function(t){this.canvasEl.width=t},a.height.get=function(){return this.canvasEl.height},a.height.set=function(t){this.canvasEl.height=t},Object.defineProperties(e.prototype,a),"undefined"!=typeof window&&(e.Image=Image);var o=.7,i=4,s=!0,l=!0,u=.5,c="miter",d=700,p=50,g=!1,h=["miter","round","bevel"];function m(n){return"object"!=typeof(n=function(t){var n=!1;if(void 0!==t)try{n=JSON.parse(JSON.stringify(t))}catch(t){}return n}(n))&&(n={}),"number"!=typeof n.accuracy||isNaN(n.accuracy)?n.accuracy=o:n.accuracy=t(n.accuracy,0,1),("number"!=typeof n.blur||isNaN(n.blur))&&(n.blur=i),n.blur<=0&&(n.blur=1),"string"!=typeof n.fill&&"boolean"!=typeof n.fill&&(n.fill=s),"string"!=typeof n.stroke&&"boolean"!=typeof n.stroke&&(n.stroke=l),("number"!=typeof n.strokeWidth||isNaN(n.strokeWidth))&&(n.strokeWidth=u),"number"!=typeof n.threshold||isNaN(n.threshold)?n.threshold=p:n.threshold=t(n.threshold,1,100),"string"==typeof n.lineJoin&&-1!==h.indexOf(n.lineJoin)||(n.lineJoin=c),n.gradients&&n.fill?n.gradients=!0:n.gradients=!1,n.gradients&&(("number"!=typeof n.gradientStops||isNaN(n.gradientStops)||n.gradientStops<2)&&(n.gradientStops=2),n.gradientStops=Math.round(n.gradientStops)),("number"!=typeof n.vertexCount||isNaN(n.vertexCount))&&(n.vertexCount=d),n.vertexCount<=0&&(n.vertexCount=1),"string"!=typeof n.transparentColor&&"boolean"!=typeof n.transparentColor&&(n.transparentColor=g),!0===typeof n.transparentColor&&(n.transparentColor=!1),"string"==typeof n.transparentColor&&(n.transparentColor=function(t){var n=r({width:1,height:1},{},1,!0).ctx;n.fillStyle=t,n.fillRect(0,0,1,1);var e=n.getImageData(0,0,1,1).data;return{r:e[0],g:e[1],b:e[2],a:e[3]/255}}(n.transparentColor)),n}function y(t){if(t instanceof HTMLImageElement){if(!t.naturalWidth||!t.naturalHeight||!1===t.complete)throw new Error("This this image hasn't finished loading: "+t.src);var n=new e(t.naturalWidth,t.naturalHeight),a=n.getContext("2d");a.drawImage(t,0,0,n.width,n.height);var r=a.getImageData(0,0,n.width,n.height);return r.data&&r.data.length&&(void 0===r.width&&(r.width=t.naturalWidth),void 0===r.height&&(r.height=t.naturalHeight)),r}throw new Error("This object does not seem to be an image.")}var f=Object.assign;function x(t){var n=f({a:1},t);return"rgba("+n.r+", "+n.g+", "+n.b+", "+n.a+")"}function b(t,n,e,a){return a=a||1,n.forEach((function(n,e){if(t.beginPath(),t.moveTo(n.a.x*a,n.a.y*a),t.lineTo(n.b.x*a,n.b.y*a),t.lineTo(n.c.x*a,n.c.y*a),t.lineTo(n.a.x*a,n.a.y*a),n.gradient){var r=t.createLinearGradient(n.gradient.x1*a,n.gradient.y1*a,n.gradient.x2*a,n.gradient.y2*a),o=n.gradient.colors.length-1;n.gradient.colors.forEach((function(t,n){var e=x(t);console.log(t),r.addColorStop(n/o,e)})),t.fillStyle=r,t.fill(),n.strokeWidth>0&&(t.strokeStyle=r,t.lineWidth=n.strokeWidth*a,t.lineJoin=n.lineJoin,t.stroke())}else n.fill&&(t.fillStyle=x(n.fill),t.fill()),n.strokeColor&&(t.strokeStyle=x(n.strokeColor),t.lineWidth=n.strokeWidth*a,t.lineJoin=n.lineJoin,t.stroke());t.closePath()})),t}function v(t,n,e){var a=e&&e.dpr?e.dpr:1,o=r(n,e,a,!0).ctx;return b(o,t,0,a),o.getImageData(0,0,n.width*a,n.height*a)}function w(t,n,e){var a=e&&e.dpr?e.dpr:1,o=r(n,e,a);return b(o.ctx,t,0,a),o.canvas.toDataURL()}function _(t){var n=t.toString(16);return 1==n.length?"0"+n:n}function k(t){var n=t.r,e=t.g,a=t.b;return"#"+_(n)+_(e)+_(a)}function D(t,n){var e="";t.length&&t[0].gradient&&(e="<defs>");var a="";return t.forEach((function(t,n){var r=t.a,o=t.b,i=t.c;if(a+='<polygon points="'+r.x+","+r.y+" "+o.x+","+o.y+" "+i.x+","+i.y+'"',t.gradient){var s=t.boundingBox,l=((t.gradient.x1-s.x)/s.width*100).toFixed(3),u=((t.gradient.y1-s.y)/s.height*100).toFixed(3),c=((t.gradient.x2-s.x)/s.width*100).toFixed(3),d=((t.gradient.y2-s.y)/s.height*100).toFixed(3);e+='\n\t<linearGradient id="gradient-'+n+'" x1="'+l+'%" y1="'+u+'%" x2="'+c+'%" y2="'+d+'%">';var p=t.gradient.colors.length-1;t.gradient.colors.forEach((function(t,n){var a=k(t),r=t.a<1?' stop-opacity="'+t.a+'"':"",o=(n/p*100).toFixed(3);e+='\n\t\t\t\t\t<stop offset="'+o+'%" stop-color="'+a+'"'+r+"/>\n\t\t\t\t"})),e+="</linearGradient>",a+=' fill="url(#gradient-'+n+')"',t.strokeWidth>0&&(a+=' stroke="url(#gradient-'+n+')" stroke-width="'+t.strokeWidth+'" stroke-linejoin="'+t.lineJoin+'"')}else{if(t.fill){var g=k(t.fill),h=t.fill.a<1?' fill-opacity="'+t.fill.a+'"':"";a+=' fill="'+g+'"'+h}else a+=' fill="transparent"';if(t.strokeColor){var m=k(t.strokeColor),y=t.strokeColor.a<1?' stroke-opacity="'+t.strokeColor.a+'"':"";a+=' stroke="'+m+'" stroke-width="'+t.strokeWidth+'" stroke-linejoin="'+t.lineJoin+'"'+y}}a+="/>\n\t"})),e.length&&(e+="\n\t\t</defs>"),'<?xml version="1.0" standalone="yes"?>\n<svg width="'+n.width+'" height="'+n.height+'" xmlns="http://www.w3.org/2000/svg" version="1.1" >\n\t'+e+"\n\t"+a+"\n</svg>"}function I(t,n){return t(n={exports:{}},n.exports),n.exports}"undefined"!=typeof window?window:void 0!==n||"undefined"!=typeof self&&self;var C=I((function(t){function n(t,n,e){this.a=t,this.b=n,this.c=e;var a,r,o,i,s=n.x-t.x,l=n.y-t.y,u=e.x-t.x,c=e.y-t.y,d=s*(t.x+n.x)+l*(t.y+n.y),p=u*(t.x+e.x)+c*(t.y+e.y),g=2*(s*(e.y-n.y)-l*(e.x-n.x));Math.abs(g)<1e-6?(a=Math.min(t.x,n.x,e.x),r=Math.min(t.y,n.y,e.y),o=.5*(Math.max(t.x,n.x,e.x)-a),i=.5*(Math.max(t.y,n.y,e.y)-r),this.x=a+o,this.y=r+i,this.r=o*o+i*i):(this.x=(c*d-l*p)/g,this.y=(s*p-u*d)/g,o=this.x-t.x,i=this.y-t.y,this.r=o*o+i*i)}function e(t,n){return n.x-t.x}function a(t){var n,e,a,r,o,i=t.length;t:for(;i;)for(e=t[--i],n=t[--i],a=i;a;)if(o=t[--a],n===(r=t[--a])&&e===o||n===o&&e===r){t.splice(i,2),t.splice(a,2),i-=2;continue t}}n.prototype.draw=function(t){t.beginPath(),t.moveTo(this.a.x,this.a.y),t.lineTo(this.b.x,this.b.y),t.lineTo(this.c.x,this.c.y),t.closePath(),t.stroke()},t.exports={Triangle:n,triangulate:function(t){if(t.length<3)return[];t.sort(e);for(var r=t.length-1,o=t[r].x,i=t[0].x,s=t[r].y,l=s;r--;)t[r].y<s&&(s=t[r].y),t[r].y>l&&(l=t[r].y);var u,c,d,p=i-o,g=l-s,h=p>g?p:g,m=.5*(i+o),y=.5*(l+s),f=[new n({x:m-20*h,y:y-h,__sentinel:!0},{x:m,y:y+20*h,__sentinel:!0},{x:m+20*h,y:y-h,__sentinel:!0})],x=[],b=[];for(r=t.length;r--;){for(b.length=0,u=f.length;u--;)(p=t[r].x-f[u].x)>0&&p*p>f[u].r?(x.push(f[u]),f.splice(u,1)):p*p+(g=t[r].y-f[u].y)*g>f[u].r||(b.push(f[u].a,f[u].b,f[u].b,f[u].c,f[u].c,f[u].a),f.splice(u,1));for(a(b),u=b.length;u;)d=b[--u],c=b[--u],f.push(new n(c,d,t[r]))}for(Array.prototype.push.apply(x,f),r=x.length;r--;)(x[r].a.__sentinel||x[r].b.__sentinel||x[r].c.__sentinel)&&x.splice(r,1);return x}}})),P=(C.Triangle,C.triangulate),S=I((function(t,n){!function(e){function a(t){if(!(this instanceof a))return new a(t);var n=t.width,e=t.height,r=[[-1,0,1],[-2,0,2],[-1,0,1]],o=[[-1,-2,-1],[0,0,0],[1,2,1]],i=[],s=[];function l(t){return function(e,a,r){return t[4*(n*a+e)+(r=r||0)]}}var u,c,d=l(t.data);for(c=0;c<e;c++)for(u=0;u<n;u++){var p=(d(u,c,0)+d(u,c,1)+d(u,c,2))/3;s.push(p,p,p,255)}for(d=l(s),c=0;c<e;c++)for(u=0;u<n;u++){var g=r[0][0]*d(u-1,c-1)+r[0][1]*d(u,c-1)+r[0][2]*d(u+1,c-1)+r[1][0]*d(u-1,c)+r[1][1]*d(u,c)+r[1][2]*d(u+1,c)+r[2][0]*d(u-1,c+1)+r[2][1]*d(u,c+1)+r[2][2]*d(u+1,c+1),h=o[0][0]*d(u-1,c-1)+o[0][1]*d(u,c-1)+o[0][2]*d(u+1,c-1)+o[1][0]*d(u-1,c)+o[1][1]*d(u,c)+o[1][2]*d(u+1,c)+o[2][0]*d(u-1,c+1)+o[2][1]*d(u,c+1)+o[2][2]*d(u+1,c+1),m=Math.sqrt(g*g+h*h)>>>0;i.push(m,m,m,255)}var y=i;return"function"==typeof Uint8ClampedArray&&(y=new Uint8ClampedArray(i)),y.toImageData=function(){return a.toImageData(y,n,e)},y}function r(t,n,e){return{width:n,height:e,data:t}}a.toImageData=function(t,n,e){if("function"==typeof ImageData&&"[object Uint16Array]"===Object.prototype.toString.call(t))return new ImageData(t,n,e);if("object"==typeof window&&"object"==typeof window.document){var a=document.createElement("canvas");if("function"==typeof a.getContext){var o=a.getContext("2d").createImageData(n,e);return o.data.set(t),o}return new r(t,n,e)}return new r(t,n,e)},t.exports&&(n=t.exports=a),n.Sobel=a}()}));function A(t){return t&&"number"==typeof t.width&&"number"==typeof t.height&&t.data&&"number"==typeof t.data.length&&"object"==typeof t.data}function E(t){if(A(t)){if("undefined"==typeof Uint8ClampedArray){if("undefined"==typeof window)throw new Error("Can't copy imageData in webworker without Uint8ClampedArray support.");return j(t)}var n,e=new Uint8ClampedArray(t.data);if("undefined"==typeof ImageData)return{width:t.width,height:t.height,data:e};try{n=new ImageData(e,t.width,t.height)}catch(e){if("undefined"==typeof window)throw new Error("Can't copy imageData in webworker without proper ImageData() support.");n=j(t)}return n}throw new Error("Given imageData object is not useable.")}function j(t){var n=new e(t.width,t.height).getContext("2d");return n.putImageData(t,0,0),n.getImageData(0,0,t.width,t.height)}S.Sobel;var O=[512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,289,287,285,282,280,278,275,273,271,269,267,265,263,261,259],M=[9,11,12,13,13,14,14,15,15,15,15,16,16,16,16,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24];function T(){this.r=0,this.g=0,this.b=0,this.a=0,this.next=null}function R(t,n,e){var a=t+"|"+n;e[a]||(e[a]={x:t,y:n}),a=null}function B(n,e,a){var r=(0|t(n.x,1,e.width-2))+(0|t(n.y,1,e.height-2))*e.width<<2;r>=e.data.length&&(r=e.data.length-5);var o=e.data[r+3]/255;return a&&0===o?a:{r:e.data[r],g:e.data[r+1],b:e.data[r+2],a:o}}function N(t){return{x:.33333*(t.a.x+t.b.x+t.c.x),y:.33333*(t.a.y+t.b.y+t.c.y)}}function W(t){return 0===t.a}function L(t){var n=function(t){if("string"==typeof t){var n=[0,0,0,0];return"#"===t[0]&&(t.length<7&&(t="#"+t[1]+t[1]+t[2]+t[2]+t[3]+t[3]+(t.length>4?t[4]+t[4]:"")),n=[parseInt(t.substr(1,2),16),parseInt(t.substr(3,2),16),parseInt(t.substr(5,2),16),t.length>7?parseInt(t.substr(7,2),16)/255:1]),0===t.indexOf("rgb")&&(t.includes("rgba")||(t+=",1"),n=t.match(/[\.\d]+/g).map((function(t){return+t}))),n}}(t);return n?{r:n[0],g:n[1],b:n[2],a:n[3]}:void 0}function F(t){var n=[t.r,t.g,t.b].map((function(t){return(t/=255)<=.03928?t/12.92:Math.pow((t+.055)/1.055,2.4)}));return.2126*n[0]+.7152*n[1]+.0722*n[2]}function H(t,n,e){return t.forEach((function(t){var a={};"abc".split("").forEach((function(r){var o=B(t[r],n,e.transparentColor);a[r]={key:r,color:o,x:t[r].x,y:t[r].y},a[r].luminance=F(a[r].color);var i="abc".replace(r,"").split("");a[r].median={x:(t[i[0]].x+t[i[1]].x)/2,y:(t[i[0]].y+t[i[1]].y)/2},a[r].medianColor=B(a[r].median,n,e.transparentColor),a[r].medianLuminance=F(a[r].medianColor)}));for(var r,o,i,s,l=[a.a,a.b,a.c].sort((function(t,n){return Math.abs(t.luminance-t.medianLuminance)-Math.abs(n.luminance-n.medianLuminance)})),u=l[0],c=l[0],d=u.median,p=[c],g=(r=c,i=(o=d).x-r.x,s=o.y-r.y,Math.sqrt(i*i+s*s)),h=1,m=e.gradientStops-2;h<m;h++){var y=h*(g/e.gradientStops)/g,f={x:c.x+y*(d.x-c.x),y:c.y+y*(d.y-c.y)};p.push(f)}p.push(d),t.gradient={x1:u.x,y1:u.y,x2:u.median.x,y2:u.median.y,colors:p.map((function(t){return B(t,n,e.transparentColor)}))},e.stroke&&(t.strokeWidth=e.strokeWidth,t.lineJoin=e.lineJoin),a=null})),t}function G(t,n){if(A(t)){var e={width:t.width,height:t.height},a=E(t),r=E(t),o=function(t){for(var n,e=t.data.length,a=0;a<e;a+=4)n=.34*t.data[a]+.5*t.data[a+1]+.16*t.data[a+2],t.data[a]=n,t.data[a+1]=n,t.data[a+2]=n;return t}(function(t,n,e,a,r,o){var i,s,l,u,c,d,p,g,h,m,y,f,x,b,v,w,_,k,D,I,C,P,S,A,E=t.data,j=o+o+1,R=a-1,B=r-1,N=o+1,W=N*(N+1)/2,L=new T,F=L;for(l=1;l<j;l++)if(F=F.next=new T,l==N)var H=F;F.next=L;var G=null,U=null;p=d=0;var J=O[o],Y=M[o];for(s=0;s<r;s++){for(w=_=k=D=g=h=m=y=0,f=N*(I=E[d]),x=N*(C=E[d+1]),b=N*(P=E[d+2]),v=N*(S=E[d+3]),g+=W*I,h+=W*C,m+=W*P,y+=W*S,F=L,l=0;l<N;l++)F.r=I,F.g=C,F.b=P,F.a=S,F=F.next;for(l=1;l<N;l++)u=d+((R<l?R:l)<<2),g+=(F.r=I=E[u])*(A=N-l),h+=(F.g=C=E[u+1])*A,m+=(F.b=P=E[u+2])*A,y+=(F.a=S=E[u+3])*A,w+=I,_+=C,k+=P,D+=S,F=F.next;for(G=L,U=H,i=0;i<a;i++)E[d+3]=S=y*J>>Y,0!=S?(S=255/S,E[d]=(g*J>>Y)*S,E[d+1]=(h*J>>Y)*S,E[d+2]=(m*J>>Y)*S):E[d]=E[d+1]=E[d+2]=0,g-=f,h-=x,m-=b,y-=v,f-=G.r,x-=G.g,b-=G.b,v-=G.a,u=p+((u=i+o+1)<R?u:R)<<2,g+=w+=G.r=E[u],h+=_+=G.g=E[u+1],m+=k+=G.b=E[u+2],y+=D+=G.a=E[u+3],G=G.next,f+=I=U.r,x+=C=U.g,b+=P=U.b,v+=S=U.a,w-=I,_-=C,k-=P,D-=S,U=U.next,d+=4;p+=a}for(i=0;i<a;i++){for(_=k=D=w=h=m=y=g=0,f=N*(I=E[d=i<<2]),x=N*(C=E[d+1]),b=N*(P=E[d+2]),v=N*(S=E[d+3]),g+=W*I,h+=W*C,m+=W*P,y+=W*S,F=L,l=0;l<N;l++)F.r=I,F.g=C,F.b=P,F.a=S,F=F.next;for(c=a,l=1;l<=o;l++)d=c+i<<2,g+=(F.r=I=E[d])*(A=N-l),h+=(F.g=C=E[d+1])*A,m+=(F.b=P=E[d+2])*A,y+=(F.a=S=E[d+3])*A,w+=I,_+=C,k+=P,D+=S,F=F.next,l<B&&(c+=a);for(d=i,G=L,U=H,s=0;s<r;s++)E[3+(u=d<<2)]=S=y*J>>Y,S>0?(S=255/S,E[u]=(g*J>>Y)*S,E[u+1]=(h*J>>Y)*S,E[u+2]=(m*J>>Y)*S):E[u]=E[u+1]=E[u+2]=0,g-=f,h-=x,m-=b,y-=v,f-=G.r,x-=G.g,b-=G.b,v-=G.a,u=i+((u=s+N)<B?u:B)*a<<2,g+=w+=G.r=E[u],h+=_+=G.g=E[u+1],m+=k+=G.b=E[u+2],y+=D+=G.a=E[u+3],G=G.next,f+=I=U.r,x+=C=U.g,b+=P=U.b,v+=S=U.a,w-=I,_-=C,k-=P,D-=S,U=U.next,d+=a}return t}(a,0,0,e.width,e.height,n.blur)),i=function(t,n,e,a,r){var o={},i=Math.max(~~(n*(1-e)),5),s=Math.round(Math.sqrt(i)),l=~~(a/s),u=~~(r/Math.round(Math.ceil(i/s))),c=0,d=0,p=0;for(p=0;p<r;p+=u)for(d=++c%2==0?~~(l/2):0;d<a;d+=l)d<a&&p<r&&R(~~(d+Math.cos(p)*u),~~(p+Math.sin(d)*l),o);R(0,0,o),R(a-1,0,o),R(a-1,r-1,o),R(0,r-1,o);var g=n-Object.keys(o).length,h=t.length,m=~~(h/g);if(n>0&&m>0){var y=0;for(y=0;y<h;y+=m)R(t[y].x,t[y].y,o)}return t=null,Object.keys(o).map((function(t){return o[t]}))}(function(t,n){var e,a,r,o,i,s,l,u,c,d=t.width,p=t.height,g=t.data,h=[];for(a=0;a<p;a+=2)for(e=0;e<d;e+=2){for(u=c=0,r=-1;r<=1;r++)if(l=(s=a+r)*d,s>=0&&s<p)for(o=-1;o<=1;o++)(i=e+o)>=0&&i<d&&(u+=g[i+l<<2],c++);c&&(u/=c),u>n&&h.push({x:e,y:a})}return h}(S(o).toImageData(),n.threshold),n.vertexCount,n.accuracy,e.width,e.height),s=P(i);return s=function(t,n,e){return t.forEach((function(t){var n,e,a,r,o;t.boundingBox=(n=[t.a,t.b,t.c],e=1/0,a=-1/0,r=1/0,o=-1/0,n.forEach((function(t){t.x<e&&(e=t.x),t.y<r&&(r=t.y),t.x>a&&(a=t.x),t.y>o&&(o=t.y)})),{x:e,y:r,width:a-e,height:o-r})})),t.filter((function(t){return t.boundingBox.width>0&&t.boundingBox.height>0}))}(s),n.transparentColor||(s=function(t,n){return t.filter((function(t){return!W(B(N(t),n))}))}(s,r)),s=!0===n.fill&&!0===n.gradients?H(s,r,n):function(t,n,e){var a=e.fill,r=e.stroke,o=e.strokeWidth,i=e.lineJoin,s=e.transparentColor,l=!!a&&L(a),u=!!r&&L(r),c=function(t,n){var e=W(t)&&s;return n&&!e?n:e?s:t};return t.forEach((function(t){var e=B(N(t),n);a&&(t.fill=c(e,l)),r&&(t.strokeColor=c(e,u),t.strokeWidth=o,t.lineJoin=i)})),t}(s,r,n)}throw new Error("Can't work with the imageData provided. It seems to be corrupt.")}return function(t){t=m(t);var n,e,a=!1,r=!1,o=new Worker(URL.createObjectURL(new Blob(["var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar delaunay = createCommonjsModule(function (module) {\nfunction Triangle(a, b, c) {\n  this.a = a;\n  this.b = b;\n  this.c = c;\n\n  var A = b.x - a.x,\n      B = b.y - a.y,\n      C = c.x - a.x,\n      D = c.y - a.y,\n      E = A * (a.x + b.x) + B * (a.y + b.y),\n      F = C * (a.x + c.x) + D * (a.y + c.y),\n      G = 2 * (A * (c.y - b.y) - B * (c.x - b.x)),\n      minx, miny, dx, dy;\n\n  /* If the points of the triangle are collinear, then just find the\n   * extremes and use the midpoint as the center of the circumcircle. */\n  if(Math.abs(G) < 0.000001) {\n    minx = Math.min(a.x, b.x, c.x);\n    miny = Math.min(a.y, b.y, c.y);\n    dx   = (Math.max(a.x, b.x, c.x) - minx) * 0.5;\n    dy   = (Math.max(a.y, b.y, c.y) - miny) * 0.5;\n\n    this.x = minx + dx;\n    this.y = miny + dy;\n    this.r = dx * dx + dy * dy;\n  }\n\n  else {\n    this.x = (D*E - B*F) / G;\n    this.y = (A*F - C*E) / G;\n    dx = this.x - a.x;\n    dy = this.y - a.y;\n    this.r = dx * dx + dy * dy;\n  }\n}\n\nTriangle.prototype.draw = function(ctx) {\n  ctx.beginPath();\n  ctx.moveTo(this.a.x, this.a.y);\n  ctx.lineTo(this.b.x, this.b.y);\n  ctx.lineTo(this.c.x, this.c.y);\n  ctx.closePath();\n  ctx.stroke();\n};\n\nfunction byX(a, b) {\n  return b.x - a.x\n}\n\nfunction dedup(edges) {\n  var j = edges.length,\n      a, b, i, m, n;\n\n  outer: while(j) {\n    b = edges[--j];\n    a = edges[--j];\n    i = j;\n    while(i) {\n      n = edges[--i];\n      m = edges[--i];\n      if((a === m && b === n) || (a === n && b === m)) {\n        edges.splice(j, 2);\n        edges.splice(i, 2);\n        j -= 2;\n        continue outer\n      }\n    }\n  }\n}\n\nfunction triangulate(vertices) {\n  /* Bail if there aren't enough vertices to form any triangles. */\n  if(vertices.length < 3)\n    { return [] }\n\n  /* Ensure the vertex array is in order of descending X coordinate\n   * (which is needed to ensure a subquadratic runtime), and then find\n   * the bounding box around the points. */\n  vertices.sort(byX);\n\n  var i    = vertices.length - 1,\n      xmin = vertices[i].x,\n      xmax = vertices[0].x,\n      ymin = vertices[i].y,\n      ymax = ymin;\n\n  while(i--) {\n    if(vertices[i].y < ymin) { ymin = vertices[i].y; }\n    if(vertices[i].y > ymax) { ymax = vertices[i].y; }\n  }\n\n  /* Find a supertriangle, which is a triangle that surrounds all the\n   * vertices. This is used like something of a sentinel value to remove\n   * cases in the main algorithm, and is removed before we return any\n   * results.\n   *\n   * Once found, put it in the \"open\" list. (The \"open\" list is for\n   * triangles who may still need to be considered; the \"closed\" list is\n   * for triangles which do not.) */\n  var dx     = xmax - xmin,\n      dy     = ymax - ymin,\n      dmax   = (dx > dy) ? dx : dy,\n      xmid   = (xmax + xmin) * 0.5,\n      ymid   = (ymax + ymin) * 0.5,\n      open   = [\n        new Triangle(\n          {x: xmid - 20 * dmax, y: ymid -      dmax, __sentinel: true},\n          {x: xmid            , y: ymid + 20 * dmax, __sentinel: true},\n          {x: xmid + 20 * dmax, y: ymid -      dmax, __sentinel: true}\n        )\n      ],\n      closed = [],\n      edges = [],\n      j, a, b;\n\n  /* Incrementally add each vertex to the mesh. */\n  i = vertices.length;\n  while(i--) {\n    /* For each open triangle, check to see if the current point is\n     * inside it's circumcircle. If it is, remove the triangle and add\n     * it's edges to an edge list. */\n    edges.length = 0;\n    j = open.length;\n    while(j--) {\n      /* If this point is to the right of this triangle's circumcircle,\n       * then this triangle should never get checked again. Remove it\n       * from the open list, add it to the closed list, and skip. */\n      dx = vertices[i].x - open[j].x;\n      if(dx > 0 && dx * dx > open[j].r) {\n        closed.push(open[j]);\n        open.splice(j, 1);\n        continue\n      }\n\n      /* If not, skip this triangle. */\n      dy = vertices[i].y - open[j].y;\n      if(dx * dx + dy * dy > open[j].r)\n        { continue }\n\n      /* Remove the triangle and add it's edges to the edge list. */\n      edges.push(\n        open[j].a, open[j].b,\n        open[j].b, open[j].c,\n        open[j].c, open[j].a\n      );\n      open.splice(j, 1);\n    }\n\n    /* Remove any doubled edges. */\n    dedup(edges);\n\n    /* Add a new triangle for each edge. */\n    j = edges.length;\n    while(j) {\n      b = edges[--j];\n      a = edges[--j];\n      open.push(new Triangle(a, b, vertices[i]));\n    }\n  }\n\n  /* Copy any remaining open triangles to the closed list, and then\n   * remove any triangles that share a vertex with the supertriangle. */\n  Array.prototype.push.apply(closed, open);\n\n  i = closed.length;\n  while(i--)\n    { if(closed[i].a.__sentinel ||\n       closed[i].b.__sentinel ||\n       closed[i].c.__sentinel)\n      { closed.splice(i, 1); } }\n\n  /* Yay, we're done! */\n  return closed\n}\n\n{\n    module.exports = {\n        Triangle: Triangle,\n        triangulate: triangulate\n    };\n}\n});\nvar delaunay_1 = delaunay.Triangle;\nvar delaunay_2 = delaunay.triangulate;\n\nvar sobel = createCommonjsModule(function (module, exports) {\n(function(root) {\n\n  function Sobel(imageData) {\n    if (!(this instanceof Sobel)) {\n      return new Sobel(imageData);\n    }\n\n    var width = imageData.width;\n    var height = imageData.height;\n\n    var kernelX = [\n      [-1,0,1],\n      [-2,0,2],\n      [-1,0,1]\n    ];\n\n    var kernelY = [\n      [-1,-2,-1],\n      [0,0,0],\n      [1,2,1]\n    ];\n\n    var sobelData = [];\n    var grayscaleData = [];\n\n    function bindPixelAt(data) {\n      return function(x, y, i) {\n        i = i || 0;\n        return data[((width * y) + x) * 4 + i];\n      };\n    }\n\n    var data = imageData.data;\n    var pixelAt = bindPixelAt(data);\n    var x, y;\n\n    for (y = 0; y < height; y++) {\n      for (x = 0; x < width; x++) {\n        var r = pixelAt(x, y, 0);\n        var g = pixelAt(x, y, 1);\n        var b = pixelAt(x, y, 2);\n\n        var avg = (r + g + b) / 3;\n        grayscaleData.push(avg, avg, avg, 255);\n      }\n    }\n\n    pixelAt = bindPixelAt(grayscaleData);\n\n    for (y = 0; y < height; y++) {\n      for (x = 0; x < width; x++) {\n        var pixelX = (\n            (kernelX[0][0] * pixelAt(x - 1, y - 1)) +\n            (kernelX[0][1] * pixelAt(x, y - 1)) +\n            (kernelX[0][2] * pixelAt(x + 1, y - 1)) +\n            (kernelX[1][0] * pixelAt(x - 1, y)) +\n            (kernelX[1][1] * pixelAt(x, y)) +\n            (kernelX[1][2] * pixelAt(x + 1, y)) +\n            (kernelX[2][0] * pixelAt(x - 1, y + 1)) +\n            (kernelX[2][1] * pixelAt(x, y + 1)) +\n            (kernelX[2][2] * pixelAt(x + 1, y + 1))\n        );\n\n        var pixelY = (\n          (kernelY[0][0] * pixelAt(x - 1, y - 1)) +\n          (kernelY[0][1] * pixelAt(x, y - 1)) +\n          (kernelY[0][2] * pixelAt(x + 1, y - 1)) +\n          (kernelY[1][0] * pixelAt(x - 1, y)) +\n          (kernelY[1][1] * pixelAt(x, y)) +\n          (kernelY[1][2] * pixelAt(x + 1, y)) +\n          (kernelY[2][0] * pixelAt(x - 1, y + 1)) +\n          (kernelY[2][1] * pixelAt(x, y + 1)) +\n          (kernelY[2][2] * pixelAt(x + 1, y + 1))\n        );\n\n        var magnitude = Math.sqrt((pixelX * pixelX) + (pixelY * pixelY))>>>0;\n\n        sobelData.push(magnitude, magnitude, magnitude, 255);\n      }\n    }\n\n    var clampedArray = sobelData;\n\n    if (typeof Uint8ClampedArray === 'function') {\n      clampedArray = new Uint8ClampedArray(sobelData);\n    }\n\n    clampedArray.toImageData = function() {\n      return Sobel.toImageData(clampedArray, width, height);\n    };\n\n    return clampedArray;\n  }\n\n  Sobel.toImageData = function toImageData(data, width, height) {\n    if (typeof ImageData === 'function' && Object.prototype.toString.call(data) === '[object Uint16Array]') {\n      return new ImageData(data, width, height);\n    } else {\n      if (typeof window === 'object' && typeof window.document === 'object') {\n        var canvas = document.createElement('canvas');\n\n        if (typeof canvas.getContext === 'function') {\n          var context = canvas.getContext('2d');\n          var imageData = context.createImageData(width, height);\n          imageData.data.set(data);\n          return imageData;\n        } else {\n          return new FakeImageData(data, width, height);\n        }\n      } else {\n        return new FakeImageData(data, width, height);\n      }\n    }\n  };\n\n  function FakeImageData(data, width, height) {\n    return {\n      width: width,\n      height: height,\n      data: data\n    };\n  }\n\n  {\n    if (module.exports) {\n      exports = module.exports = Sobel;\n    }\n    exports.Sobel = Sobel;\n  }\n\n})(commonjsGlobal);\n});\nvar sobel_1 = sobel.Sobel;\n\nfunction isImageData (imageData) {\n\treturn (\n\t\timageData && \n\t\ttypeof imageData.width === 'number' &&\n\t\ttypeof imageData.height === 'number' &&\n\t\timageData.data &&\n\t\ttypeof imageData.data.length === 'number' &&\n\t\ttypeof imageData.data === 'object'\n\t);\n}\n\nvar Canvas = function Canvas ( width, height ) {\n\tif ( width === void 0 ) width = 300;\n\tif ( height === void 0 ) height = 150;\n\n\tif ( typeof window === 'undefined' ) {\n\t\tthis.canvasEl = { width: width, height: height };\n\t\tthis.ctx = null;\n\t} else {\n\t\tthis.canvasEl = document.createElement( 'canvas' );\n\t\tthis.canvasEl.width = width;\n\t\tthis.canvasEl.height = height;\n\t\tthis.ctx = this.canvasEl.getContext( '2d' );\n\t} \n};\n\nvar prototypeAccessors = { width: { configurable: true },height: { configurable: true } };\n\nCanvas.prototype.getContext = function getContext () {\n\treturn this.ctx;\n};\n\nCanvas.prototype.toDataURL = function toDataURL ( type, encoderOptions, cb ) {\n\tif ( typeof cb === 'function' ) {\n\t\tcb( this.canvasEl.toDataURL( type, encoderOptions ) );\n\t} else {\n\t\treturn this.canvasEl.toDataURL( type, encoderOptions );\n\t}\n};\n\t\nprototypeAccessors.width.get = function () {\n\treturn this.canvasEl.width;\n};\n\t\nprototypeAccessors.width.set = function ( newWidth ) {\n\tthis.canvasEl.width = newWidth;\n};\n\nprototypeAccessors.height.get = function () {\n\treturn this.canvasEl.height;\n};\n\nprototypeAccessors.height.set = function ( newHeight ) {\n\tthis.canvasEl.height = newHeight;\n};\n\nObject.defineProperties( Canvas.prototype, prototypeAccessors );\n\nif ( typeof window !== 'undefined' ) {\n\tCanvas.Image = Image;\n}\n\n// import Canvas from 'canvas';\n\nfunction copyImageData (imageData) {\n\tif ( isImageData ( imageData ) ) {\n\t\tif ( typeof Uint8ClampedArray === 'undefined' ) {\n\t\t\tif ( typeof window === 'undefined' ) {\n\t\t\t\tthrow new Error( \"Can't copy imageData in webworker without Uint8ClampedArray support.\" );\n\t\t\t\treturn imageData;\n\t\t\t} else {\n\t\t\t\treturn copyImageDataWithCanvas( imageData );\n\t\t\t}\n\t\t} else {\n\t\t\tvar clampedArray = new Uint8ClampedArray( imageData.data );\n\n\t\t\tif ( typeof ImageData === 'undefined' ) {\n\t\t\t\t// http://stackoverflow.com/a/15238036/229189\n\t\t\t\treturn {\n\t\t\t\t\twidth: imageData.width,\n\t\t\t\t\theight: imageData.height,\n\t\t\t\t\tdata: clampedArray\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// http://stackoverflow.com/a/15908922/229189#comment57192591_15908922\n\t\t\t\tvar result;\n\n\t\t\t\ttry {\n\t\t\t\t\tresult = new ImageData( clampedArray, imageData.width, imageData.height );\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\tif ( typeof window === 'undefined' ) {\n\t\t\t\t\t\tthrow new Error( \"Can't copy imageData in webworker without proper ImageData() support.\" );\n\t\t\t\t\t\tresult = imageData;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = copyImageDataWithCanvas( imageData );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tthrow new Error( 'Given imageData object is not useable.' );\n\t\treturn;\n\t}\n}\n\n// http://stackoverflow.com/a/11918126/229189\nfunction copyImageDataWithCanvas ( imageData ) {\n\tvar canvas = new Canvas( imageData.width, imageData.height );\n\tvar ctx = canvas.getContext( '2d' );\n\n\tctx.putImageData( imageData, 0, 0 );\n\t\t\t\t\n\treturn ctx.getImageData( 0, 0, imageData.width, imageData.height );\n}\n\n/*\n    StackBlur - a fast almost Gaussian Blur For Canvas\n\n    Version:     0.5\n    Author:        Mario Klingemann\n    Contact:     mario@quasimondo.com\n    Website:    http://www.quasimondo.com/StackBlurForCanvas\n    Twitter:    @quasimondo\n\n    In case you find this class useful - especially in commercial projects -\n    I am not totally unhappy for a small donation to my PayPal account\n    mario@quasimondo.de\n\n    Or support me on flattr:\n    https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript\n\n    Copyright (c) 2010 Mario Klingemann\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n    */\n\nvar mul_table = [\n    512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,\n    454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,\n    482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,\n    437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,\n    497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,\n    320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,\n    446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,\n    329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,\n    505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,\n    399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,\n    324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,\n    268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,\n    451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,\n    385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,\n    332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,\n    289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];\n\n\nvar shg_table = [\n    9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,\n    17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,\n    19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,\n    20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,\n    21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n    21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,\n    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,\n    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n    23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];\n\nfunction BlurStack () {\n\tthis.r = 0;\n\tthis.g = 0;\n\tthis.b = 0;\n\tthis.a = 0;\n\tthis.next = null;\n}\n\nfunction stackblur ( imageData, top_x, top_y, width, height, radius ) {\n\tvar pixels = imageData.data;\n\n\tvar x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum,\n\t\tr_out_sum, g_out_sum, b_out_sum, a_out_sum,\n\t\tr_in_sum, g_in_sum, b_in_sum, a_in_sum,\n\t\tpr, pg, pb, pa, rbs;\n\n\tvar div = radius + radius + 1;\n\tvar widthMinus1  = width - 1;\n\tvar heightMinus1 = height - 1;\n\tvar radiusPlus1  = radius + 1;\n\tvar sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;\n\n\tvar stackStart = new BlurStack();\n\tvar stack = stackStart;\n\t\n\tfor ( i = 1; i < div; i++ ) {\n\t\tstack = stack.next = new BlurStack();\n\t\tif (i == radiusPlus1) { var stackEnd = stack; }\n\t}\n\tstack.next = stackStart;\n\t\n\tvar stackIn = null;\n\tvar stackOut = null;\n\n\tyw = yi = 0;\n\n\tvar mul_sum = mul_table[radius];\n\tvar shg_sum = shg_table[radius];\n\n\tfor ( y = 0; y < height; y++ ) {\n\t\tr_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;\n\n\t\tr_out_sum = radiusPlus1 * ( pr = pixels[yi] );\n\t\tg_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );\n\t\tb_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );\n\t\ta_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );\n\n\t\tr_sum += sumFactor * pr;\n\t\tg_sum += sumFactor * pg;\n\t\tb_sum += sumFactor * pb;\n\t\ta_sum += sumFactor * pa;\n\n\t\tstack = stackStart;\n\n\t\tfor ( i = 0; i < radiusPlus1; i++ ) {\n\t\t\tstack.r = pr;\n\t\t\tstack.g = pg;\n\t\t\tstack.b = pb;\n\t\t\tstack.a = pa;\n\t\t\tstack = stack.next;\n\t\t}\n\n\t\tfor ( i = 1; i < radiusPlus1; i++ ) {\n\t\t\tp = yi + ( ( widthMinus1 < i ? widthMinus1 : i ) << 2 );\n\t\t\tr_sum += ( stack.r = ( pr = pixels[p] ) ) * ( rbs = radiusPlus1 - i );\n\t\t\tg_sum += ( stack.g = ( pg = pixels[p+1] ) ) * rbs;\n\t\t\tb_sum += ( stack.b = ( pb = pixels[p+2] ) ) * rbs;\n\t\t\ta_sum += ( stack.a = ( pa = pixels[p+3] ) ) * rbs;\n\n\t\t\tr_in_sum += pr;\n\t\t\tg_in_sum += pg;\n\t\t\tb_in_sum += pb;\n\t\t\ta_in_sum += pa;\n\n\t\t\tstack = stack.next;\n\t\t}\n\n\n\t\tstackIn = stackStart;\n\t\tstackOut = stackEnd;\n\n\t\tfor (x = 0; x < width; x++) {\n\t\t\tpixels[yi+3] = pa = (a_sum * mul_sum) >> shg_sum;\n\t\t\t\n\t\t\tif (pa != 0) {\n\t\t\t\tpa = 255 / pa;\n\t\t\t\tpixels[yi]   = ( ( r_sum * mul_sum ) >> shg_sum ) * pa;\n\t\t\t\tpixels[yi+1] = ( ( g_sum * mul_sum ) >> shg_sum ) * pa;\n\t\t\t\tpixels[yi+2] = ( ( b_sum * mul_sum ) >> shg_sum ) * pa;\n\t\t\t} else {\n\t\t\t\tpixels[yi] = pixels[yi+1] = pixels[yi+2] = 0;\n\t\t\t}\n\n\t\t\tr_sum -= r_out_sum;\n\t\t\tg_sum -= g_out_sum;\n\t\t\tb_sum -= b_out_sum;\n\t\t\ta_sum -= a_out_sum;\n\n\t\t\tr_out_sum -= stackIn.r;\n\t\t\tg_out_sum -= stackIn.g;\n\t\t\tb_out_sum -= stackIn.b;\n\t\t\ta_out_sum -= stackIn.a;\n\n\t\t\tp =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;\n\n\t\t\tr_in_sum += ( stackIn.r = pixels[p] );\n\t\t\tg_in_sum += ( stackIn.g = pixels[p+1] );\n\t\t\tb_in_sum += ( stackIn.b = pixels[p+2] );\n\t\t\ta_in_sum += ( stackIn.a = pixels[p+3] );\n\n\t\t\tr_sum += r_in_sum;\n\t\t\tg_sum += g_in_sum;\n\t\t\tb_sum += b_in_sum;\n\t\t\ta_sum += a_in_sum;\n\n\t\t\tstackIn = stackIn.next;\n\n\t\t\tr_out_sum += ( pr = stackOut.r );\n\t\t\tg_out_sum += ( pg = stackOut.g );\n\t\t\tb_out_sum += ( pb = stackOut.b );\n\t\t\ta_out_sum += ( pa = stackOut.a );\n\n\t\t\tr_in_sum -= pr;\n\t\t\tg_in_sum -= pg;\n\t\t\tb_in_sum -= pb;\n\t\t\ta_in_sum -= pa;\n\n\t\t\tstackOut = stackOut.next;\n\n\t\t\tyi += 4;\n\t\t}\n\t\tyw += width;\n\t}\n\n\n\tfor ( x = 0; x < width; x++ ) {\n\t\tg_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;\n\n\t\tyi = x << 2;\n\t\tr_out_sum = radiusPlus1 * ( pr = pixels[yi] );\n\t\tg_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );\n\t\tb_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );\n\t\ta_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );\n\n\t\tr_sum += sumFactor * pr;\n\t\tg_sum += sumFactor * pg;\n\t\tb_sum += sumFactor * pb;\n\t\ta_sum += sumFactor * pa;\n\n\t\tstack = stackStart;\n\n\t\tfor ( i = 0; i < radiusPlus1; i++) {\n\t\t\tstack.r = pr;\n\t\t\tstack.g = pg;\n\t\t\tstack.b = pb;\n\t\t\tstack.a = pa;\n\t\t\tstack = stack.next;\n\t\t}\n\n\t\typ = width;\n\n\t\tfor ( i = 1; i <= radius; i++ ) {\n\t\t\tyi = ( yp + x ) << 2;\n\n\t\t\tr_sum += ( stack.r = ( pr = pixels[yi] ) ) * (rbs = radiusPlus1 - i);\n\t\t\tg_sum += ( stack.g = ( pg = pixels[yi+1] ) ) * rbs;\n\t\t\tb_sum += ( stack.b = ( pb = pixels[yi+2] ) ) * rbs;\n\t\t\ta_sum += ( stack.a = ( pa = pixels[yi+3] ) ) * rbs;\n\n\t\t\tr_in_sum += pr;\n\t\t\tg_in_sum += pg;\n\t\t\tb_in_sum += pb;\n\t\t\ta_in_sum += pa;\n\n\t\t\tstack = stack.next;\n\n\t\t\tif ( i < heightMinus1 ) {\n\t\t\t\typ += width;\n\t\t\t}\n\t\t}\n\n\t\tyi = x;\n\t\tstackIn = stackStart;\n\t\tstackOut = stackEnd;\n\n\t\tfor ( y = 0; y < height; y++ ) {\n\t\t\tp = yi << 2;\n\t\t\tpixels[p+3] = pa = ( a_sum * mul_sum ) >> shg_sum;\n\t\t\t\n\t\t\tif ( pa > 0 ) {\n\t\t\t\tpa = 255 / pa;\n\t\t\t\tpixels[p]   = ( ( r_sum * mul_sum ) >> shg_sum) * pa;\n\t\t\t\tpixels[p+1] = ( ( g_sum * mul_sum ) >> shg_sum) * pa;\n\t\t\t\tpixels[p+2] = ( ( b_sum * mul_sum ) >> shg_sum) * pa;\n\t\t\t} else {\n\t\t\t\tpixels[p] = pixels[p+1] = pixels[p+2] = 0;\n\t\t\t}\n\n\t\t\tr_sum -= r_out_sum;\n\t\t\tg_sum -= g_out_sum;\n\t\t\tb_sum -= b_out_sum;\n\t\t\ta_sum -= a_out_sum;\n\n\t\t\tr_out_sum -= stackIn.r;\n\t\t\tg_out_sum -= stackIn.g;\n\t\t\tb_out_sum -= stackIn.b;\n\t\t\ta_out_sum -= stackIn.a;\n\n\t\t\tp = ( x + ( ( ( p = y + radiusPlus1 ) < heightMinus1 ? p : heightMinus1 ) * width ) ) << 2;\n\n\t\t\tr_sum += ( r_in_sum += ( stackIn.r = pixels[p] ) );\n\t\t\tg_sum += ( g_in_sum += ( stackIn.g = pixels[p+1] ) );\n\t\t\tb_sum += ( b_in_sum += ( stackIn.b = pixels[p+2] ) );\n\t\t\ta_sum += ( a_in_sum += ( stackIn.a = pixels[p+3] ) );\n\n\t\t\tstackIn = stackIn.next;\n\n\t\t\tr_out_sum += ( pr = stackOut.r );\n\t\t\tg_out_sum += ( pg = stackOut.g );\n\t\t\tb_out_sum += ( pb = stackOut.b );\n\t\t\ta_out_sum += ( pa = stackOut.a );\n\n\t\t\tr_in_sum -= pr;\n\t\t\tg_in_sum -= pg;\n\t\t\tb_in_sum -= pb;\n\t\t\ta_in_sum -= pa;\n\n\t\t\tstackOut = stackOut.next;\n\n\t\t\tyi += width;\n\t\t}\n\t}\n\n\treturn imageData;\n}\n\nfunction greyscale (imageData) {\n\tvar len = imageData.data.length;\n\tvar brightness;\n\n\tfor ( var i = 0; i < len; i += 4 ) {\n\t\tbrightness = 0.34 * imageData.data[i] + 0.5 * imageData.data[i + 1] + 0.16 * imageData.data[i + 2];\n\n\t\timageData.data[i] = brightness;\n\t\timageData.data[i + 1] = brightness;\n\t\timageData.data[i + 2] = brightness;\n\t}\n\t\t\n\treturn imageData;\n}\n\n// most parts taken from http://jsdo.it/akm2/xoYx\n// (starting line 293++)\nfunction getEdgePoints ( imageData, threshold ) {\n\t// only check every 2nd pixel in imageData to save some time.\n\tvar multiplier = 2;\n\tvar width = imageData.width;\n\tvar height = imageData.height;\n\tvar data = imageData.data;\n\tvar points = [ ];\n\tvar x, y, row, col, sx, sy, step, sum, total;\n\n\tfor ( y = 0; y < height; y += multiplier ) {\n\t\tfor ( x = 0; x < width; x += multiplier ) {\n\t\t\tsum = total = 0;\n\n\t\t\tfor ( row = -1; row <= 1; row++ ) {\n\t\t\t\tsy = y + row;\n\t\t\t\tstep = sy * width;\n\n\t\t\t\tif ( sy >= 0 && sy < height ) {\n\t\t\t\t\tfor ( col = -1; col <= 1; col++ ) {\n\t\t\t\t\t\tsx = x + col;\n\n\t\t\t\t\t\tif ( sx >= 0 && sx < width ) {\n\t\t\t\t\t\t\tsum += data[( sx + step ) << 2];\n\t\t\t\t\t\t\ttotal++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( total ) {\n\t\t\t\tsum /= total;\n\t\t\t}\n\n\t\t\tif ( sum > threshold ) {\n\t\t\t\tpoints.push( { x: x, y: y } );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn points;\n}\n\nfunction clamp ( value, min, max ) {\n\treturn value < min ? min : value > max ? max : value;\n}\n\nfunction addVertex ( x, y, hash ) {\n\tvar resultKey = x + '|' + y;\n\n\tif ( ! hash[resultKey] ) {\n\t\thash[resultKey] = { x: x, y: y };\n\t}\n\n\tresultKey = null;\n}\n\nfunction getVerticesFromPoints ( points, maxPointCount, accuracy, width, height ) {\n\t// using hash for all points to make sure we have a set of unique vertices.\n\tvar resultHash = { };\n\n\t// use 25% of max point count to create a background grid.\n\t// this avoids having too many \"big\" triangles in areas of the image with low contrast \n\t// next to very small ones in areas with high contrast\n\t// for every other row, start the x value at > 0, so the grid doesn't look too regular\n\tvar gridPointCount = Math.max( ~~( maxPointCount * ( 1 - accuracy ) ), 5 );\n\n\t// http://stackoverflow.com/a/4107092/229189\n\tvar gridColumns = Math.round( Math.sqrt( gridPointCount ) );\n\tvar gridRows = Math.round( Math.ceil( gridPointCount / gridColumns ) );\n\t\n\tvar xIncrement = ~~( width / gridColumns );\n\tvar yIncrement = ~~( height / gridRows );\n\n\tvar rowIndex = 0;\n\tvar startX = 0;\n\n\tvar x = 0;\n\tvar y = 0;\n\n\tfor ( y = 0; y < height; y+= yIncrement ) {\n\t\trowIndex++;\n\n\t\tstartX = rowIndex % 2 === 0 ? ~~( xIncrement / 2 ) : 0; \n\n\t\tfor ( x = startX; x < width; x += xIncrement ) {\n\t\t\tif ( x < width && y < height ) {\n\t\t\t\t// \"distorting\" the grid a little bit so that the\n\t\t\t\t// background vertices don't appear to be on a straight line (which looks boring)\n\t\t\t\taddVertex(\n\t\t\t\t\t~~( x + ( Math.cos( y ) * ( yIncrement ) ) ),\n\t\t\t\t\t~~( y + ( Math.sin( x ) * ( xIncrement ) ) ),\n\t\t\t\t\tresultHash\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// add points in the corners\n\taddVertex( 0, 0, resultHash );\n\taddVertex( width - 1, 0, resultHash );\n\taddVertex( width - 1, height - 1, resultHash );\n\taddVertex( 0, height - 1, resultHash );\n\n\t// add points from all edge points\n\tvar remainingPointCount = maxPointCount - Object.keys( resultHash ).length;\n\tvar edgePointCount = points.length;\n\tvar increment = ~~( edgePointCount / remainingPointCount );\n\n\tif ( maxPointCount > 0 && increment > 0 ) {\n\t\tvar i = 0;\n\n\t\tfor ( i = 0; i < edgePointCount; i += increment ) {\n\t\t\taddVertex( points[i].x, points[i].y, resultHash );\n\t\t}\n\t}\n\n\tpoints = null;\n\n\treturn Object.keys( resultHash ).map( function (key) {\n\t\treturn resultHash[key];\n\t} );\n}\n\nfunction getBoundingBox (points) {\n\tvar xMin = Infinity;\n\tvar xMax = -Infinity;\n\tvar yMin = Infinity;\n\tvar yMax = -Infinity;\n\n\tpoints.forEach( function (p) {\n\t\tif ( p.x < xMin ) {\n\t\t\txMin = p.x;\n\t\t}\n\n\t\tif ( p.y < yMin ) {\n\t\t\tyMin = p.y;\n\t\t}\n\n\t\tif ( p.x > xMax ) {\n\t\t\txMax = p.x;\n\t\t}\n\n\t\tif ( p.y > yMax ) {\n\t\t\tyMax = p.y;\n\t\t}\n\t} );\n\n\treturn {\n\t\tx: xMin,\n\t\ty: yMin,\n\t\twidth: xMax - xMin,\n\t\theight: yMax - yMin\n\t};\n}\n\nfunction addBoundingBoxesToPolygons ( polygons, colorData, params ) {\n\tpolygons.forEach( function (polygon) {\n\t\tpolygon.boundingBox = getBoundingBox( [ polygon.a, polygon.b, polygon.c ] );\n\t} );\n\n\treturn polygons.filter( function (polygon) {\n\t\treturn polygon.boundingBox.width > 0 && polygon.boundingBox.height > 0;\n\t} );\n}\n\n/**\n * Get color object by position\n * @param  {Object} pos         {x,y} object\n * @param  {Object} colorData   Image color data object\n * @param  {Object} [transparentColor] (optional) RGBA color object. Used to set specific color to transparent pixels\n * @return {Object}             RGBA color object\n */\nfunction getColorByPos ( pos, colorData, transparentColor ) {\n\tvar x = clamp( pos.x, 1, colorData.width - 2 );\n\tvar y = clamp( pos.y, 1, colorData.height - 2 );\n\tvar index = ( ( x | 0 ) + ( y | 0 ) * colorData.width ) << 2;\n\n\tif ( index >= colorData.data.length ) {\n\t\tindex = colorData.data.length - 5;\n\t}\n\n\tvar alpha = colorData.data[index + 3] / 255;\n\n\t// Return RGBA color object\n\treturn ( transparentColor && alpha === 0 ) ? transparentColor : {\n\t\tr: colorData.data[index],\n\t\tg: colorData.data[index + 1],\n\t\tb: colorData.data[index + 2],\n\t\ta: alpha\n\t};\n}\n\n/**\n * Get polygon's center point\n * @param  {Object} polygon Polygon object\n * @return {Object}         Point coordinates {x,y}\n */\nfunction polygonCenter (polygon) {\n\treturn {\n\t\tx: ( polygon.a.x + polygon.b.x + polygon.c.x ) * 0.33333,\n\t\ty: ( polygon.a.y + polygon.b.y + polygon.c.y ) * 0.33333\n\t};\n}\n\n/**\n * Is color transparent ?\n * @param  {Object} color Color object\n * @return {Boolean}      Is transparent?\n */\nfunction isTransparent (color) {\n\treturn color.a === 0;\n}\n\n// import objectAssign from 'object-assign'\n\n// https://gist.githubusercontent.com/oriadam/396a4beaaad465ca921618f2f2444d49/raw/76b0de6caffaac59f8af2b4dfa0e0b6397cf447d/colorValues.js\n// return array of [r,g,b,a] from any valid color. if failed returns undefined\nfunction strToColorArr ( color ) {\n\tif ( typeof color === 'string' ) {\n\t\tvar result = [ 0, 0, 0, 0 ];\n\t\t\n\t\tif ( color[0] === '#' )\t{\n\t\t\t// convert #RGB and #RGBA to #RRGGBB and #RRGGBBAA\n\t\t\tif ( color.length < 7 ) {\n\t\t\t\tcolor = \"#\" + (color[1]) + (color[1]) + (color[2]) + (color[2]) + (color[3]) + (color[3]) + (color.length > 4 ? color[4] + color[4] : '');\n\t\t\t}\n\n\t\t\tresult = [\n\t\t\t\tparseInt(color.substr( 1, 2 ), 16),\n\t\t\t\tparseInt(color.substr( 3, 2 ), 16),\n\t\t\t\tparseInt(color.substr( 5, 2 ), 16),\n\t\t\t\tcolor.length > 7 ? parseInt( color.substr( 7, 2 ), 16 ) / 255 : 1\n\t\t\t];\n\t\t}\n\n\t\tif ( color.indexOf('rgb') === 0 ) {\n\t\t\t// convert 'rgb(R,G,B)' to 'rgb(R,G,B)A' which looks awful but will pass the regxep below\n\t\t\tif ( ! color.includes( 'rgba' ) ) {\n\t\t\t\tcolor += ',1';\n\t\t\t}\n\n\t\t\tresult = color\n\t\t\t\t.match( /[\\.\\d]+/g )\n\t\t\t\t.map( function (a) { return +a; } );\n\t\t}\n\t\t\n\t\treturn result;\n\t} else {\n\t\treturn;\n\t}\n\n}\n\nfunction strToColor ( str ) {\n\tvar color = strToColorArr( str );\n\n\tif ( color ) {\n\t\tvar r = color[0];\n\t\tvar g = color[1];\n\t\tvar b = color[2];\n\t\tvar a = color[3];\n\t\treturn { r: r, g: g, b: b, a: a };\n\t} else {\n\t\treturn;\n\t}\n}\n\nfunction addColorToPolygons ( polygons, colorData, params ) {\n\tvar fill = params.fill;\n\tvar stroke = params.stroke;\n\tvar strokeWidth = params.strokeWidth;\n\tvar lineJoin = params.lineJoin;\n\tvar transparentColor = params.transparentColor;\n\tvar fillColor = fill ? strToColor( fill ) : false;\n\tvar strokeColor = stroke ? strToColor( stroke ) : false;\n\n\t/**\n\t * Color override logic\n\t * @param  {Object} color    Color object\n\t * @param  {String} override Override color (fillColor/strokeColor)\n\t * @return {String}          CSS formatted color (rgba,..)\n\t */\n\tvar getColor = function ( color, override ) {\n\t\tvar t = ( isTransparent( color ) && transparentColor );\t// Color is transparent, and transparentColor override is defined\n\t\tvar c = t ? transparentColor : color;\n\t\treturn ( override && !t ) ? override : c;\t\t// Priority: transparentColor -> override -> supplied color\n\t};\n\n\tpolygons.forEach( function (polygon) {\n\t\tvar color = getColorByPos( polygonCenter( polygon ), colorData );\n\n\t\tif ( fill ) {\n\t\t\tpolygon.fill = getColor( color, fillColor );\n\t\t}\n\n\t\tif ( stroke ) {\n\t\t\tpolygon.strokeColor = getColor(color, strokeColor);\n\t\t\tpolygon.strokeWidth = strokeWidth;\n\t\t\tpolygon.lineJoin = lineJoin;\n\t\t}\n\t} );\n\n\treturn polygons;\n}\n\n//  http://stackoverflow.com/a/9733420/229189\nfunction luminance (color) {\n\tvar a = [ color.r, color.g, color.b ].map( function (v) {\n\t\tv /= 255;\n\t\treturn ( v <= 0.03928 ) ? v / 12.92 : Math.pow( ( ( v + 0.055 ) / 1.055 ), 2.4 );\n\t} );\n\n\treturn a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;\n}\n\nfunction distance ( a, b ) {\n\tvar dx = b.x - a.x;\n\tvar dy = b.y - a.y;\n\n\treturn Math.sqrt( ( dx * dx ) + ( dy * dy ) );\n}\n\nfunction addGradientsToPolygons ( polygons, colorData, params ) {\n\tpolygons.forEach( function (polygon) {\n\t\tvar data = { };\n\n\t\t'abc'.split( '' ).forEach( function (key) {\n\t\t\tvar color = getColorByPos( polygon[key], colorData, params.transparentColor );\n\t\t\t\n\t\t\tdata[key] = {\n\t\t\t\tkey: key,\n\t\t\t\tcolor: color,\n\t\t\t\tx: polygon[key].x,\n\t\t\t\ty: polygon[key].y\n\t\t\t};\n\n\t\t\tdata[key].luminance = luminance( data[key].color );\n\n\t\t\tvar otherKeys = 'abc'.replace( key, '' ).split( '' );\n\n\t\t\tdata[key].median = {\n\t\t\t\tx: ( polygon[otherKeys[0]].x + polygon[otherKeys[1]].x ) / 2,\n\t\t\t\ty: ( polygon[otherKeys[0]].y + polygon[otherKeys[1]].y ) / 2\n\t\t\t};\n\n\t\t\tdata[key].medianColor = getColorByPos( data[key].median, colorData, params.transparentColor );\n\t\t\tdata[key].medianLuminance = luminance( data[key].medianColor );\n\t\t} );\n\n\t\t// sort by axis of most difference in luminance\n\t\tvar pointsByDeltaInLuminance = [ data.a, data.b, data.c ].sort( function ( u, v ) {\n\t\t\treturn Math.abs( u.luminance - u.medianLuminance ) - Math.abs( v.luminance - v.medianLuminance );\n\t\t} );\n\n\t\tvar pointWithMostDeltaInLuminance = pointsByDeltaInLuminance[0];\n\t\tvar startPoint = pointsByDeltaInLuminance[0];\n\t\tvar endPoint = pointWithMostDeltaInLuminance.median;\n\n\t\tvar gradienStopPositions = [ startPoint ];\n\n\t\tvar startToEndDistance = distance( startPoint, endPoint );\n\n\t\tfor ( var i = 1, len = params.gradientStops - 2; i < len; i++ ) {\n\t\t\tvar pointDistance = i * ( startToEndDistance / params.gradientStops );\n\t\t\tvar pointPercent = pointDistance / startToEndDistance;\n\t\t\t\n\t\t\tvar point = {\n\t\t\t\tx: startPoint.x + pointPercent * ( endPoint.x - startPoint.x ), \n\t\t\t\ty: startPoint.y + pointPercent * ( endPoint.y - startPoint.y )\n\t\t\t};\n\n\t\t\tgradienStopPositions.push( point );\n\t\t}\n\n\t\tgradienStopPositions.push( endPoint );\n\n\t\tpolygon.gradient = {\n\t\t\tx1: pointWithMostDeltaInLuminance.x,\n\t\t\ty1: pointWithMostDeltaInLuminance.y,\n\t\t\tx2: pointWithMostDeltaInLuminance.median.x,\n\t\t\ty2: pointWithMostDeltaInLuminance.median.y,\n\t\t\tcolors: gradienStopPositions.map( function (pos) {\n\t\t\t\treturn getColorByPos( pos, colorData, params.transparentColor );\n\t\t\t} )\n\t\t};\n\n\t\tif ( params.stroke ) {\n\t\t\tpolygon.strokeWidth = params.strokeWidth;\n\t\t\tpolygon.lineJoin = params.lineJoin;\n\t\t}\n\n\t\tdata = null;\n\t} );\n\n\treturn polygons;\n}\n\n/**\n * Filter polygons with transparent color\n * @param  {Array} polygons    Polygons array\n * @param  {Object} colorData  Color data\n * @return {Array}             Filtered polygons array\n */\nfunction filterTransparentPolygons ( polygons, colorData ) {\n\treturn polygons.filter( function (polygon) {\n\t\tvar color = getColorByPos( polygonCenter( polygon ), colorData );\n\t\treturn ! isTransparent( color );\n\t});\n}\n\nfunction imageDataToPolygons ( imageData, params ) {\n\tif ( isImageData( imageData ) ) {\n\t\tvar imageSize = { width: imageData.width, height: imageData.height };\n\t\tvar tmpImageData = copyImageData( imageData );\n\t\tvar colorImageData = copyImageData( imageData );\n\t\tvar blurredImageData = stackblur( tmpImageData, 0, 0, imageSize.width, imageSize.height, params.blur );\n\t\tvar greyscaleImageData = greyscale( blurredImageData );\n\t\tvar edgesImageData = sobel( greyscaleImageData ).toImageData();\n\t\tvar edgePoints = getEdgePoints( edgesImageData, params.threshold );\n\t\tvar edgeVertices = getVerticesFromPoints( edgePoints, params.vertexCount, params.accuracy, imageSize.width, imageSize.height );\n\t\tvar polygons = delaunay_2( edgeVertices );\n\t\t\n\t\tpolygons = addBoundingBoxesToPolygons( polygons );\n\t\t\n\t\tif ( ! params.transparentColor ) {\n\t\t\tpolygons = filterTransparentPolygons( polygons, colorImageData );\n\t\t}\n\t\t\n\t\tif ( params.fill === true && params.gradients === true ) {\n\t\t\tpolygons = addGradientsToPolygons( polygons, colorImageData, params );\n\t\t} else {\n\t\t\tpolygons = addColorToPolygons( polygons, colorImageData, params );\n\t\t}\n\n\t\treturn polygons;\n\t} else {\n\t\tthrow new Error( \"Can't work with the imageData provided. It seems to be corrupt.\" );\n\t\treturn;\n\t}\n}\n\nonmessage = function (msg) {\n\tif ( msg.data.imageData && msg.data.params ) {\n\t\ttry {\n\t\t\tvar imageData = msg.data.imageData;\n\n\t\t\t// phantomjs seems to have some memory loss so we need to make sure\n\t\t\tif ( typeof imageData.width === 'undefined' && typeof msg.data.imageDataWidth === 'number' ) {\n\t\t\t\timageData.width = msg.data.imageDataWidth;\n\t\t\t}\n\n\t\t\tif ( typeof imageData.height === 'undefined' && typeof msg.data.imageDataHeight === 'number' ) {\n\t\t\t\timageData.height = msg.data.imageDataHeight;\n\t\t\t}\n\t\t\t\n\t\t\tvar polygons = imageDataToPolygons( msg.data.imageData, msg.data.params );\n\t\t\t\t\t\t\n\t\t\tself.postMessage( {\n\t\t\t\tpolygonJSONStr: JSON.stringify( polygons )\n\t\t\t} );\n\t\t} catch ( err ) {\n\t\t\tself.postMessage( { err: err.message || err } );\n\t\t}\n\n\t} else {\n\t\tif ( msg.data.imageData ) {\n\t\t\tself.postMessage( { err: 'Parameters are missing.' } );\n\t\t} else {\n\t\t\tself.postMessage( { err: 'ImageData is missing.' } );\n\t\t}\n\t}\n\t\n\tself.close();\n};\n"],{type:"text/javascript"}))),i={getParams:function(){return t},getInput:u,getOutput:c},s={fromImage:function(t){return d(y,t)},fromImageSync:function(t){return d(y,t,!0)},fromImageData:function(t){return d((function(t){return t}),t)},fromImageDataSync:function(t){return d((function(t){return t}),t,!0)}},l={toData:function(t){return p((function(t){return t}),t)},toDataSync:function(t){return p((function(t){return t}),t,!0)},toDataURL:function(t){return p(w,t)},toDataURLSync:function(t){return p(w,t,!0)},toImageData:function(t){return p(v,t)},toImageDataSync:function(t){return p(v,t,!0)},toSVG:function(t){return p(D,t)},toSVGSync:function(t){return p(D,t,!0)}};function u(){var t=f({},i);return n||f(t,s),t}function c(){var t=f({},i);return e||f(t,l),t}function d(t,e,r){return a=!!r,n=function(){return a?t(e):new Promise((function(n,a){try{n(t(e))}catch(t){a(t)}}))},g()?h():c()}function p(t,n,a){return r=!!a,e=function(e,a){return r?t(e,a,n):new Promise((function(r,o){try{r(t(e,a,n))}catch(t){o(t)}}))},g()?h():u()}function g(){return n&&e}function h(){if(a&&r){var i=n(t),s=G(i,t);return e(s,i)}return new Promise((function(i,s){var l,u;new Promise((function(t,e){if(a)try{t(n(u))}catch(t){e(t)}else n(u).then(t,e)})).then((function(n){return function(t,n){return new Promise((function(e,a){o.addEventListener("message",(function(t){if(t.data&&t.data.polygonJSONStr){var n=JSON.parse(t.data.polygonJSONStr);e(n)}else t.data&&t.data.err?a(t.data.err):a(t)})),o.postMessage({params:n,imageData:t,imageDataWidth:t.width,imageDataHeight:t.height})}))}(l=n,t)}),s).then((function(t){return function(t,n){return new Promise((function(a,o){if(r)try{a(e(t,n))}catch(t){o(t)}else e(t,n).then(a,o)}))}(t,l)}),s).then((function(t){i(t)}),s)}))}return u()}},t.exports=e()}).call(this,e(1))},function(t,n){var e;e=function(){return this}();try{e=e||new Function("return this")()}catch(t){"object"==typeof window&&(e=window)}t.exports=e},function(t,n,e){"use strict";e.r(n),e.d(n,"getTriangulationData",(function(){return i})),e.d(n,"invokePolygons",(function(){return l}));var a=e(0),r=e.n(a);const o=t=>{const n=document.createElement("div");return n.innerHTML=t.trim(),n.firstElementChild};var i=({image:t,params:n})=>r()(n).fromImage(t).toSVG().then(o).then(t=>({height:t.getAttribute("height"),width:t.getAttribute("width"),polygons:t.querySelectorAll("polygon")})).then(t=>({...t,polygons:Array.from(t.polygons).map(n=>({points:n.getAttribute("points").split(" ").map(t=>t.split(",")).map(([n,e])=>`${n/t.width*100}% ${e/t.height*100}%`).join(","),color:n.getAttribute("fill")}))}));const s={fade:{pre:({duration:t,color:n,points:e})=>`\n      clip-path: polygon(${e});\n      background: ${n};\n      left: 0;\n      right: 0;\n      top: 0;\n      bottom: 0;\n      position: absolute;\n      opacity: 0;\n      transition: opacity ${t}s cubic-bezier(.7,.3,0,1);`,post:()=>"opacity: 1;"},fly:{pre:({duration:t,points:n})=>`\n        clip-path: polygon(${n.split(",").map(t=>t.split(" ")).map(([t,n])=>`${1*t.replace("%","")+30*Math.random()}% ${n}`).join(",")});\n        background: transparent;\n        left: 0;\n        right: 0;\n        top: 0;\n        bottom: 0;\n        position: absolute;\n        transition: -webkit-clip-path ${t}s cubic-bezier(.7, .3, 0, 1), clip-path ${t}s cubic-bezier(.7, .3, 0, 1), background-color ${t}s cubic-bezier(.7, .3, 0, 1);`,post:({points:t,color:n})=>`\n      clip-path: polygon(${t});\n      background-color: ${n};`}};var l=({data:t,animation:n,container:e})=>Promise.all(t.polygons.map((t,a)=>{const{polygon:r,promise:o}=(({points:t,color:n,idx:e,type:a="fade",duration:r=.5})=>{const o=document.createElement("div");o.classList.add("polygon"),o.style=s[a].pre({duration:r,color:n,points:t});const i=new Promise(i=>setTimeout(()=>{o.style=o.getAttribute("style")+s[a].post({duration:r,color:n,points:t}),i(o)},100*e/20));return{polygon:o,promise:i}})({...t,idx:a,duration:n.duration,type:n.type});return e.append(r),o}))}])}));

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var polygonize_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! polygonize-image */ "./node_modules/polygonize-image/dist/polygons.js");
/* harmony import */ var polygonize_image__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(polygonize_image__WEBPACK_IMPORTED_MODULE_0__);


const animateImage = async ({
  imageSelector,
  containerSelector,
  animation,
}) => {
  const image = document.querySelector(imageSelector);
  const container = document.querySelector(containerSelector);

  const params = {
    blur: 0,
    vertexCount: 300,
    accuracy: 1,
  };

  const preParams = {
    blur: 1000,
    vertexCount: 50,
    accuracy: 0.2,
  };

  const data1Promise = Object(polygonize_image__WEBPACK_IMPORTED_MODULE_0__["getTriangulationData"])({
    image,
    params: preParams,
  });

  const data2Promise = Object(polygonize_image__WEBPACK_IMPORTED_MODULE_0__["getTriangulationData"])({
    image,
    params,
  });

  await Object(polygonize_image__WEBPACK_IMPORTED_MODULE_0__["invokePolygons"])({
    data: await data1Promise,
    animation: {
      duration: 0.5,
      type: animation,
    },
    container,
  });

  await Object(polygonize_image__WEBPACK_IMPORTED_MODULE_0__["invokePolygons"])({
    data: await data2Promise,
    animation: {
      duration: 0.5,
      type: animation,
    },
    container,
  });

  image.classList.add("show");
};

const init = () => {
  animateImage({
    imageSelector: ".img",
    containerSelector: ".container",
    animation: "fly",
  });
  animateImage({
    imageSelector: ".img-2",
    containerSelector: ".container-2",
    animation: "fade",
  });
};

init();


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BvbHlnb25pemUtaW1hZ2UvZGlzdC9wb2x5Z29ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7O0FDbEZBLGVBQWUsR0FBRyxJQUFpRCxvQkFBb0IsS0FBSyxhQUFpSSxDQUFDLG9CQUFvQixtQkFBbUIsU0FBUyxjQUFjLDRCQUE0QixZQUFZLHFCQUFxQiwyREFBMkQsdUNBQXVDLHFDQUFxQyxvQkFBb0IsRUFBRSxpQkFBaUIsNEZBQTRGLGVBQWUsd0NBQXdDLFNBQVMsRUFBRSxtQkFBbUIsOEJBQThCLHFEQUFxRCwwQkFBMEIsNkNBQTZDLHNCQUFzQiw2REFBNkQsWUFBWSxlQUFlLFNBQVMsaUJBQWlCLGlDQUFpQyxpQkFBaUIs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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsImZpbGUiOiJhcHAuYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXguanNcIik7XG4iLCIhZnVuY3Rpb24odCxuKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1uKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLG4pO2Vsc2V7dmFyIGU9bigpO2Zvcih2YXIgYSBpbiBlKShcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzOnQpW2FdPWVbYV19fSh3aW5kb3csKGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBuPXt9O2Z1bmN0aW9uIGUoYSl7aWYoblthXSlyZXR1cm4gblthXS5leHBvcnRzO3ZhciByPW5bYV09e2k6YSxsOiExLGV4cG9ydHM6e319O3JldHVybiB0W2FdLmNhbGwoci5leHBvcnRzLHIsci5leHBvcnRzLGUpLHIubD0hMCxyLmV4cG9ydHN9cmV0dXJuIGUubT10LGUuYz1uLGUuZD1mdW5jdGlvbih0LG4sYSl7ZS5vKHQsbil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4se2VudW1lcmFibGU6ITAsZ2V0OmF9KX0sZS5yPWZ1bmN0aW9uKHQpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LGUudD1mdW5jdGlvbih0LG4pe2lmKDEmbiYmKHQ9ZSh0KSksOCZuKXJldHVybiB0O2lmKDQmbiYmXCJvYmplY3RcIj09dHlwZW9mIHQmJnQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgYT1PYmplY3QuY3JlYXRlKG51bGwpO2lmKGUucihhKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSksMiZuJiZcInN0cmluZ1wiIT10eXBlb2YgdClmb3IodmFyIHIgaW4gdCllLmQoYSxyLGZ1bmN0aW9uKG4pe3JldHVybiB0W25dfS5iaW5kKG51bGwscikpO3JldHVybiBhfSxlLm49ZnVuY3Rpb24odCl7dmFyIG49dCYmdC5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHQuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gdH07cmV0dXJuIGUuZChuLFwiYVwiLG4pLG59LGUubz1mdW5jdGlvbih0LG4pe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKX0sZS5wPVwiXCIsZShlLnM9Mil9KFtmdW5jdGlvbih0LG4sZSl7KGZ1bmN0aW9uKG4pe3ZhciBlO2U9ZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KHQsbixlKXtyZXR1cm4gdDxuP246dD5lP2U6dH12YXIgZT1mdW5jdGlvbih0LG4pe3ZvaWQgMD09PXQmJih0PTMwMCksdm9pZCAwPT09biYmKG49MTUwKSxcInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93Pyh0aGlzLmNhbnZhc0VsPXt3aWR0aDp0LGhlaWdodDpufSx0aGlzLmN0eD1udWxsKToodGhpcy5jYW52YXNFbD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLHRoaXMuY2FudmFzRWwud2lkdGg9dCx0aGlzLmNhbnZhc0VsLmhlaWdodD1uLHRoaXMuY3R4PXRoaXMuY2FudmFzRWwuZ2V0Q29udGV4dChcIjJkXCIpKX0sYT17d2lkdGg6e2NvbmZpZ3VyYWJsZTohMH0saGVpZ2h0Ontjb25maWd1cmFibGU6ITB9fTtmdW5jdGlvbiByKHQsbixhLHIpe3ZhciBvPSEoIW58fCFuLmJhY2tncm91bmRDb2xvcikmJm4uYmFja2dyb3VuZENvbG9yLGk9bmV3IGUodC53aWR0aCphLHQuaGVpZ2h0KmEscikscz1pLmdldENvbnRleHQoXCIyZFwiKTtyZXR1cm4gbyYmKHMuZmlsbFN0eWxlPW8scy5maWxsUmVjdCgwLDAsdC53aWR0aCphLHQuaGVpZ2h0KmEpLHMuZmlsbFN0eWxlPVwidHJhbnNwYXJlbnRcIikse2NhbnZhczppLGN0eDpzfX1lLnByb3RvdHlwZS5nZXRDb250ZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3R4fSxlLnByb3RvdHlwZS50b0RhdGFVUkw9ZnVuY3Rpb24odCxuLGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpcmV0dXJuIHRoaXMuY2FudmFzRWwudG9EYXRhVVJMKHQsbik7ZSh0aGlzLmNhbnZhc0VsLnRvRGF0YVVSTCh0LG4pKX0sYS53aWR0aC5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jYW52YXNFbC53aWR0aH0sYS53aWR0aC5zZXQ9ZnVuY3Rpb24odCl7dGhpcy5jYW52YXNFbC53aWR0aD10fSxhLmhlaWdodC5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jYW52YXNFbC5oZWlnaHR9LGEuaGVpZ2h0LnNldD1mdW5jdGlvbih0KXt0aGlzLmNhbnZhc0VsLmhlaWdodD10fSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSxhKSxcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiYoZS5JbWFnZT1JbWFnZSk7dmFyIG89LjcsaT00LHM9ITAsbD0hMCx1PS41LGM9XCJtaXRlclwiLGQ9NzAwLHA9NTAsZz0hMSxoPVtcIm1pdGVyXCIsXCJyb3VuZFwiLFwiYmV2ZWxcIl07ZnVuY3Rpb24gbShuKXtyZXR1cm5cIm9iamVjdFwiIT10eXBlb2Yobj1mdW5jdGlvbih0KXt2YXIgbj0hMTtpZih2b2lkIDAhPT10KXRyeXtuPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodCkpfWNhdGNoKHQpe31yZXR1cm4gbn0obikpJiYobj17fSksXCJudW1iZXJcIiE9dHlwZW9mIG4uYWNjdXJhY3l8fGlzTmFOKG4uYWNjdXJhY3kpP24uYWNjdXJhY3k9bzpuLmFjY3VyYWN5PXQobi5hY2N1cmFjeSwwLDEpLChcIm51bWJlclwiIT10eXBlb2Ygbi5ibHVyfHxpc05hTihuLmJsdXIpKSYmKG4uYmx1cj1pKSxuLmJsdXI8PTAmJihuLmJsdXI9MSksXCJzdHJpbmdcIiE9dHlwZW9mIG4uZmlsbCYmXCJib29sZWFuXCIhPXR5cGVvZiBuLmZpbGwmJihuLmZpbGw9cyksXCJzdHJpbmdcIiE9dHlwZW9mIG4uc3Ryb2tlJiZcImJvb2xlYW5cIiE9dHlwZW9mIG4uc3Ryb2tlJiYobi5zdHJva2U9bCksKFwibnVtYmVyXCIhPXR5cGVvZiBuLnN0cm9rZVdpZHRofHxpc05hTihuLnN0cm9rZVdpZHRoKSkmJihuLnN0cm9rZVdpZHRoPXUpLFwibnVtYmVyXCIhPXR5cGVvZiBuLnRocmVzaG9sZHx8aXNOYU4obi50aHJlc2hvbGQpP24udGhyZXNob2xkPXA6bi50aHJlc2hvbGQ9dChuLnRocmVzaG9sZCwxLDEwMCksXCJzdHJpbmdcIj09dHlwZW9mIG4ubGluZUpvaW4mJi0xIT09aC5pbmRleE9mKG4ubGluZUpvaW4pfHwobi5saW5lSm9pbj1jKSxuLmdyYWRpZW50cyYmbi5maWxsP24uZ3JhZGllbnRzPSEwOm4uZ3JhZGllbnRzPSExLG4uZ3JhZGllbnRzJiYoKFwibnVtYmVyXCIhPXR5cGVvZiBuLmdyYWRpZW50U3RvcHN8fGlzTmFOKG4uZ3JhZGllbnRTdG9wcyl8fG4uZ3JhZGllbnRTdG9wczwyKSYmKG4uZ3JhZGllbnRTdG9wcz0yKSxuLmdyYWRpZW50U3RvcHM9TWF0aC5yb3VuZChuLmdyYWRpZW50U3RvcHMpKSwoXCJudW1iZXJcIiE9dHlwZW9mIG4udmVydGV4Q291bnR8fGlzTmFOKG4udmVydGV4Q291bnQpKSYmKG4udmVydGV4Q291bnQ9ZCksbi52ZXJ0ZXhDb3VudDw9MCYmKG4udmVydGV4Q291bnQ9MSksXCJzdHJpbmdcIiE9dHlwZW9mIG4udHJhbnNwYXJlbnRDb2xvciYmXCJib29sZWFuXCIhPXR5cGVvZiBuLnRyYW5zcGFyZW50Q29sb3ImJihuLnRyYW5zcGFyZW50Q29sb3I9ZyksITA9PT10eXBlb2Ygbi50cmFuc3BhcmVudENvbG9yJiYobi50cmFuc3BhcmVudENvbG9yPSExKSxcInN0cmluZ1wiPT10eXBlb2Ygbi50cmFuc3BhcmVudENvbG9yJiYobi50cmFuc3BhcmVudENvbG9yPWZ1bmN0aW9uKHQpe3ZhciBuPXIoe3dpZHRoOjEsaGVpZ2h0OjF9LHt9LDEsITApLmN0eDtuLmZpbGxTdHlsZT10LG4uZmlsbFJlY3QoMCwwLDEsMSk7dmFyIGU9bi5nZXRJbWFnZURhdGEoMCwwLDEsMSkuZGF0YTtyZXR1cm57cjplWzBdLGc6ZVsxXSxiOmVbMl0sYTplWzNdLzI1NX19KG4udHJhbnNwYXJlbnRDb2xvcikpLG59ZnVuY3Rpb24geSh0KXtpZih0IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCl7aWYoIXQubmF0dXJhbFdpZHRofHwhdC5uYXR1cmFsSGVpZ2h0fHwhMT09PXQuY29tcGxldGUpdGhyb3cgbmV3IEVycm9yKFwiVGhpcyB0aGlzIGltYWdlIGhhc24ndCBmaW5pc2hlZCBsb2FkaW5nOiBcIit0LnNyYyk7dmFyIG49bmV3IGUodC5uYXR1cmFsV2lkdGgsdC5uYXR1cmFsSGVpZ2h0KSxhPW4uZ2V0Q29udGV4dChcIjJkXCIpO2EuZHJhd0ltYWdlKHQsMCwwLG4ud2lkdGgsbi5oZWlnaHQpO3ZhciByPWEuZ2V0SW1hZ2VEYXRhKDAsMCxuLndpZHRoLG4uaGVpZ2h0KTtyZXR1cm4gci5kYXRhJiZyLmRhdGEubGVuZ3RoJiYodm9pZCAwPT09ci53aWR0aCYmKHIud2lkdGg9dC5uYXR1cmFsV2lkdGgpLHZvaWQgMD09PXIuaGVpZ2h0JiYoci5oZWlnaHQ9dC5uYXR1cmFsSGVpZ2h0KSkscn10aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG9iamVjdCBkb2VzIG5vdCBzZWVtIHRvIGJlIGFuIGltYWdlLlwiKX12YXIgZj1PYmplY3QuYXNzaWduO2Z1bmN0aW9uIHgodCl7dmFyIG49Zih7YToxfSx0KTtyZXR1cm5cInJnYmEoXCIrbi5yK1wiLCBcIituLmcrXCIsIFwiK24uYitcIiwgXCIrbi5hK1wiKVwifWZ1bmN0aW9uIGIodCxuLGUsYSl7cmV0dXJuIGE9YXx8MSxuLmZvckVhY2goKGZ1bmN0aW9uKG4sZSl7aWYodC5iZWdpblBhdGgoKSx0Lm1vdmVUbyhuLmEueCphLG4uYS55KmEpLHQubGluZVRvKG4uYi54KmEsbi5iLnkqYSksdC5saW5lVG8obi5jLngqYSxuLmMueSphKSx0LmxpbmVUbyhuLmEueCphLG4uYS55KmEpLG4uZ3JhZGllbnQpe3ZhciByPXQuY3JlYXRlTGluZWFyR3JhZGllbnQobi5ncmFkaWVudC54MSphLG4uZ3JhZGllbnQueTEqYSxuLmdyYWRpZW50LngyKmEsbi5ncmFkaWVudC55MiphKSxvPW4uZ3JhZGllbnQuY29sb3JzLmxlbmd0aC0xO24uZ3JhZGllbnQuY29sb3JzLmZvckVhY2goKGZ1bmN0aW9uKHQsbil7dmFyIGU9eCh0KTtjb25zb2xlLmxvZyh0KSxyLmFkZENvbG9yU3RvcChuL28sZSl9KSksdC5maWxsU3R5bGU9cix0LmZpbGwoKSxuLnN0cm9rZVdpZHRoPjAmJih0LnN0cm9rZVN0eWxlPXIsdC5saW5lV2lkdGg9bi5zdHJva2VXaWR0aCphLHQubGluZUpvaW49bi5saW5lSm9pbix0LnN0cm9rZSgpKX1lbHNlIG4uZmlsbCYmKHQuZmlsbFN0eWxlPXgobi5maWxsKSx0LmZpbGwoKSksbi5zdHJva2VDb2xvciYmKHQuc3Ryb2tlU3R5bGU9eChuLnN0cm9rZUNvbG9yKSx0LmxpbmVXaWR0aD1uLnN0cm9rZVdpZHRoKmEsdC5saW5lSm9pbj1uLmxpbmVKb2luLHQuc3Ryb2tlKCkpO3QuY2xvc2VQYXRoKCl9KSksdH1mdW5jdGlvbiB2KHQsbixlKXt2YXIgYT1lJiZlLmRwcj9lLmRwcjoxLG89cihuLGUsYSwhMCkuY3R4O3JldHVybiBiKG8sdCwwLGEpLG8uZ2V0SW1hZ2VEYXRhKDAsMCxuLndpZHRoKmEsbi5oZWlnaHQqYSl9ZnVuY3Rpb24gdyh0LG4sZSl7dmFyIGE9ZSYmZS5kcHI/ZS5kcHI6MSxvPXIobixlLGEpO3JldHVybiBiKG8uY3R4LHQsMCxhKSxvLmNhbnZhcy50b0RhdGFVUkwoKX1mdW5jdGlvbiBfKHQpe3ZhciBuPXQudG9TdHJpbmcoMTYpO3JldHVybiAxPT1uLmxlbmd0aD9cIjBcIituOm59ZnVuY3Rpb24gayh0KXt2YXIgbj10LnIsZT10LmcsYT10LmI7cmV0dXJuXCIjXCIrXyhuKStfKGUpK18oYSl9ZnVuY3Rpb24gRCh0LG4pe3ZhciBlPVwiXCI7dC5sZW5ndGgmJnRbMF0uZ3JhZGllbnQmJihlPVwiPGRlZnM+XCIpO3ZhciBhPVwiXCI7cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCxuKXt2YXIgcj10LmEsbz10LmIsaT10LmM7aWYoYSs9Jzxwb2x5Z29uIHBvaW50cz1cIicrci54K1wiLFwiK3IueStcIiBcIitvLngrXCIsXCIrby55K1wiIFwiK2kueCtcIixcIitpLnkrJ1wiJyx0LmdyYWRpZW50KXt2YXIgcz10LmJvdW5kaW5nQm94LGw9KCh0LmdyYWRpZW50LngxLXMueCkvcy53aWR0aCoxMDApLnRvRml4ZWQoMyksdT0oKHQuZ3JhZGllbnQueTEtcy55KS9zLmhlaWdodCoxMDApLnRvRml4ZWQoMyksYz0oKHQuZ3JhZGllbnQueDItcy54KS9zLndpZHRoKjEwMCkudG9GaXhlZCgzKSxkPSgodC5ncmFkaWVudC55Mi1zLnkpL3MuaGVpZ2h0KjEwMCkudG9GaXhlZCgzKTtlKz0nXFxuXFx0PGxpbmVhckdyYWRpZW50IGlkPVwiZ3JhZGllbnQtJytuKydcIiB4MT1cIicrbCsnJVwiIHkxPVwiJyt1KyclXCIgeDI9XCInK2MrJyVcIiB5Mj1cIicrZCsnJVwiPic7dmFyIHA9dC5ncmFkaWVudC5jb2xvcnMubGVuZ3RoLTE7dC5ncmFkaWVudC5jb2xvcnMuZm9yRWFjaCgoZnVuY3Rpb24odCxuKXt2YXIgYT1rKHQpLHI9dC5hPDE/JyBzdG9wLW9wYWNpdHk9XCInK3QuYSsnXCInOlwiXCIsbz0obi9wKjEwMCkudG9GaXhlZCgzKTtlKz0nXFxuXFx0XFx0XFx0XFx0XFx0PHN0b3Agb2Zmc2V0PVwiJytvKyclXCIgc3RvcC1jb2xvcj1cIicrYSsnXCInK3IrXCIvPlxcblxcdFxcdFxcdFxcdFwifSkpLGUrPVwiPC9saW5lYXJHcmFkaWVudD5cIixhKz0nIGZpbGw9XCJ1cmwoI2dyYWRpZW50LScrbisnKVwiJyx0LnN0cm9rZVdpZHRoPjAmJihhKz0nIHN0cm9rZT1cInVybCgjZ3JhZGllbnQtJytuKycpXCIgc3Ryb2tlLXdpZHRoPVwiJyt0LnN0cm9rZVdpZHRoKydcIiBzdHJva2UtbGluZWpvaW49XCInK3QubGluZUpvaW4rJ1wiJyl9ZWxzZXtpZih0LmZpbGwpe3ZhciBnPWsodC5maWxsKSxoPXQuZmlsbC5hPDE/JyBmaWxsLW9wYWNpdHk9XCInK3QuZmlsbC5hKydcIic6XCJcIjthKz0nIGZpbGw9XCInK2crJ1wiJytofWVsc2UgYSs9JyBmaWxsPVwidHJhbnNwYXJlbnRcIic7aWYodC5zdHJva2VDb2xvcil7dmFyIG09ayh0LnN0cm9rZUNvbG9yKSx5PXQuc3Ryb2tlQ29sb3IuYTwxPycgc3Ryb2tlLW9wYWNpdHk9XCInK3Quc3Ryb2tlQ29sb3IuYSsnXCInOlwiXCI7YSs9JyBzdHJva2U9XCInK20rJ1wiIHN0cm9rZS13aWR0aD1cIicrdC5zdHJva2VXaWR0aCsnXCIgc3Ryb2tlLWxpbmVqb2luPVwiJyt0LmxpbmVKb2luKydcIicreX19YSs9XCIvPlxcblxcdFwifSkpLGUubGVuZ3RoJiYoZSs9XCJcXG5cXHRcXHQ8L2RlZnM+XCIpLCc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgc3RhbmRhbG9uZT1cInllc1wiPz5cXG48c3ZnIHdpZHRoPVwiJytuLndpZHRoKydcIiBoZWlnaHQ9XCInK24uaGVpZ2h0KydcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmVyc2lvbj1cIjEuMVwiID5cXG5cXHQnK2UrXCJcXG5cXHRcIithK1wiXFxuPC9zdmc+XCJ9ZnVuY3Rpb24gSSh0LG4pe3JldHVybiB0KG49e2V4cG9ydHM6e319LG4uZXhwb3J0cyksbi5leHBvcnRzfVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OnZvaWQgMCE9PW58fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmO3ZhciBDPUkoKGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4odCxuLGUpe3RoaXMuYT10LHRoaXMuYj1uLHRoaXMuYz1lO3ZhciBhLHIsbyxpLHM9bi54LXQueCxsPW4ueS10LnksdT1lLngtdC54LGM9ZS55LXQueSxkPXMqKHQueCtuLngpK2wqKHQueStuLnkpLHA9dSoodC54K2UueCkrYyoodC55K2UueSksZz0yKihzKihlLnktbi55KS1sKihlLngtbi54KSk7TWF0aC5hYnMoZyk8MWUtNj8oYT1NYXRoLm1pbih0Lngsbi54LGUueCkscj1NYXRoLm1pbih0Lnksbi55LGUueSksbz0uNSooTWF0aC5tYXgodC54LG4ueCxlLngpLWEpLGk9LjUqKE1hdGgubWF4KHQueSxuLnksZS55KS1yKSx0aGlzLng9YStvLHRoaXMueT1yK2ksdGhpcy5yPW8qbytpKmkpOih0aGlzLng9KGMqZC1sKnApL2csdGhpcy55PShzKnAtdSpkKS9nLG89dGhpcy54LXQueCxpPXRoaXMueS10LnksdGhpcy5yPW8qbytpKmkpfWZ1bmN0aW9uIGUodCxuKXtyZXR1cm4gbi54LXQueH1mdW5jdGlvbiBhKHQpe3ZhciBuLGUsYSxyLG8saT10Lmxlbmd0aDt0OmZvcig7aTspZm9yKGU9dFstLWldLG49dFstLWldLGE9aTthOylpZihvPXRbLS1hXSxuPT09KHI9dFstLWFdKSYmZT09PW98fG49PT1vJiZlPT09cil7dC5zcGxpY2UoaSwyKSx0LnNwbGljZShhLDIpLGktPTI7Y29udGludWUgdH19bi5wcm90b3R5cGUuZHJhdz1mdW5jdGlvbih0KXt0LmJlZ2luUGF0aCgpLHQubW92ZVRvKHRoaXMuYS54LHRoaXMuYS55KSx0LmxpbmVUbyh0aGlzLmIueCx0aGlzLmIueSksdC5saW5lVG8odGhpcy5jLngsdGhpcy5jLnkpLHQuY2xvc2VQYXRoKCksdC5zdHJva2UoKX0sdC5leHBvcnRzPXtUcmlhbmdsZTpuLHRyaWFuZ3VsYXRlOmZ1bmN0aW9uKHQpe2lmKHQubGVuZ3RoPDMpcmV0dXJuW107dC5zb3J0KGUpO2Zvcih2YXIgcj10Lmxlbmd0aC0xLG89dFtyXS54LGk9dFswXS54LHM9dFtyXS55LGw9cztyLS07KXRbcl0ueTxzJiYocz10W3JdLnkpLHRbcl0ueT5sJiYobD10W3JdLnkpO3ZhciB1LGMsZCxwPWktbyxnPWwtcyxoPXA+Zz9wOmcsbT0uNSooaStvKSx5PS41KihsK3MpLGY9W25ldyBuKHt4Om0tMjAqaCx5OnktaCxfX3NlbnRpbmVsOiEwfSx7eDptLHk6eSsyMCpoLF9fc2VudGluZWw6ITB9LHt4Om0rMjAqaCx5OnktaCxfX3NlbnRpbmVsOiEwfSldLHg9W10sYj1bXTtmb3Iocj10Lmxlbmd0aDtyLS07KXtmb3IoYi5sZW5ndGg9MCx1PWYubGVuZ3RoO3UtLTspKHA9dFtyXS54LWZbdV0ueCk+MCYmcCpwPmZbdV0ucj8oeC5wdXNoKGZbdV0pLGYuc3BsaWNlKHUsMSkpOnAqcCsoZz10W3JdLnktZlt1XS55KSpnPmZbdV0ucnx8KGIucHVzaChmW3VdLmEsZlt1XS5iLGZbdV0uYixmW3VdLmMsZlt1XS5jLGZbdV0uYSksZi5zcGxpY2UodSwxKSk7Zm9yKGEoYiksdT1iLmxlbmd0aDt1OylkPWJbLS11XSxjPWJbLS11XSxmLnB1c2gobmV3IG4oYyxkLHRbcl0pKX1mb3IoQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoeCxmKSxyPXgubGVuZ3RoO3ItLTspKHhbcl0uYS5fX3NlbnRpbmVsfHx4W3JdLmIuX19zZW50aW5lbHx8eFtyXS5jLl9fc2VudGluZWwpJiZ4LnNwbGljZShyLDEpO3JldHVybiB4fX19KSksUD0oQy5UcmlhbmdsZSxDLnRyaWFuZ3VsYXRlKSxTPUkoKGZ1bmN0aW9uKHQsbil7IWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGEodCl7aWYoISh0aGlzIGluc3RhbmNlb2YgYSkpcmV0dXJuIG5ldyBhKHQpO3ZhciBuPXQud2lkdGgsZT10LmhlaWdodCxyPVtbLTEsMCwxXSxbLTIsMCwyXSxbLTEsMCwxXV0sbz1bWy0xLC0yLC0xXSxbMCwwLDBdLFsxLDIsMV1dLGk9W10scz1bXTtmdW5jdGlvbiBsKHQpe3JldHVybiBmdW5jdGlvbihlLGEscil7cmV0dXJuIHRbNCoobiphK2UpKyhyPXJ8fDApXX19dmFyIHUsYyxkPWwodC5kYXRhKTtmb3IoYz0wO2M8ZTtjKyspZm9yKHU9MDt1PG47dSsrKXt2YXIgcD0oZCh1LGMsMCkrZCh1LGMsMSkrZCh1LGMsMikpLzM7cy5wdXNoKHAscCxwLDI1NSl9Zm9yKGQ9bChzKSxjPTA7YzxlO2MrKylmb3IodT0wO3U8bjt1Kyspe3ZhciBnPXJbMF1bMF0qZCh1LTEsYy0xKStyWzBdWzFdKmQodSxjLTEpK3JbMF1bMl0qZCh1KzEsYy0xKStyWzFdWzBdKmQodS0xLGMpK3JbMV1bMV0qZCh1LGMpK3JbMV1bMl0qZCh1KzEsYykrclsyXVswXSpkKHUtMSxjKzEpK3JbMl1bMV0qZCh1LGMrMSkrclsyXVsyXSpkKHUrMSxjKzEpLGg9b1swXVswXSpkKHUtMSxjLTEpK29bMF1bMV0qZCh1LGMtMSkrb1swXVsyXSpkKHUrMSxjLTEpK29bMV1bMF0qZCh1LTEsYykrb1sxXVsxXSpkKHUsYykrb1sxXVsyXSpkKHUrMSxjKStvWzJdWzBdKmQodS0xLGMrMSkrb1syXVsxXSpkKHUsYysxKStvWzJdWzJdKmQodSsxLGMrMSksbT1NYXRoLnNxcnQoZypnK2gqaCk+Pj4wO2kucHVzaChtLG0sbSwyNTUpfXZhciB5PWk7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgVWludDhDbGFtcGVkQXJyYXkmJih5PW5ldyBVaW50OENsYW1wZWRBcnJheShpKSkseS50b0ltYWdlRGF0YT1mdW5jdGlvbigpe3JldHVybiBhLnRvSW1hZ2VEYXRhKHksbixlKX0seX1mdW5jdGlvbiByKHQsbixlKXtyZXR1cm57d2lkdGg6bixoZWlnaHQ6ZSxkYXRhOnR9fWEudG9JbWFnZURhdGE9ZnVuY3Rpb24odCxuLGUpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIEltYWdlRGF0YSYmXCJbb2JqZWN0IFVpbnQxNkFycmF5XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKXJldHVybiBuZXcgSW1hZ2VEYXRhKHQsbixlKTtpZihcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiZcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93LmRvY3VtZW50KXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGEuZ2V0Q29udGV4dCl7dmFyIG89YS5nZXRDb250ZXh0KFwiMmRcIikuY3JlYXRlSW1hZ2VEYXRhKG4sZSk7cmV0dXJuIG8uZGF0YS5zZXQodCksb31yZXR1cm4gbmV3IHIodCxuLGUpfXJldHVybiBuZXcgcih0LG4sZSl9LHQuZXhwb3J0cyYmKG49dC5leHBvcnRzPWEpLG4uU29iZWw9YX0oKX0pKTtmdW5jdGlvbiBBKHQpe3JldHVybiB0JiZcIm51bWJlclwiPT10eXBlb2YgdC53aWR0aCYmXCJudW1iZXJcIj09dHlwZW9mIHQuaGVpZ2h0JiZ0LmRhdGEmJlwibnVtYmVyXCI9PXR5cGVvZiB0LmRhdGEubGVuZ3RoJiZcIm9iamVjdFwiPT10eXBlb2YgdC5kYXRhfWZ1bmN0aW9uIEUodCl7aWYoQSh0KSl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93KXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvcHkgaW1hZ2VEYXRhIGluIHdlYndvcmtlciB3aXRob3V0IFVpbnQ4Q2xhbXBlZEFycmF5IHN1cHBvcnQuXCIpO3JldHVybiBqKHQpfXZhciBuLGU9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHQuZGF0YSk7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIEltYWdlRGF0YSlyZXR1cm57d2lkdGg6dC53aWR0aCxoZWlnaHQ6dC5oZWlnaHQsZGF0YTplfTt0cnl7bj1uZXcgSW1hZ2VEYXRhKGUsdC53aWR0aCx0LmhlaWdodCl9Y2F0Y2goZSl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdyl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb3B5IGltYWdlRGF0YSBpbiB3ZWJ3b3JrZXIgd2l0aG91dCBwcm9wZXIgSW1hZ2VEYXRhKCkgc3VwcG9ydC5cIik7bj1qKHQpfXJldHVybiBufXRocm93IG5ldyBFcnJvcihcIkdpdmVuIGltYWdlRGF0YSBvYmplY3QgaXMgbm90IHVzZWFibGUuXCIpfWZ1bmN0aW9uIGoodCl7dmFyIG49bmV3IGUodC53aWR0aCx0LmhlaWdodCkuZ2V0Q29udGV4dChcIjJkXCIpO3JldHVybiBuLnB1dEltYWdlRGF0YSh0LDAsMCksbi5nZXRJbWFnZURhdGEoMCwwLHQud2lkdGgsdC5oZWlnaHQpfVMuU29iZWw7dmFyIE89WzUxMiw1MTIsNDU2LDUxMiwzMjgsNDU2LDMzNSw1MTIsNDA1LDMyOCwyNzEsNDU2LDM4OCwzMzUsMjkyLDUxMiw0NTQsNDA1LDM2NCwzMjgsMjk4LDI3MSw0OTYsNDU2LDQyMCwzODgsMzYwLDMzNSwzMTIsMjkyLDI3Myw1MTIsNDgyLDQ1NCw0MjgsNDA1LDM4MywzNjQsMzQ1LDMyOCwzMTIsMjk4LDI4NCwyNzEsMjU5LDQ5Niw0NzUsNDU2LDQzNyw0MjAsNDA0LDM4OCwzNzQsMzYwLDM0NywzMzUsMzIzLDMxMiwzMDIsMjkyLDI4MiwyNzMsMjY1LDUxMiw0OTcsNDgyLDQ2OCw0NTQsNDQxLDQyOCw0MTcsNDA1LDM5NCwzODMsMzczLDM2NCwzNTQsMzQ1LDMzNywzMjgsMzIwLDMxMiwzMDUsMjk4LDI5MSwyODQsMjc4LDI3MSwyNjUsMjU5LDUwNyw0OTYsNDg1LDQ3NSw0NjUsNDU2LDQ0Niw0MzcsNDI4LDQyMCw0MTIsNDA0LDM5NiwzODgsMzgxLDM3NCwzNjcsMzYwLDM1NCwzNDcsMzQxLDMzNSwzMjksMzIzLDMxOCwzMTIsMzA3LDMwMiwyOTcsMjkyLDI4NywyODIsMjc4LDI3MywyNjksMjY1LDI2MSw1MTIsNTA1LDQ5Nyw0ODksNDgyLDQ3NSw0NjgsNDYxLDQ1NCw0NDcsNDQxLDQzNSw0MjgsNDIyLDQxNyw0MTEsNDA1LDM5OSwzOTQsMzg5LDM4MywzNzgsMzczLDM2OCwzNjQsMzU5LDM1NCwzNTAsMzQ1LDM0MSwzMzcsMzMyLDMyOCwzMjQsMzIwLDMxNiwzMTIsMzA5LDMwNSwzMDEsMjk4LDI5NCwyOTEsMjg3LDI4NCwyODEsMjc4LDI3NCwyNzEsMjY4LDI2NSwyNjIsMjU5LDI1Nyw1MDcsNTAxLDQ5Niw0OTEsNDg1LDQ4MCw0NzUsNDcwLDQ2NSw0NjAsNDU2LDQ1MSw0NDYsNDQyLDQzNyw0MzMsNDI4LDQyNCw0MjAsNDE2LDQxMiw0MDgsNDA0LDQwMCwzOTYsMzkyLDM4OCwzODUsMzgxLDM3NywzNzQsMzcwLDM2NywzNjMsMzYwLDM1NywzNTQsMzUwLDM0NywzNDQsMzQxLDMzOCwzMzUsMzMyLDMyOSwzMjYsMzIzLDMyMCwzMTgsMzE1LDMxMiwzMTAsMzA3LDMwNCwzMDIsMjk5LDI5NywyOTQsMjkyLDI4OSwyODcsMjg1LDI4MiwyODAsMjc4LDI3NSwyNzMsMjcxLDI2OSwyNjcsMjY1LDI2MywyNjEsMjU5XSxNPVs5LDExLDEyLDEzLDEzLDE0LDE0LDE1LDE1LDE1LDE1LDE2LDE2LDE2LDE2LDE3LDE3LDE3LDE3LDE3LDE3LDE3LDE4LDE4LDE4LDE4LDE4LDE4LDE4LDE4LDE4LDE5LDE5LDE5LDE5LDE5LDE5LDE5LDE5LDE5LDE5LDE5LDE5LDE5LDE5LDIwLDIwLDIwLDIwLDIwLDIwLDIwLDIwLDIwLDIwLDIwLDIwLDIwLDIwLDIwLDIwLDIwLDIwLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIxLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIyLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDIzLDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0LDI0XTtmdW5jdGlvbiBUKCl7dGhpcy5yPTAsdGhpcy5nPTAsdGhpcy5iPTAsdGhpcy5hPTAsdGhpcy5uZXh0PW51bGx9ZnVuY3Rpb24gUih0LG4sZSl7dmFyIGE9dCtcInxcIituO2VbYV18fChlW2FdPXt4OnQseTpufSksYT1udWxsfWZ1bmN0aW9uIEIobixlLGEpe3ZhciByPSgwfHQobi54LDEsZS53aWR0aC0yKSkrKDB8dChuLnksMSxlLmhlaWdodC0yKSkqZS53aWR0aDw8MjtyPj1lLmRhdGEubGVuZ3RoJiYocj1lLmRhdGEubGVuZ3RoLTUpO3ZhciBvPWUuZGF0YVtyKzNdLzI1NTtyZXR1cm4gYSYmMD09PW8/YTp7cjplLmRhdGFbcl0sZzplLmRhdGFbcisxXSxiOmUuZGF0YVtyKzJdLGE6b319ZnVuY3Rpb24gTih0KXtyZXR1cm57eDouMzMzMzMqKHQuYS54K3QuYi54K3QuYy54KSx5Oi4zMzMzMyoodC5hLnkrdC5iLnkrdC5jLnkpfX1mdW5jdGlvbiBXKHQpe3JldHVybiAwPT09dC5hfWZ1bmN0aW9uIEwodCl7dmFyIG49ZnVuY3Rpb24odCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe3ZhciBuPVswLDAsMCwwXTtyZXR1cm5cIiNcIj09PXRbMF0mJih0Lmxlbmd0aDw3JiYodD1cIiNcIit0WzFdK3RbMV0rdFsyXSt0WzJdK3RbM10rdFszXSsodC5sZW5ndGg+ND90WzRdK3RbNF06XCJcIikpLG49W3BhcnNlSW50KHQuc3Vic3RyKDEsMiksMTYpLHBhcnNlSW50KHQuc3Vic3RyKDMsMiksMTYpLHBhcnNlSW50KHQuc3Vic3RyKDUsMiksMTYpLHQubGVuZ3RoPjc/cGFyc2VJbnQodC5zdWJzdHIoNywyKSwxNikvMjU1OjFdKSwwPT09dC5pbmRleE9mKFwicmdiXCIpJiYodC5pbmNsdWRlcyhcInJnYmFcIil8fCh0Kz1cIiwxXCIpLG49dC5tYXRjaCgvW1xcLlxcZF0rL2cpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuK3R9KSkpLG59fSh0KTtyZXR1cm4gbj97cjpuWzBdLGc6blsxXSxiOm5bMl0sYTpuWzNdfTp2b2lkIDB9ZnVuY3Rpb24gRih0KXt2YXIgbj1bdC5yLHQuZyx0LmJdLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuKHQvPTI1NSk8PS4wMzkyOD90LzEyLjkyOk1hdGgucG93KCh0Ky4wNTUpLzEuMDU1LDIuNCl9KSk7cmV0dXJuLjIxMjYqblswXSsuNzE1MipuWzFdKy4wNzIyKm5bMl19ZnVuY3Rpb24gSCh0LG4sZSl7cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGE9e307XCJhYmNcIi5zcGxpdChcIlwiKS5mb3JFYWNoKChmdW5jdGlvbihyKXt2YXIgbz1CKHRbcl0sbixlLnRyYW5zcGFyZW50Q29sb3IpO2Fbcl09e2tleTpyLGNvbG9yOm8seDp0W3JdLngseTp0W3JdLnl9LGFbcl0ubHVtaW5hbmNlPUYoYVtyXS5jb2xvcik7dmFyIGk9XCJhYmNcIi5yZXBsYWNlKHIsXCJcIikuc3BsaXQoXCJcIik7YVtyXS5tZWRpYW49e3g6KHRbaVswXV0ueCt0W2lbMV1dLngpLzIseToodFtpWzBdXS55K3RbaVsxXV0ueSkvMn0sYVtyXS5tZWRpYW5Db2xvcj1CKGFbcl0ubWVkaWFuLG4sZS50cmFuc3BhcmVudENvbG9yKSxhW3JdLm1lZGlhbkx1bWluYW5jZT1GKGFbcl0ubWVkaWFuQ29sb3IpfSkpO2Zvcih2YXIgcixvLGkscyxsPVthLmEsYS5iLGEuY10uc29ydCgoZnVuY3Rpb24odCxuKXtyZXR1cm4gTWF0aC5hYnModC5sdW1pbmFuY2UtdC5tZWRpYW5MdW1pbmFuY2UpLU1hdGguYWJzKG4ubHVtaW5hbmNlLW4ubWVkaWFuTHVtaW5hbmNlKX0pKSx1PWxbMF0sYz1sWzBdLGQ9dS5tZWRpYW4scD1bY10sZz0ocj1jLGk9KG89ZCkueC1yLngscz1vLnktci55LE1hdGguc3FydChpKmkrcypzKSksaD0xLG09ZS5ncmFkaWVudFN0b3BzLTI7aDxtO2grKyl7dmFyIHk9aCooZy9lLmdyYWRpZW50U3RvcHMpL2csZj17eDpjLngreSooZC54LWMueCkseTpjLnkreSooZC55LWMueSl9O3AucHVzaChmKX1wLnB1c2goZCksdC5ncmFkaWVudD17eDE6dS54LHkxOnUueSx4Mjp1Lm1lZGlhbi54LHkyOnUubWVkaWFuLnksY29sb3JzOnAubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gQih0LG4sZS50cmFuc3BhcmVudENvbG9yKX0pKX0sZS5zdHJva2UmJih0LnN0cm9rZVdpZHRoPWUuc3Ryb2tlV2lkdGgsdC5saW5lSm9pbj1lLmxpbmVKb2luKSxhPW51bGx9KSksdH1mdW5jdGlvbiBHKHQsbil7aWYoQSh0KSl7dmFyIGU9e3dpZHRoOnQud2lkdGgsaGVpZ2h0OnQuaGVpZ2h0fSxhPUUodCkscj1FKHQpLG89ZnVuY3Rpb24odCl7Zm9yKHZhciBuLGU9dC5kYXRhLmxlbmd0aCxhPTA7YTxlO2ErPTQpbj0uMzQqdC5kYXRhW2FdKy41KnQuZGF0YVthKzFdKy4xNip0LmRhdGFbYSsyXSx0LmRhdGFbYV09bix0LmRhdGFbYSsxXT1uLHQuZGF0YVthKzJdPW47cmV0dXJuIHR9KGZ1bmN0aW9uKHQsbixlLGEscixvKXt2YXIgaSxzLGwsdSxjLGQscCxnLGgsbSx5LGYseCxiLHYsdyxfLGssRCxJLEMsUCxTLEEsRT10LmRhdGEsaj1vK28rMSxSPWEtMSxCPXItMSxOPW8rMSxXPU4qKE4rMSkvMixMPW5ldyBULEY9TDtmb3IobD0xO2w8ajtsKyspaWYoRj1GLm5leHQ9bmV3IFQsbD09Til2YXIgSD1GO0YubmV4dD1MO3ZhciBHPW51bGwsVT1udWxsO3A9ZD0wO3ZhciBKPU9bb10sWT1NW29dO2ZvcihzPTA7czxyO3MrKyl7Zm9yKHc9Xz1rPUQ9Zz1oPW09eT0wLGY9TiooST1FW2RdKSx4PU4qKEM9RVtkKzFdKSxiPU4qKFA9RVtkKzJdKSx2PU4qKFM9RVtkKzNdKSxnKz1XKkksaCs9VypDLG0rPVcqUCx5Kz1XKlMsRj1MLGw9MDtsPE47bCsrKUYucj1JLEYuZz1DLEYuYj1QLEYuYT1TLEY9Ri5uZXh0O2ZvcihsPTE7bDxOO2wrKyl1PWQrKChSPGw/UjpsKTw8MiksZys9KEYucj1JPUVbdV0pKihBPU4tbCksaCs9KEYuZz1DPUVbdSsxXSkqQSxtKz0oRi5iPVA9RVt1KzJdKSpBLHkrPShGLmE9Uz1FW3UrM10pKkEsdys9SSxfKz1DLGsrPVAsRCs9UyxGPUYubmV4dDtmb3IoRz1MLFU9SCxpPTA7aTxhO2krKylFW2QrM109Uz15Kko+PlksMCE9Uz8oUz0yNTUvUyxFW2RdPShnKko+PlkpKlMsRVtkKzFdPShoKko+PlkpKlMsRVtkKzJdPShtKko+PlkpKlMpOkVbZF09RVtkKzFdPUVbZCsyXT0wLGctPWYsaC09eCxtLT1iLHktPXYsZi09Ry5yLHgtPUcuZyxiLT1HLmIsdi09Ry5hLHU9cCsoKHU9aStvKzEpPFI/dTpSKTw8MixnKz13Kz1HLnI9RVt1XSxoKz1fKz1HLmc9RVt1KzFdLG0rPWsrPUcuYj1FW3UrMl0seSs9RCs9Ry5hPUVbdSszXSxHPUcubmV4dCxmKz1JPVUucix4Kz1DPVUuZyxiKz1QPVUuYix2Kz1TPVUuYSx3LT1JLF8tPUMsay09UCxELT1TLFU9VS5uZXh0LGQrPTQ7cCs9YX1mb3IoaT0wO2k8YTtpKyspe2ZvcihfPWs9RD13PWg9bT15PWc9MCxmPU4qKEk9RVtkPWk8PDJdKSx4PU4qKEM9RVtkKzFdKSxiPU4qKFA9RVtkKzJdKSx2PU4qKFM9RVtkKzNdKSxnKz1XKkksaCs9VypDLG0rPVcqUCx5Kz1XKlMsRj1MLGw9MDtsPE47bCsrKUYucj1JLEYuZz1DLEYuYj1QLEYuYT1TLEY9Ri5uZXh0O2ZvcihjPWEsbD0xO2w8PW87bCsrKWQ9YytpPDwyLGcrPShGLnI9ST1FW2RdKSooQT1OLWwpLGgrPShGLmc9Qz1FW2QrMV0pKkEsbSs9KEYuYj1QPUVbZCsyXSkqQSx5Kz0oRi5hPVM9RVtkKzNdKSpBLHcrPUksXys9QyxrKz1QLEQrPVMsRj1GLm5leHQsbDxCJiYoYys9YSk7Zm9yKGQ9aSxHPUwsVT1ILHM9MDtzPHI7cysrKUVbMysodT1kPDwyKV09Uz15Kko+PlksUz4wPyhTPTI1NS9TLEVbdV09KGcqSj4+WSkqUyxFW3UrMV09KGgqSj4+WSkqUyxFW3UrMl09KG0qSj4+WSkqUyk6RVt1XT1FW3UrMV09RVt1KzJdPTAsZy09ZixoLT14LG0tPWIseS09dixmLT1HLnIseC09Ry5nLGItPUcuYix2LT1HLmEsdT1pKygodT1zK04pPEI/dTpCKSphPDwyLGcrPXcrPUcucj1FW3VdLGgrPV8rPUcuZz1FW3UrMV0sbSs9ays9Ry5iPUVbdSsyXSx5Kz1EKz1HLmE9RVt1KzNdLEc9Ry5uZXh0LGYrPUk9VS5yLHgrPUM9VS5nLGIrPVA9VS5iLHYrPVM9VS5hLHctPUksXy09QyxrLT1QLEQtPVMsVT1VLm5leHQsZCs9YX1yZXR1cm4gdH0oYSwwLDAsZS53aWR0aCxlLmhlaWdodCxuLmJsdXIpKSxpPWZ1bmN0aW9uKHQsbixlLGEscil7dmFyIG89e30saT1NYXRoLm1heCh+fihuKigxLWUpKSw1KSxzPU1hdGgucm91bmQoTWF0aC5zcXJ0KGkpKSxsPX5+KGEvcyksdT1+fihyL01hdGgucm91bmQoTWF0aC5jZWlsKGkvcykpKSxjPTAsZD0wLHA9MDtmb3IocD0wO3A8cjtwKz11KWZvcihkPSsrYyUyPT0wP35+KGwvMik6MDtkPGE7ZCs9bClkPGEmJnA8ciYmUih+fihkK01hdGguY29zKHApKnUpLH5+KHArTWF0aC5zaW4oZCkqbCksbyk7UigwLDAsbyksUihhLTEsMCxvKSxSKGEtMSxyLTEsbyksUigwLHItMSxvKTt2YXIgZz1uLU9iamVjdC5rZXlzKG8pLmxlbmd0aCxoPXQubGVuZ3RoLG09fn4oaC9nKTtpZihuPjAmJm0+MCl7dmFyIHk9MDtmb3IoeT0wO3k8aDt5Kz1tKVIodFt5XS54LHRbeV0ueSxvKX1yZXR1cm4gdD1udWxsLE9iamVjdC5rZXlzKG8pLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG9bdF19KSl9KGZ1bmN0aW9uKHQsbil7dmFyIGUsYSxyLG8saSxzLGwsdSxjLGQ9dC53aWR0aCxwPXQuaGVpZ2h0LGc9dC5kYXRhLGg9W107Zm9yKGE9MDthPHA7YSs9Milmb3IoZT0wO2U8ZDtlKz0yKXtmb3IodT1jPTAscj0tMTtyPD0xO3IrKylpZihsPShzPWErcikqZCxzPj0wJiZzPHApZm9yKG89LTE7bzw9MTtvKyspKGk9ZStvKT49MCYmaTxkJiYodSs9Z1tpK2w8PDJdLGMrKyk7YyYmKHUvPWMpLHU+biYmaC5wdXNoKHt4OmUseTphfSl9cmV0dXJuIGh9KFMobykudG9JbWFnZURhdGEoKSxuLnRocmVzaG9sZCksbi52ZXJ0ZXhDb3VudCxuLmFjY3VyYWN5LGUud2lkdGgsZS5oZWlnaHQpLHM9UChpKTtyZXR1cm4gcz1mdW5jdGlvbih0LG4sZSl7cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIG4sZSxhLHIsbzt0LmJvdW5kaW5nQm94PShuPVt0LmEsdC5iLHQuY10sZT0xLzAsYT0tMS8wLHI9MS8wLG89LTEvMCxuLmZvckVhY2goKGZ1bmN0aW9uKHQpe3QueDxlJiYoZT10LngpLHQueTxyJiYocj10LnkpLHQueD5hJiYoYT10LngpLHQueT5vJiYobz10LnkpfSkpLHt4OmUseTpyLHdpZHRoOmEtZSxoZWlnaHQ6by1yfSl9KSksdC5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmJvdW5kaW5nQm94LndpZHRoPjAmJnQuYm91bmRpbmdCb3guaGVpZ2h0PjB9KSl9KHMpLG4udHJhbnNwYXJlbnRDb2xvcnx8KHM9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdC5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiFXKEIoTih0KSxuKSl9KSl9KHMscikpLHM9ITA9PT1uLmZpbGwmJiEwPT09bi5ncmFkaWVudHM/SChzLHIsbik6ZnVuY3Rpb24odCxuLGUpe3ZhciBhPWUuZmlsbCxyPWUuc3Ryb2tlLG89ZS5zdHJva2VXaWR0aCxpPWUubGluZUpvaW4scz1lLnRyYW5zcGFyZW50Q29sb3IsbD0hIWEmJkwoYSksdT0hIXImJkwociksYz1mdW5jdGlvbih0LG4pe3ZhciBlPVcodCkmJnM7cmV0dXJuIG4mJiFlP246ZT9zOnR9O3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPUIoTih0KSxuKTthJiYodC5maWxsPWMoZSxsKSksciYmKHQuc3Ryb2tlQ29sb3I9YyhlLHUpLHQuc3Ryb2tlV2lkdGg9byx0LmxpbmVKb2luPWkpfSkpLHR9KHMscixuKX10aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB3b3JrIHdpdGggdGhlIGltYWdlRGF0YSBwcm92aWRlZC4gSXQgc2VlbXMgdG8gYmUgY29ycnVwdC5cIil9cmV0dXJuIGZ1bmN0aW9uKHQpe3Q9bSh0KTt2YXIgbixlLGE9ITEscj0hMSxvPW5ldyBXb3JrZXIoVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbXCJ2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xcblxcbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcXG5cXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XFxufVxcblxcbnZhciBkZWxhdW5heSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcXG5mdW5jdGlvbiBUcmlhbmdsZShhLCBiLCBjKSB7XFxuICB0aGlzLmEgPSBhO1xcbiAgdGhpcy5iID0gYjtcXG4gIHRoaXMuYyA9IGM7XFxuXFxuICB2YXIgQSA9IGIueCAtIGEueCxcXG4gICAgICBCID0gYi55IC0gYS55LFxcbiAgICAgIEMgPSBjLnggLSBhLngsXFxuICAgICAgRCA9IGMueSAtIGEueSxcXG4gICAgICBFID0gQSAqIChhLnggKyBiLngpICsgQiAqIChhLnkgKyBiLnkpLFxcbiAgICAgIEYgPSBDICogKGEueCArIGMueCkgKyBEICogKGEueSArIGMueSksXFxuICAgICAgRyA9IDIgKiAoQSAqIChjLnkgLSBiLnkpIC0gQiAqIChjLnggLSBiLngpKSxcXG4gICAgICBtaW54LCBtaW55LCBkeCwgZHk7XFxuXFxuICAvKiBJZiB0aGUgcG9pbnRzIG9mIHRoZSB0cmlhbmdsZSBhcmUgY29sbGluZWFyLCB0aGVuIGp1c3QgZmluZCB0aGVcXG4gICAqIGV4dHJlbWVzIGFuZCB1c2UgdGhlIG1pZHBvaW50IGFzIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmN1bWNpcmNsZS4gKi9cXG4gIGlmKE1hdGguYWJzKEcpIDwgMC4wMDAwMDEpIHtcXG4gICAgbWlueCA9IE1hdGgubWluKGEueCwgYi54LCBjLngpO1xcbiAgICBtaW55ID0gTWF0aC5taW4oYS55LCBiLnksIGMueSk7XFxuICAgIGR4ICAgPSAoTWF0aC5tYXgoYS54LCBiLngsIGMueCkgLSBtaW54KSAqIDAuNTtcXG4gICAgZHkgICA9IChNYXRoLm1heChhLnksIGIueSwgYy55KSAtIG1pbnkpICogMC41O1xcblxcbiAgICB0aGlzLnggPSBtaW54ICsgZHg7XFxuICAgIHRoaXMueSA9IG1pbnkgKyBkeTtcXG4gICAgdGhpcy5yID0gZHggKiBkeCArIGR5ICogZHk7XFxuICB9XFxuXFxuICBlbHNlIHtcXG4gICAgdGhpcy54ID0gKEQqRSAtIEIqRikgLyBHO1xcbiAgICB0aGlzLnkgPSAoQSpGIC0gQypFKSAvIEc7XFxuICAgIGR4ID0gdGhpcy54IC0gYS54O1xcbiAgICBkeSA9IHRoaXMueSAtIGEueTtcXG4gICAgdGhpcy5yID0gZHggKiBkeCArIGR5ICogZHk7XFxuICB9XFxufVxcblxcblRyaWFuZ2xlLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4KSB7XFxuICBjdHguYmVnaW5QYXRoKCk7XFxuICBjdHgubW92ZVRvKHRoaXMuYS54LCB0aGlzLmEueSk7XFxuICBjdHgubGluZVRvKHRoaXMuYi54LCB0aGlzLmIueSk7XFxuICBjdHgubGluZVRvKHRoaXMuYy54LCB0aGlzLmMueSk7XFxuICBjdHguY2xvc2VQYXRoKCk7XFxuICBjdHguc3Ryb2tlKCk7XFxufTtcXG5cXG5mdW5jdGlvbiBieVgoYSwgYikge1xcbiAgcmV0dXJuIGIueCAtIGEueFxcbn1cXG5cXG5mdW5jdGlvbiBkZWR1cChlZGdlcykge1xcbiAgdmFyIGogPSBlZGdlcy5sZW5ndGgsXFxuICAgICAgYSwgYiwgaSwgbSwgbjtcXG5cXG4gIG91dGVyOiB3aGlsZShqKSB7XFxuICAgIGIgPSBlZGdlc1stLWpdO1xcbiAgICBhID0gZWRnZXNbLS1qXTtcXG4gICAgaSA9IGo7XFxuICAgIHdoaWxlKGkpIHtcXG4gICAgICBuID0gZWRnZXNbLS1pXTtcXG4gICAgICBtID0gZWRnZXNbLS1pXTtcXG4gICAgICBpZigoYSA9PT0gbSAmJiBiID09PSBuKSB8fCAoYSA9PT0gbiAmJiBiID09PSBtKSkge1xcbiAgICAgICAgZWRnZXMuc3BsaWNlKGosIDIpO1xcbiAgICAgICAgZWRnZXMuc3BsaWNlKGksIDIpO1xcbiAgICAgICAgaiAtPSAyO1xcbiAgICAgICAgY29udGludWUgb3V0ZXJcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gdHJpYW5ndWxhdGUodmVydGljZXMpIHtcXG4gIC8qIEJhaWwgaWYgdGhlcmUgYXJlbid0IGVub3VnaCB2ZXJ0aWNlcyB0byBmb3JtIGFueSB0cmlhbmdsZXMuICovXFxuICBpZih2ZXJ0aWNlcy5sZW5ndGggPCAzKVxcbiAgICB7IHJldHVybiBbXSB9XFxuXFxuICAvKiBFbnN1cmUgdGhlIHZlcnRleCBhcnJheSBpcyBpbiBvcmRlciBvZiBkZXNjZW5kaW5nIFggY29vcmRpbmF0ZVxcbiAgICogKHdoaWNoIGlzIG5lZWRlZCB0byBlbnN1cmUgYSBzdWJxdWFkcmF0aWMgcnVudGltZSksIGFuZCB0aGVuIGZpbmRcXG4gICAqIHRoZSBib3VuZGluZyBib3ggYXJvdW5kIHRoZSBwb2ludHMuICovXFxuICB2ZXJ0aWNlcy5zb3J0KGJ5WCk7XFxuXFxuICB2YXIgaSAgICA9IHZlcnRpY2VzLmxlbmd0aCAtIDEsXFxuICAgICAgeG1pbiA9IHZlcnRpY2VzW2ldLngsXFxuICAgICAgeG1heCA9IHZlcnRpY2VzWzBdLngsXFxuICAgICAgeW1pbiA9IHZlcnRpY2VzW2ldLnksXFxuICAgICAgeW1heCA9IHltaW47XFxuXFxuICB3aGlsZShpLS0pIHtcXG4gICAgaWYodmVydGljZXNbaV0ueSA8IHltaW4pIHsgeW1pbiA9IHZlcnRpY2VzW2ldLnk7IH1cXG4gICAgaWYodmVydGljZXNbaV0ueSA+IHltYXgpIHsgeW1heCA9IHZlcnRpY2VzW2ldLnk7IH1cXG4gIH1cXG5cXG4gIC8qIEZpbmQgYSBzdXBlcnRyaWFuZ2xlLCB3aGljaCBpcyBhIHRyaWFuZ2xlIHRoYXQgc3Vycm91bmRzIGFsbCB0aGVcXG4gICAqIHZlcnRpY2VzLiBUaGlzIGlzIHVzZWQgbGlrZSBzb21ldGhpbmcgb2YgYSBzZW50aW5lbCB2YWx1ZSB0byByZW1vdmVcXG4gICAqIGNhc2VzIGluIHRoZSBtYWluIGFsZ29yaXRobSwgYW5kIGlzIHJlbW92ZWQgYmVmb3JlIHdlIHJldHVybiBhbnlcXG4gICAqIHJlc3VsdHMuXFxuICAgKlxcbiAgICogT25jZSBmb3VuZCwgcHV0IGl0IGluIHRoZSBcXFwib3BlblxcXCIgbGlzdC4gKFRoZSBcXFwib3BlblxcXCIgbGlzdCBpcyBmb3JcXG4gICAqIHRyaWFuZ2xlcyB3aG8gbWF5IHN0aWxsIG5lZWQgdG8gYmUgY29uc2lkZXJlZDsgdGhlIFxcXCJjbG9zZWRcXFwiIGxpc3QgaXNcXG4gICAqIGZvciB0cmlhbmdsZXMgd2hpY2ggZG8gbm90LikgKi9cXG4gIHZhciBkeCAgICAgPSB4bWF4IC0geG1pbixcXG4gICAgICBkeSAgICAgPSB5bWF4IC0geW1pbixcXG4gICAgICBkbWF4ICAgPSAoZHggPiBkeSkgPyBkeCA6IGR5LFxcbiAgICAgIHhtaWQgICA9ICh4bWF4ICsgeG1pbikgKiAwLjUsXFxuICAgICAgeW1pZCAgID0gKHltYXggKyB5bWluKSAqIDAuNSxcXG4gICAgICBvcGVuICAgPSBbXFxuICAgICAgICBuZXcgVHJpYW5nbGUoXFxuICAgICAgICAgIHt4OiB4bWlkIC0gMjAgKiBkbWF4LCB5OiB5bWlkIC0gICAgICBkbWF4LCBfX3NlbnRpbmVsOiB0cnVlfSxcXG4gICAgICAgICAge3g6IHhtaWQgICAgICAgICAgICAsIHk6IHltaWQgKyAyMCAqIGRtYXgsIF9fc2VudGluZWw6IHRydWV9LFxcbiAgICAgICAgICB7eDogeG1pZCArIDIwICogZG1heCwgeTogeW1pZCAtICAgICAgZG1heCwgX19zZW50aW5lbDogdHJ1ZX1cXG4gICAgICAgIClcXG4gICAgICBdLFxcbiAgICAgIGNsb3NlZCA9IFtdLFxcbiAgICAgIGVkZ2VzID0gW10sXFxuICAgICAgaiwgYSwgYjtcXG5cXG4gIC8qIEluY3JlbWVudGFsbHkgYWRkIGVhY2ggdmVydGV4IHRvIHRoZSBtZXNoLiAqL1xcbiAgaSA9IHZlcnRpY2VzLmxlbmd0aDtcXG4gIHdoaWxlKGktLSkge1xcbiAgICAvKiBGb3IgZWFjaCBvcGVuIHRyaWFuZ2xlLCBjaGVjayB0byBzZWUgaWYgdGhlIGN1cnJlbnQgcG9pbnQgaXNcXG4gICAgICogaW5zaWRlIGl0J3MgY2lyY3VtY2lyY2xlLiBJZiBpdCBpcywgcmVtb3ZlIHRoZSB0cmlhbmdsZSBhbmQgYWRkXFxuICAgICAqIGl0J3MgZWRnZXMgdG8gYW4gZWRnZSBsaXN0LiAqL1xcbiAgICBlZGdlcy5sZW5ndGggPSAwO1xcbiAgICBqID0gb3Blbi5sZW5ndGg7XFxuICAgIHdoaWxlKGotLSkge1xcbiAgICAgIC8qIElmIHRoaXMgcG9pbnQgaXMgdG8gdGhlIHJpZ2h0IG9mIHRoaXMgdHJpYW5nbGUncyBjaXJjdW1jaXJjbGUsXFxuICAgICAgICogdGhlbiB0aGlzIHRyaWFuZ2xlIHNob3VsZCBuZXZlciBnZXQgY2hlY2tlZCBhZ2Fpbi4gUmVtb3ZlIGl0XFxuICAgICAgICogZnJvbSB0aGUgb3BlbiBsaXN0LCBhZGQgaXQgdG8gdGhlIGNsb3NlZCBsaXN0LCBhbmQgc2tpcC4gKi9cXG4gICAgICBkeCA9IHZlcnRpY2VzW2ldLnggLSBvcGVuW2pdLng7XFxuICAgICAgaWYoZHggPiAwICYmIGR4ICogZHggPiBvcGVuW2pdLnIpIHtcXG4gICAgICAgIGNsb3NlZC5wdXNoKG9wZW5bal0pO1xcbiAgICAgICAgb3Blbi5zcGxpY2UoaiwgMSk7XFxuICAgICAgICBjb250aW51ZVxcbiAgICAgIH1cXG5cXG4gICAgICAvKiBJZiBub3QsIHNraXAgdGhpcyB0cmlhbmdsZS4gKi9cXG4gICAgICBkeSA9IHZlcnRpY2VzW2ldLnkgLSBvcGVuW2pdLnk7XFxuICAgICAgaWYoZHggKiBkeCArIGR5ICogZHkgPiBvcGVuW2pdLnIpXFxuICAgICAgICB7IGNvbnRpbnVlIH1cXG5cXG4gICAgICAvKiBSZW1vdmUgdGhlIHRyaWFuZ2xlIGFuZCBhZGQgaXQncyBlZGdlcyB0byB0aGUgZWRnZSBsaXN0LiAqL1xcbiAgICAgIGVkZ2VzLnB1c2goXFxuICAgICAgICBvcGVuW2pdLmEsIG9wZW5bal0uYixcXG4gICAgICAgIG9wZW5bal0uYiwgb3BlbltqXS5jLFxcbiAgICAgICAgb3BlbltqXS5jLCBvcGVuW2pdLmFcXG4gICAgICApO1xcbiAgICAgIG9wZW4uc3BsaWNlKGosIDEpO1xcbiAgICB9XFxuXFxuICAgIC8qIFJlbW92ZSBhbnkgZG91YmxlZCBlZGdlcy4gKi9cXG4gICAgZGVkdXAoZWRnZXMpO1xcblxcbiAgICAvKiBBZGQgYSBuZXcgdHJpYW5nbGUgZm9yIGVhY2ggZWRnZS4gKi9cXG4gICAgaiA9IGVkZ2VzLmxlbmd0aDtcXG4gICAgd2hpbGUoaikge1xcbiAgICAgIGIgPSBlZGdlc1stLWpdO1xcbiAgICAgIGEgPSBlZGdlc1stLWpdO1xcbiAgICAgIG9wZW4ucHVzaChuZXcgVHJpYW5nbGUoYSwgYiwgdmVydGljZXNbaV0pKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLyogQ29weSBhbnkgcmVtYWluaW5nIG9wZW4gdHJpYW5nbGVzIHRvIHRoZSBjbG9zZWQgbGlzdCwgYW5kIHRoZW5cXG4gICAqIHJlbW92ZSBhbnkgdHJpYW5nbGVzIHRoYXQgc2hhcmUgYSB2ZXJ0ZXggd2l0aCB0aGUgc3VwZXJ0cmlhbmdsZS4gKi9cXG4gIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGNsb3NlZCwgb3Blbik7XFxuXFxuICBpID0gY2xvc2VkLmxlbmd0aDtcXG4gIHdoaWxlKGktLSlcXG4gICAgeyBpZihjbG9zZWRbaV0uYS5fX3NlbnRpbmVsIHx8XFxuICAgICAgIGNsb3NlZFtpXS5iLl9fc2VudGluZWwgfHxcXG4gICAgICAgY2xvc2VkW2ldLmMuX19zZW50aW5lbClcXG4gICAgICB7IGNsb3NlZC5zcGxpY2UoaSwgMSk7IH0gfVxcblxcbiAgLyogWWF5LCB3ZSdyZSBkb25lISAqL1xcbiAgcmV0dXJuIGNsb3NlZFxcbn1cXG5cXG57XFxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xcbiAgICAgICAgVHJpYW5nbGU6IFRyaWFuZ2xlLFxcbiAgICAgICAgdHJpYW5ndWxhdGU6IHRyaWFuZ3VsYXRlXFxuICAgIH07XFxufVxcbn0pO1xcbnZhciBkZWxhdW5heV8xID0gZGVsYXVuYXkuVHJpYW5nbGU7XFxudmFyIGRlbGF1bmF5XzIgPSBkZWxhdW5heS50cmlhbmd1bGF0ZTtcXG5cXG52YXIgc29iZWwgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XFxuKGZ1bmN0aW9uKHJvb3QpIHtcXG5cXG4gIGZ1bmN0aW9uIFNvYmVsKGltYWdlRGF0YSkge1xcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29iZWwpKSB7XFxuICAgICAgcmV0dXJuIG5ldyBTb2JlbChpbWFnZURhdGEpO1xcbiAgICB9XFxuXFxuICAgIHZhciB3aWR0aCA9IGltYWdlRGF0YS53aWR0aDtcXG4gICAgdmFyIGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQ7XFxuXFxuICAgIHZhciBrZXJuZWxYID0gW1xcbiAgICAgIFstMSwwLDFdLFxcbiAgICAgIFstMiwwLDJdLFxcbiAgICAgIFstMSwwLDFdXFxuICAgIF07XFxuXFxuICAgIHZhciBrZXJuZWxZID0gW1xcbiAgICAgIFstMSwtMiwtMV0sXFxuICAgICAgWzAsMCwwXSxcXG4gICAgICBbMSwyLDFdXFxuICAgIF07XFxuXFxuICAgIHZhciBzb2JlbERhdGEgPSBbXTtcXG4gICAgdmFyIGdyYXlzY2FsZURhdGEgPSBbXTtcXG5cXG4gICAgZnVuY3Rpb24gYmluZFBpeGVsQXQoZGF0YSkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbih4LCB5LCBpKSB7XFxuICAgICAgICBpID0gaSB8fCAwO1xcbiAgICAgICAgcmV0dXJuIGRhdGFbKCh3aWR0aCAqIHkpICsgeCkgKiA0ICsgaV07XFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xcbiAgICB2YXIgcGl4ZWxBdCA9IGJpbmRQaXhlbEF0KGRhdGEpO1xcbiAgICB2YXIgeCwgeTtcXG5cXG4gICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XFxuICAgICAgZm9yICh4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcXG4gICAgICAgIHZhciByID0gcGl4ZWxBdCh4LCB5LCAwKTtcXG4gICAgICAgIHZhciBnID0gcGl4ZWxBdCh4LCB5LCAxKTtcXG4gICAgICAgIHZhciBiID0gcGl4ZWxBdCh4LCB5LCAyKTtcXG5cXG4gICAgICAgIHZhciBhdmcgPSAociArIGcgKyBiKSAvIDM7XFxuICAgICAgICBncmF5c2NhbGVEYXRhLnB1c2goYXZnLCBhdmcsIGF2ZywgMjU1KTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcGl4ZWxBdCA9IGJpbmRQaXhlbEF0KGdyYXlzY2FsZURhdGEpO1xcblxcbiAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcXG4gICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xcbiAgICAgICAgdmFyIHBpeGVsWCA9IChcXG4gICAgICAgICAgICAoa2VybmVsWFswXVswXSAqIHBpeGVsQXQoeCAtIDEsIHkgLSAxKSkgK1xcbiAgICAgICAgICAgIChrZXJuZWxYWzBdWzFdICogcGl4ZWxBdCh4LCB5IC0gMSkpICtcXG4gICAgICAgICAgICAoa2VybmVsWFswXVsyXSAqIHBpeGVsQXQoeCArIDEsIHkgLSAxKSkgK1xcbiAgICAgICAgICAgIChrZXJuZWxYWzFdWzBdICogcGl4ZWxBdCh4IC0gMSwgeSkpICtcXG4gICAgICAgICAgICAoa2VybmVsWFsxXVsxXSAqIHBpeGVsQXQoeCwgeSkpICtcXG4gICAgICAgICAgICAoa2VybmVsWFsxXVsyXSAqIHBpeGVsQXQoeCArIDEsIHkpKSArXFxuICAgICAgICAgICAgKGtlcm5lbFhbMl1bMF0gKiBwaXhlbEF0KHggLSAxLCB5ICsgMSkpICtcXG4gICAgICAgICAgICAoa2VybmVsWFsyXVsxXSAqIHBpeGVsQXQoeCwgeSArIDEpKSArXFxuICAgICAgICAgICAgKGtlcm5lbFhbMl1bMl0gKiBwaXhlbEF0KHggKyAxLCB5ICsgMSkpXFxuICAgICAgICApO1xcblxcbiAgICAgICAgdmFyIHBpeGVsWSA9IChcXG4gICAgICAgICAgKGtlcm5lbFlbMF1bMF0gKiBwaXhlbEF0KHggLSAxLCB5IC0gMSkpICtcXG4gICAgICAgICAgKGtlcm5lbFlbMF1bMV0gKiBwaXhlbEF0KHgsIHkgLSAxKSkgK1xcbiAgICAgICAgICAoa2VybmVsWVswXVsyXSAqIHBpeGVsQXQoeCArIDEsIHkgLSAxKSkgK1xcbiAgICAgICAgICAoa2VybmVsWVsxXVswXSAqIHBpeGVsQXQoeCAtIDEsIHkpKSArXFxuICAgICAgICAgIChrZXJuZWxZWzFdWzFdICogcGl4ZWxBdCh4LCB5KSkgK1xcbiAgICAgICAgICAoa2VybmVsWVsxXVsyXSAqIHBpeGVsQXQoeCArIDEsIHkpKSArXFxuICAgICAgICAgIChrZXJuZWxZWzJdWzBdICogcGl4ZWxBdCh4IC0gMSwgeSArIDEpKSArXFxuICAgICAgICAgIChrZXJuZWxZWzJdWzFdICogcGl4ZWxBdCh4LCB5ICsgMSkpICtcXG4gICAgICAgICAgKGtlcm5lbFlbMl1bMl0gKiBwaXhlbEF0KHggKyAxLCB5ICsgMSkpXFxuICAgICAgICApO1xcblxcbiAgICAgICAgdmFyIG1hZ25pdHVkZSA9IE1hdGguc3FydCgocGl4ZWxYICogcGl4ZWxYKSArIChwaXhlbFkgKiBwaXhlbFkpKT4+PjA7XFxuXFxuICAgICAgICBzb2JlbERhdGEucHVzaChtYWduaXR1ZGUsIG1hZ25pdHVkZSwgbWFnbml0dWRlLCAyNTUpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB2YXIgY2xhbXBlZEFycmF5ID0gc29iZWxEYXRhO1xcblxcbiAgICBpZiAodHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgY2xhbXBlZEFycmF5ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHNvYmVsRGF0YSk7XFxuICAgIH1cXG5cXG4gICAgY2xhbXBlZEFycmF5LnRvSW1hZ2VEYXRhID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIFNvYmVsLnRvSW1hZ2VEYXRhKGNsYW1wZWRBcnJheSwgd2lkdGgsIGhlaWdodCk7XFxuICAgIH07XFxuXFxuICAgIHJldHVybiBjbGFtcGVkQXJyYXk7XFxuICB9XFxuXFxuICBTb2JlbC50b0ltYWdlRGF0YSA9IGZ1bmN0aW9uIHRvSW1hZ2VEYXRhKGRhdGEsIHdpZHRoLCBoZWlnaHQpIHtcXG4gICAgaWYgKHR5cGVvZiBJbWFnZURhdGEgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBVaW50MTZBcnJheV0nKSB7XFxuICAgICAgcmV0dXJuIG5ldyBJbWFnZURhdGEoZGF0YSwgd2lkdGgsIGhlaWdodCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGNhbnZhcy5nZXRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XFxuICAgICAgICAgIHZhciBpbWFnZURhdGEgPSBjb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcXG4gICAgICAgICAgaW1hZ2VEYXRhLmRhdGEuc2V0KGRhdGEpO1xcbiAgICAgICAgICByZXR1cm4gaW1hZ2VEYXRhO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmV0dXJuIG5ldyBGYWtlSW1hZ2VEYXRhKGRhdGEsIHdpZHRoLCBoZWlnaHQpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gbmV3IEZha2VJbWFnZURhdGEoZGF0YSwgd2lkdGgsIGhlaWdodCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gRmFrZUltYWdlRGF0YShkYXRhLCB3aWR0aCwgaGVpZ2h0KSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgd2lkdGg6IHdpZHRoLFxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxcbiAgICAgIGRhdGE6IGRhdGFcXG4gICAgfTtcXG4gIH1cXG5cXG4gIHtcXG4gICAgaWYgKG1vZHVsZS5leHBvcnRzKSB7XFxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU29iZWw7XFxuICAgIH1cXG4gICAgZXhwb3J0cy5Tb2JlbCA9IFNvYmVsO1xcbiAgfVxcblxcbn0pKGNvbW1vbmpzR2xvYmFsKTtcXG59KTtcXG52YXIgc29iZWxfMSA9IHNvYmVsLlNvYmVsO1xcblxcbmZ1bmN0aW9uIGlzSW1hZ2VEYXRhIChpbWFnZURhdGEpIHtcXG5cXHRyZXR1cm4gKFxcblxcdFxcdGltYWdlRGF0YSAmJiBcXG5cXHRcXHR0eXBlb2YgaW1hZ2VEYXRhLndpZHRoID09PSAnbnVtYmVyJyAmJlxcblxcdFxcdHR5cGVvZiBpbWFnZURhdGEuaGVpZ2h0ID09PSAnbnVtYmVyJyAmJlxcblxcdFxcdGltYWdlRGF0YS5kYXRhICYmXFxuXFx0XFx0dHlwZW9mIGltYWdlRGF0YS5kYXRhLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcXG5cXHRcXHR0eXBlb2YgaW1hZ2VEYXRhLmRhdGEgPT09ICdvYmplY3QnXFxuXFx0KTtcXG59XFxuXFxudmFyIENhbnZhcyA9IGZ1bmN0aW9uIENhbnZhcyAoIHdpZHRoLCBoZWlnaHQgKSB7XFxuXFx0aWYgKCB3aWR0aCA9PT0gdm9pZCAwICkgd2lkdGggPSAzMDA7XFxuXFx0aWYgKCBoZWlnaHQgPT09IHZvaWQgMCApIGhlaWdodCA9IDE1MDtcXG5cXG5cXHRpZiAoIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnICkge1xcblxcdFxcdHRoaXMuY2FudmFzRWwgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcXG5cXHRcXHR0aGlzLmN0eCA9IG51bGw7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHR0aGlzLmNhbnZhc0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcXG5cXHRcXHR0aGlzLmNhbnZhc0VsLndpZHRoID0gd2lkdGg7XFxuXFx0XFx0dGhpcy5jYW52YXNFbC5oZWlnaHQgPSBoZWlnaHQ7XFxuXFx0XFx0dGhpcy5jdHggPSB0aGlzLmNhbnZhc0VsLmdldENvbnRleHQoICcyZCcgKTtcXG5cXHR9IFxcbn07XFxuXFxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgd2lkdGg6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saGVpZ2h0OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XFxuXFxuQ2FudmFzLnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q29udGV4dCAoKSB7XFxuXFx0cmV0dXJuIHRoaXMuY3R4O1xcbn07XFxuXFxuQ2FudmFzLnByb3RvdHlwZS50b0RhdGFVUkwgPSBmdW5jdGlvbiB0b0RhdGFVUkwgKCB0eXBlLCBlbmNvZGVyT3B0aW9ucywgY2IgKSB7XFxuXFx0aWYgKCB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicgKSB7XFxuXFx0XFx0Y2IoIHRoaXMuY2FudmFzRWwudG9EYXRhVVJMKCB0eXBlLCBlbmNvZGVyT3B0aW9ucyApICk7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5jYW52YXNFbC50b0RhdGFVUkwoIHR5cGUsIGVuY29kZXJPcHRpb25zICk7XFxuXFx0fVxcbn07XFxuXFx0XFxucHJvdG90eXBlQWNjZXNzb3JzLndpZHRoLmdldCA9IGZ1bmN0aW9uICgpIHtcXG5cXHRyZXR1cm4gdGhpcy5jYW52YXNFbC53aWR0aDtcXG59O1xcblxcdFxcbnByb3RvdHlwZUFjY2Vzc29ycy53aWR0aC5zZXQgPSBmdW5jdGlvbiAoIG5ld1dpZHRoICkge1xcblxcdHRoaXMuY2FudmFzRWwud2lkdGggPSBuZXdXaWR0aDtcXG59O1xcblxcbnByb3RvdHlwZUFjY2Vzc29ycy5oZWlnaHQuZ2V0ID0gZnVuY3Rpb24gKCkge1xcblxcdHJldHVybiB0aGlzLmNhbnZhc0VsLmhlaWdodDtcXG59O1xcblxcbnByb3RvdHlwZUFjY2Vzc29ycy5oZWlnaHQuc2V0ID0gZnVuY3Rpb24gKCBuZXdIZWlnaHQgKSB7XFxuXFx0dGhpcy5jYW52YXNFbC5oZWlnaHQgPSBuZXdIZWlnaHQ7XFxufTtcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQ2FudmFzLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XFxuXFxuaWYgKCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyApIHtcXG5cXHRDYW52YXMuSW1hZ2UgPSBJbWFnZTtcXG59XFxuXFxuLy8gaW1wb3J0IENhbnZhcyBmcm9tICdjYW52YXMnO1xcblxcbmZ1bmN0aW9uIGNvcHlJbWFnZURhdGEgKGltYWdlRGF0YSkge1xcblxcdGlmICggaXNJbWFnZURhdGEgKCBpbWFnZURhdGEgKSApIHtcXG5cXHRcXHRpZiAoIHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgKSB7XFxuXFx0XFx0XFx0aWYgKCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyApIHtcXG5cXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoIFxcXCJDYW4ndCBjb3B5IGltYWdlRGF0YSBpbiB3ZWJ3b3JrZXIgd2l0aG91dCBVaW50OENsYW1wZWRBcnJheSBzdXBwb3J0LlxcXCIgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gaW1hZ2VEYXRhO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNvcHlJbWFnZURhdGFXaXRoQ2FudmFzKCBpbWFnZURhdGEgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR2YXIgY2xhbXBlZEFycmF5ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KCBpbWFnZURhdGEuZGF0YSApO1xcblxcblxcdFxcdFxcdGlmICggdHlwZW9mIEltYWdlRGF0YSA9PT0gJ3VuZGVmaW5lZCcgKSB7XFxuXFx0XFx0XFx0XFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTUyMzgwMzYvMjI5MTg5XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHRcXHR3aWR0aDogaW1hZ2VEYXRhLndpZHRoLFxcblxcdFxcdFxcdFxcdFxcdGhlaWdodDogaW1hZ2VEYXRhLmhlaWdodCxcXG5cXHRcXHRcXHRcXHRcXHRkYXRhOiBjbGFtcGVkQXJyYXlcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTU5MDg5MjIvMjI5MTg5I2NvbW1lbnQ1NzE5MjU5MV8xNTkwODkyMlxcblxcdFxcdFxcdFxcdHZhciByZXN1bHQ7XFxuXFxuXFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRyZXN1bHQgPSBuZXcgSW1hZ2VEYXRhKCBjbGFtcGVkQXJyYXksIGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCApO1xcblxcdFxcdFxcdFxcdH0gY2F0Y2ggKCBlcnIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoIFxcXCJDYW4ndCBjb3B5IGltYWdlRGF0YSBpbiB3ZWJ3b3JrZXIgd2l0aG91dCBwcm9wZXIgSW1hZ2VEYXRhKCkgc3VwcG9ydC5cXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVzdWx0ID0gaW1hZ2VEYXRhO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVzdWx0ID0gY29weUltYWdlRGF0YVdpdGhDYW52YXMoIGltYWdlRGF0YSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0gZWxzZSB7XFxuXFx0XFx0dGhyb3cgbmV3IEVycm9yKCAnR2l2ZW4gaW1hZ2VEYXRhIG9iamVjdCBpcyBub3QgdXNlYWJsZS4nICk7XFxuXFx0XFx0cmV0dXJuO1xcblxcdH1cXG59XFxuXFxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTE5MTgxMjYvMjI5MTg5XFxuZnVuY3Rpb24gY29weUltYWdlRGF0YVdpdGhDYW52YXMgKCBpbWFnZURhdGEgKSB7XFxuXFx0dmFyIGNhbnZhcyA9IG5ldyBDYW52YXMoIGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCApO1xcblxcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xcblxcblxcdGN0eC5wdXRJbWFnZURhdGEoIGltYWdlRGF0YSwgMCwgMCApO1xcblxcdFxcdFxcdFxcdFxcblxcdHJldHVybiBjdHguZ2V0SW1hZ2VEYXRhKCAwLCAwLCBpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQgKTtcXG59XFxuXFxuLypcXG4gICAgU3RhY2tCbHVyIC0gYSBmYXN0IGFsbW9zdCBHYXVzc2lhbiBCbHVyIEZvciBDYW52YXNcXG5cXG4gICAgVmVyc2lvbjogICAgIDAuNVxcbiAgICBBdXRob3I6ICAgICAgICBNYXJpbyBLbGluZ2VtYW5uXFxuICAgIENvbnRhY3Q6ICAgICBtYXJpb0BxdWFzaW1vbmRvLmNvbVxcbiAgICBXZWJzaXRlOiAgICBodHRwOi8vd3d3LnF1YXNpbW9uZG8uY29tL1N0YWNrQmx1ckZvckNhbnZhc1xcbiAgICBUd2l0dGVyOiAgICBAcXVhc2ltb25kb1xcblxcbiAgICBJbiBjYXNlIHlvdSBmaW5kIHRoaXMgY2xhc3MgdXNlZnVsIC0gZXNwZWNpYWxseSBpbiBjb21tZXJjaWFsIHByb2plY3RzIC1cXG4gICAgSSBhbSBub3QgdG90YWxseSB1bmhhcHB5IGZvciBhIHNtYWxsIGRvbmF0aW9uIHRvIG15IFBheVBhbCBhY2NvdW50XFxuICAgIG1hcmlvQHF1YXNpbW9uZG8uZGVcXG5cXG4gICAgT3Igc3VwcG9ydCBtZSBvbiBmbGF0dHI6XFxuICAgIGh0dHBzOi8vZmxhdHRyLmNvbS90aGluZy83Mjc5MS9TdGFja0JsdXItYS1mYXN0LWFsbW9zdC1HYXVzc2lhbi1CbHVyLUVmZmVjdC1mb3ItQ2FudmFzSmF2YXNjcmlwdFxcblxcbiAgICBDb3B5cmlnaHQgKGMpIDIwMTAgTWFyaW8gS2xpbmdlbWFublxcblxcbiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxcbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxcbiAgICBmaWxlcyAodGhlIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XFxuICAgIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxcbiAgICBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxcbiAgICBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcXG4gICAgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcXG4gICAgY29uZGl0aW9uczpcXG5cXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcXG4gICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuXFxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxcbiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcXG4gICAgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcXG4gICAgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXFxuICAgIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xcbiAgICBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXFxuICAgIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG4gICAgKi9cXG5cXG52YXIgbXVsX3RhYmxlID0gW1xcbiAgICA1MTIsNTEyLDQ1Niw1MTIsMzI4LDQ1NiwzMzUsNTEyLDQwNSwzMjgsMjcxLDQ1NiwzODgsMzM1LDI5Miw1MTIsXFxuICAgIDQ1NCw0MDUsMzY0LDMyOCwyOTgsMjcxLDQ5Niw0NTYsNDIwLDM4OCwzNjAsMzM1LDMxMiwyOTIsMjczLDUxMixcXG4gICAgNDgyLDQ1NCw0MjgsNDA1LDM4MywzNjQsMzQ1LDMyOCwzMTIsMjk4LDI4NCwyNzEsMjU5LDQ5Niw0NzUsNDU2LFxcbiAgICA0MzcsNDIwLDQwNCwzODgsMzc0LDM2MCwzNDcsMzM1LDMyMywzMTIsMzAyLDI5MiwyODIsMjczLDI2NSw1MTIsXFxuICAgIDQ5Nyw0ODIsNDY4LDQ1NCw0NDEsNDI4LDQxNyw0MDUsMzk0LDM4MywzNzMsMzY0LDM1NCwzNDUsMzM3LDMyOCxcXG4gICAgMzIwLDMxMiwzMDUsMjk4LDI5MSwyODQsMjc4LDI3MSwyNjUsMjU5LDUwNyw0OTYsNDg1LDQ3NSw0NjUsNDU2LFxcbiAgICA0NDYsNDM3LDQyOCw0MjAsNDEyLDQwNCwzOTYsMzg4LDM4MSwzNzQsMzY3LDM2MCwzNTQsMzQ3LDM0MSwzMzUsXFxuICAgIDMyOSwzMjMsMzE4LDMxMiwzMDcsMzAyLDI5NywyOTIsMjg3LDI4MiwyNzgsMjczLDI2OSwyNjUsMjYxLDUxMixcXG4gICAgNTA1LDQ5Nyw0ODksNDgyLDQ3NSw0NjgsNDYxLDQ1NCw0NDcsNDQxLDQzNSw0MjgsNDIyLDQxNyw0MTEsNDA1LFxcbiAgICAzOTksMzk0LDM4OSwzODMsMzc4LDM3MywzNjgsMzY0LDM1OSwzNTQsMzUwLDM0NSwzNDEsMzM3LDMzMiwzMjgsXFxuICAgIDMyNCwzMjAsMzE2LDMxMiwzMDksMzA1LDMwMSwyOTgsMjk0LDI5MSwyODcsMjg0LDI4MSwyNzgsMjc0LDI3MSxcXG4gICAgMjY4LDI2NSwyNjIsMjU5LDI1Nyw1MDcsNTAxLDQ5Niw0OTEsNDg1LDQ4MCw0NzUsNDcwLDQ2NSw0NjAsNDU2LFxcbiAgICA0NTEsNDQ2LDQ0Miw0MzcsNDMzLDQyOCw0MjQsNDIwLDQxNiw0MTIsNDA4LDQwNCw0MDAsMzk2LDM5MiwzODgsXFxuICAgIDM4NSwzODEsMzc3LDM3NCwzNzAsMzY3LDM2MywzNjAsMzU3LDM1NCwzNTAsMzQ3LDM0NCwzNDEsMzM4LDMzNSxcXG4gICAgMzMyLDMyOSwzMjYsMzIzLDMyMCwzMTgsMzE1LDMxMiwzMTAsMzA3LDMwNCwzMDIsMjk5LDI5NywyOTQsMjkyLFxcbiAgICAyODksMjg3LDI4NSwyODIsMjgwLDI3OCwyNzUsMjczLDI3MSwyNjksMjY3LDI2NSwyNjMsMjYxLDI1OV07XFxuXFxuXFxudmFyIHNoZ190YWJsZSA9IFtcXG4gICAgOSwgMTEsIDEyLCAxMywgMTMsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDE2LCAxNyxcXG4gICAgMTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTksXFxuICAgIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLFxcbiAgICAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMSxcXG4gICAgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsXFxuICAgIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLFxcbiAgICAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMixcXG4gICAgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjMsXFxuICAgIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLFxcbiAgICAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMyxcXG4gICAgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsXFxuICAgIDIzLCAyMywgMjMsIDIzLCAyMywgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxcbiAgICAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcXG4gICAgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsXFxuICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxcbiAgICAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0IF07XFxuXFxuZnVuY3Rpb24gQmx1clN0YWNrICgpIHtcXG5cXHR0aGlzLnIgPSAwO1xcblxcdHRoaXMuZyA9IDA7XFxuXFx0dGhpcy5iID0gMDtcXG5cXHR0aGlzLmEgPSAwO1xcblxcdHRoaXMubmV4dCA9IG51bGw7XFxufVxcblxcbmZ1bmN0aW9uIHN0YWNrYmx1ciAoIGltYWdlRGF0YSwgdG9wX3gsIHRvcF95LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMgKSB7XFxuXFx0dmFyIHBpeGVscyA9IGltYWdlRGF0YS5kYXRhO1xcblxcblxcdHZhciB4LCB5LCBpLCBwLCB5cCwgeWksIHl3LCByX3N1bSwgZ19zdW0sIGJfc3VtLCBhX3N1bSxcXG5cXHRcXHRyX291dF9zdW0sIGdfb3V0X3N1bSwgYl9vdXRfc3VtLCBhX291dF9zdW0sXFxuXFx0XFx0cl9pbl9zdW0sIGdfaW5fc3VtLCBiX2luX3N1bSwgYV9pbl9zdW0sXFxuXFx0XFx0cHIsIHBnLCBwYiwgcGEsIHJicztcXG5cXG5cXHR2YXIgZGl2ID0gcmFkaXVzICsgcmFkaXVzICsgMTtcXG5cXHR2YXIgd2lkdGhNaW51czEgID0gd2lkdGggLSAxO1xcblxcdHZhciBoZWlnaHRNaW51czEgPSBoZWlnaHQgLSAxO1xcblxcdHZhciByYWRpdXNQbHVzMSAgPSByYWRpdXMgKyAxO1xcblxcdHZhciBzdW1GYWN0b3IgPSByYWRpdXNQbHVzMSAqICggcmFkaXVzUGx1czEgKyAxICkgLyAyO1xcblxcblxcdHZhciBzdGFja1N0YXJ0ID0gbmV3IEJsdXJTdGFjaygpO1xcblxcdHZhciBzdGFjayA9IHN0YWNrU3RhcnQ7XFxuXFx0XFxuXFx0Zm9yICggaSA9IDE7IGkgPCBkaXY7IGkrKyApIHtcXG5cXHRcXHRzdGFjayA9IHN0YWNrLm5leHQgPSBuZXcgQmx1clN0YWNrKCk7XFxuXFx0XFx0aWYgKGkgPT0gcmFkaXVzUGx1czEpIHsgdmFyIHN0YWNrRW5kID0gc3RhY2s7IH1cXG5cXHR9XFxuXFx0c3RhY2submV4dCA9IHN0YWNrU3RhcnQ7XFxuXFx0XFxuXFx0dmFyIHN0YWNrSW4gPSBudWxsO1xcblxcdHZhciBzdGFja091dCA9IG51bGw7XFxuXFxuXFx0eXcgPSB5aSA9IDA7XFxuXFxuXFx0dmFyIG11bF9zdW0gPSBtdWxfdGFibGVbcmFkaXVzXTtcXG5cXHR2YXIgc2hnX3N1bSA9IHNoZ190YWJsZVtyYWRpdXNdO1xcblxcblxcdGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KysgKSB7XFxuXFx0XFx0cl9pbl9zdW0gPSBnX2luX3N1bSA9IGJfaW5fc3VtID0gYV9pbl9zdW0gPSByX3N1bSA9IGdfc3VtID0gYl9zdW0gPSBhX3N1bSA9IDA7XFxuXFxuXFx0XFx0cl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHByID0gcGl4ZWxzW3lpXSApO1xcblxcdFxcdGdfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwZyA9IHBpeGVsc1t5aSsxXSApO1xcblxcdFxcdGJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwYiA9IHBpeGVsc1t5aSsyXSApO1xcblxcdFxcdGFfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwYSA9IHBpeGVsc1t5aSszXSApO1xcblxcblxcdFxcdHJfc3VtICs9IHN1bUZhY3RvciAqIHByO1xcblxcdFxcdGdfc3VtICs9IHN1bUZhY3RvciAqIHBnO1xcblxcdFxcdGJfc3VtICs9IHN1bUZhY3RvciAqIHBiO1xcblxcdFxcdGFfc3VtICs9IHN1bUZhY3RvciAqIHBhO1xcblxcblxcdFxcdHN0YWNrID0gc3RhY2tTdGFydDtcXG5cXG5cXHRcXHRmb3IgKCBpID0gMDsgaSA8IHJhZGl1c1BsdXMxOyBpKysgKSB7XFxuXFx0XFx0XFx0c3RhY2suciA9IHByO1xcblxcdFxcdFxcdHN0YWNrLmcgPSBwZztcXG5cXHRcXHRcXHRzdGFjay5iID0gcGI7XFxuXFx0XFx0XFx0c3RhY2suYSA9IHBhO1xcblxcdFxcdFxcdHN0YWNrID0gc3RhY2submV4dDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Zm9yICggaSA9IDE7IGkgPCByYWRpdXNQbHVzMTsgaSsrICkge1xcblxcdFxcdFxcdHAgPSB5aSArICggKCB3aWR0aE1pbnVzMSA8IGkgPyB3aWR0aE1pbnVzMSA6IGkgKSA8PCAyICk7XFxuXFx0XFx0XFx0cl9zdW0gKz0gKCBzdGFjay5yID0gKCBwciA9IHBpeGVsc1twXSApICkgKiAoIHJicyA9IHJhZGl1c1BsdXMxIC0gaSApO1xcblxcdFxcdFxcdGdfc3VtICs9ICggc3RhY2suZyA9ICggcGcgPSBwaXhlbHNbcCsxXSApICkgKiByYnM7XFxuXFx0XFx0XFx0Yl9zdW0gKz0gKCBzdGFjay5iID0gKCBwYiA9IHBpeGVsc1twKzJdICkgKSAqIHJicztcXG5cXHRcXHRcXHRhX3N1bSArPSAoIHN0YWNrLmEgPSAoIHBhID0gcGl4ZWxzW3ArM10gKSApICogcmJzO1xcblxcblxcdFxcdFxcdHJfaW5fc3VtICs9IHByO1xcblxcdFxcdFxcdGdfaW5fc3VtICs9IHBnO1xcblxcdFxcdFxcdGJfaW5fc3VtICs9IHBiO1xcblxcdFxcdFxcdGFfaW5fc3VtICs9IHBhO1xcblxcblxcdFxcdFxcdHN0YWNrID0gc3RhY2submV4dDtcXG5cXHRcXHR9XFxuXFxuXFxuXFx0XFx0c3RhY2tJbiA9IHN0YWNrU3RhcnQ7XFxuXFx0XFx0c3RhY2tPdXQgPSBzdGFja0VuZDtcXG5cXG5cXHRcXHRmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xcblxcdFxcdFxcdHBpeGVsc1t5aSszXSA9IHBhID0gKGFfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bTtcXG5cXHRcXHRcXHRcXG5cXHRcXHRcXHRpZiAocGEgIT0gMCkge1xcblxcdFxcdFxcdFxcdHBhID0gMjU1IC8gcGE7XFxuXFx0XFx0XFx0XFx0cGl4ZWxzW3lpXSAgID0gKCAoIHJfc3VtICogbXVsX3N1bSApID4+IHNoZ19zdW0gKSAqIHBhO1xcblxcdFxcdFxcdFxcdHBpeGVsc1t5aSsxXSA9ICggKCBnX3N1bSAqIG11bF9zdW0gKSA+PiBzaGdfc3VtICkgKiBwYTtcXG5cXHRcXHRcXHRcXHRwaXhlbHNbeWkrMl0gPSAoICggYl9zdW0gKiBtdWxfc3VtICkgPj4gc2hnX3N1bSApICogcGE7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRwaXhlbHNbeWldID0gcGl4ZWxzW3lpKzFdID0gcGl4ZWxzW3lpKzJdID0gMDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cl9zdW0gLT0gcl9vdXRfc3VtO1xcblxcdFxcdFxcdGdfc3VtIC09IGdfb3V0X3N1bTtcXG5cXHRcXHRcXHRiX3N1bSAtPSBiX291dF9zdW07XFxuXFx0XFx0XFx0YV9zdW0gLT0gYV9vdXRfc3VtO1xcblxcblxcdFxcdFxcdHJfb3V0X3N1bSAtPSBzdGFja0luLnI7XFxuXFx0XFx0XFx0Z19vdXRfc3VtIC09IHN0YWNrSW4uZztcXG5cXHRcXHRcXHRiX291dF9zdW0gLT0gc3RhY2tJbi5iO1xcblxcdFxcdFxcdGFfb3V0X3N1bSAtPSBzdGFja0luLmE7XFxuXFxuXFx0XFx0XFx0cCA9ICAoIHl3ICsgKCAoIHAgPSB4ICsgcmFkaXVzICsgMSApIDwgd2lkdGhNaW51czEgPyBwIDogd2lkdGhNaW51czEgKSApIDw8IDI7XFxuXFxuXFx0XFx0XFx0cl9pbl9zdW0gKz0gKCBzdGFja0luLnIgPSBwaXhlbHNbcF0gKTtcXG5cXHRcXHRcXHRnX2luX3N1bSArPSAoIHN0YWNrSW4uZyA9IHBpeGVsc1twKzFdICk7XFxuXFx0XFx0XFx0Yl9pbl9zdW0gKz0gKCBzdGFja0luLmIgPSBwaXhlbHNbcCsyXSApO1xcblxcdFxcdFxcdGFfaW5fc3VtICs9ICggc3RhY2tJbi5hID0gcGl4ZWxzW3ArM10gKTtcXG5cXG5cXHRcXHRcXHRyX3N1bSArPSByX2luX3N1bTtcXG5cXHRcXHRcXHRnX3N1bSArPSBnX2luX3N1bTtcXG5cXHRcXHRcXHRiX3N1bSArPSBiX2luX3N1bTtcXG5cXHRcXHRcXHRhX3N1bSArPSBhX2luX3N1bTtcXG5cXG5cXHRcXHRcXHRzdGFja0luID0gc3RhY2tJbi5uZXh0O1xcblxcblxcdFxcdFxcdHJfb3V0X3N1bSArPSAoIHByID0gc3RhY2tPdXQuciApO1xcblxcdFxcdFxcdGdfb3V0X3N1bSArPSAoIHBnID0gc3RhY2tPdXQuZyApO1xcblxcdFxcdFxcdGJfb3V0X3N1bSArPSAoIHBiID0gc3RhY2tPdXQuYiApO1xcblxcdFxcdFxcdGFfb3V0X3N1bSArPSAoIHBhID0gc3RhY2tPdXQuYSApO1xcblxcblxcdFxcdFxcdHJfaW5fc3VtIC09IHByO1xcblxcdFxcdFxcdGdfaW5fc3VtIC09IHBnO1xcblxcdFxcdFxcdGJfaW5fc3VtIC09IHBiO1xcblxcdFxcdFxcdGFfaW5fc3VtIC09IHBhO1xcblxcblxcdFxcdFxcdHN0YWNrT3V0ID0gc3RhY2tPdXQubmV4dDtcXG5cXG5cXHRcXHRcXHR5aSArPSA0O1xcblxcdFxcdH1cXG5cXHRcXHR5dyArPSB3aWR0aDtcXG5cXHR9XFxuXFxuXFxuXFx0Zm9yICggeCA9IDA7IHggPCB3aWR0aDsgeCsrICkge1xcblxcdFxcdGdfaW5fc3VtID0gYl9pbl9zdW0gPSBhX2luX3N1bSA9IHJfaW5fc3VtID0gZ19zdW0gPSBiX3N1bSA9IGFfc3VtID0gcl9zdW0gPSAwO1xcblxcblxcdFxcdHlpID0geCA8PCAyO1xcblxcdFxcdHJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwciA9IHBpeGVsc1t5aV0gKTtcXG5cXHRcXHRnX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGcgPSBwaXhlbHNbeWkrMV0gKTtcXG5cXHRcXHRiX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGIgPSBwaXhlbHNbeWkrMl0gKTtcXG5cXHRcXHRhX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGEgPSBwaXhlbHNbeWkrM10gKTtcXG5cXG5cXHRcXHRyX3N1bSArPSBzdW1GYWN0b3IgKiBwcjtcXG5cXHRcXHRnX3N1bSArPSBzdW1GYWN0b3IgKiBwZztcXG5cXHRcXHRiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcXG5cXHRcXHRhX3N1bSArPSBzdW1GYWN0b3IgKiBwYTtcXG5cXG5cXHRcXHRzdGFjayA9IHN0YWNrU3RhcnQ7XFxuXFxuXFx0XFx0Zm9yICggaSA9IDA7IGkgPCByYWRpdXNQbHVzMTsgaSsrKSB7XFxuXFx0XFx0XFx0c3RhY2suciA9IHByO1xcblxcdFxcdFxcdHN0YWNrLmcgPSBwZztcXG5cXHRcXHRcXHRzdGFjay5iID0gcGI7XFxuXFx0XFx0XFx0c3RhY2suYSA9IHBhO1xcblxcdFxcdFxcdHN0YWNrID0gc3RhY2submV4dDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0eXAgPSB3aWR0aDtcXG5cXG5cXHRcXHRmb3IgKCBpID0gMTsgaSA8PSByYWRpdXM7IGkrKyApIHtcXG5cXHRcXHRcXHR5aSA9ICggeXAgKyB4ICkgPDwgMjtcXG5cXG5cXHRcXHRcXHRyX3N1bSArPSAoIHN0YWNrLnIgPSAoIHByID0gcGl4ZWxzW3lpXSApICkgKiAocmJzID0gcmFkaXVzUGx1czEgLSBpKTtcXG5cXHRcXHRcXHRnX3N1bSArPSAoIHN0YWNrLmcgPSAoIHBnID0gcGl4ZWxzW3lpKzFdICkgKSAqIHJicztcXG5cXHRcXHRcXHRiX3N1bSArPSAoIHN0YWNrLmIgPSAoIHBiID0gcGl4ZWxzW3lpKzJdICkgKSAqIHJicztcXG5cXHRcXHRcXHRhX3N1bSArPSAoIHN0YWNrLmEgPSAoIHBhID0gcGl4ZWxzW3lpKzNdICkgKSAqIHJicztcXG5cXG5cXHRcXHRcXHRyX2luX3N1bSArPSBwcjtcXG5cXHRcXHRcXHRnX2luX3N1bSArPSBwZztcXG5cXHRcXHRcXHRiX2luX3N1bSArPSBwYjtcXG5cXHRcXHRcXHRhX2luX3N1bSArPSBwYTtcXG5cXG5cXHRcXHRcXHRzdGFjayA9IHN0YWNrLm5leHQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBpIDwgaGVpZ2h0TWludXMxICkge1xcblxcdFxcdFxcdFxcdHlwICs9IHdpZHRoO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0eWkgPSB4O1xcblxcdFxcdHN0YWNrSW4gPSBzdGFja1N0YXJ0O1xcblxcdFxcdHN0YWNrT3V0ID0gc3RhY2tFbmQ7XFxuXFxuXFx0XFx0Zm9yICggeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKyApIHtcXG5cXHRcXHRcXHRwID0geWkgPDwgMjtcXG5cXHRcXHRcXHRwaXhlbHNbcCszXSA9IHBhID0gKCBhX3N1bSAqIG11bF9zdW0gKSA+PiBzaGdfc3VtO1xcblxcdFxcdFxcdFxcblxcdFxcdFxcdGlmICggcGEgPiAwICkge1xcblxcdFxcdFxcdFxcdHBhID0gMjU1IC8gcGE7XFxuXFx0XFx0XFx0XFx0cGl4ZWxzW3BdICAgPSAoICggcl9zdW0gKiBtdWxfc3VtICkgPj4gc2hnX3N1bSkgKiBwYTtcXG5cXHRcXHRcXHRcXHRwaXhlbHNbcCsxXSA9ICggKCBnX3N1bSAqIG11bF9zdW0gKSA+PiBzaGdfc3VtKSAqIHBhO1xcblxcdFxcdFxcdFxcdHBpeGVsc1twKzJdID0gKCAoIGJfc3VtICogbXVsX3N1bSApID4+IHNoZ19zdW0pICogcGE7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRwaXhlbHNbcF0gPSBwaXhlbHNbcCsxXSA9IHBpeGVsc1twKzJdID0gMDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cl9zdW0gLT0gcl9vdXRfc3VtO1xcblxcdFxcdFxcdGdfc3VtIC09IGdfb3V0X3N1bTtcXG5cXHRcXHRcXHRiX3N1bSAtPSBiX291dF9zdW07XFxuXFx0XFx0XFx0YV9zdW0gLT0gYV9vdXRfc3VtO1xcblxcblxcdFxcdFxcdHJfb3V0X3N1bSAtPSBzdGFja0luLnI7XFxuXFx0XFx0XFx0Z19vdXRfc3VtIC09IHN0YWNrSW4uZztcXG5cXHRcXHRcXHRiX291dF9zdW0gLT0gc3RhY2tJbi5iO1xcblxcdFxcdFxcdGFfb3V0X3N1bSAtPSBzdGFja0luLmE7XFxuXFxuXFx0XFx0XFx0cCA9ICggeCArICggKCAoIHAgPSB5ICsgcmFkaXVzUGx1czEgKSA8IGhlaWdodE1pbnVzMSA/IHAgOiBoZWlnaHRNaW51czEgKSAqIHdpZHRoICkgKSA8PCAyO1xcblxcblxcdFxcdFxcdHJfc3VtICs9ICggcl9pbl9zdW0gKz0gKCBzdGFja0luLnIgPSBwaXhlbHNbcF0gKSApO1xcblxcdFxcdFxcdGdfc3VtICs9ICggZ19pbl9zdW0gKz0gKCBzdGFja0luLmcgPSBwaXhlbHNbcCsxXSApICk7XFxuXFx0XFx0XFx0Yl9zdW0gKz0gKCBiX2luX3N1bSArPSAoIHN0YWNrSW4uYiA9IHBpeGVsc1twKzJdICkgKTtcXG5cXHRcXHRcXHRhX3N1bSArPSAoIGFfaW5fc3VtICs9ICggc3RhY2tJbi5hID0gcGl4ZWxzW3ArM10gKSApO1xcblxcblxcdFxcdFxcdHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XFxuXFxuXFx0XFx0XFx0cl9vdXRfc3VtICs9ICggcHIgPSBzdGFja091dC5yICk7XFxuXFx0XFx0XFx0Z19vdXRfc3VtICs9ICggcGcgPSBzdGFja091dC5nICk7XFxuXFx0XFx0XFx0Yl9vdXRfc3VtICs9ICggcGIgPSBzdGFja091dC5iICk7XFxuXFx0XFx0XFx0YV9vdXRfc3VtICs9ICggcGEgPSBzdGFja091dC5hICk7XFxuXFxuXFx0XFx0XFx0cl9pbl9zdW0gLT0gcHI7XFxuXFx0XFx0XFx0Z19pbl9zdW0gLT0gcGc7XFxuXFx0XFx0XFx0Yl9pbl9zdW0gLT0gcGI7XFxuXFx0XFx0XFx0YV9pbl9zdW0gLT0gcGE7XFxuXFxuXFx0XFx0XFx0c3RhY2tPdXQgPSBzdGFja091dC5uZXh0O1xcblxcblxcdFxcdFxcdHlpICs9IHdpZHRoO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGltYWdlRGF0YTtcXG59XFxuXFxuZnVuY3Rpb24gZ3JleXNjYWxlIChpbWFnZURhdGEpIHtcXG5cXHR2YXIgbGVuID0gaW1hZ2VEYXRhLmRhdGEubGVuZ3RoO1xcblxcdHZhciBicmlnaHRuZXNzO1xcblxcblxcdGZvciAoIHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0ICkge1xcblxcdFxcdGJyaWdodG5lc3MgPSAwLjM0ICogaW1hZ2VEYXRhLmRhdGFbaV0gKyAwLjUgKiBpbWFnZURhdGEuZGF0YVtpICsgMV0gKyAwLjE2ICogaW1hZ2VEYXRhLmRhdGFbaSArIDJdO1xcblxcblxcdFxcdGltYWdlRGF0YS5kYXRhW2ldID0gYnJpZ2h0bmVzcztcXG5cXHRcXHRpbWFnZURhdGEuZGF0YVtpICsgMV0gPSBicmlnaHRuZXNzO1xcblxcdFxcdGltYWdlRGF0YS5kYXRhW2kgKyAyXSA9IGJyaWdodG5lc3M7XFxuXFx0fVxcblxcdFxcdFxcblxcdHJldHVybiBpbWFnZURhdGE7XFxufVxcblxcbi8vIG1vc3QgcGFydHMgdGFrZW4gZnJvbSBodHRwOi8vanNkby5pdC9ha20yL3hvWXhcXG4vLyAoc3RhcnRpbmcgbGluZSAyOTMrKylcXG5mdW5jdGlvbiBnZXRFZGdlUG9pbnRzICggaW1hZ2VEYXRhLCB0aHJlc2hvbGQgKSB7XFxuXFx0Ly8gb25seSBjaGVjayBldmVyeSAybmQgcGl4ZWwgaW4gaW1hZ2VEYXRhIHRvIHNhdmUgc29tZSB0aW1lLlxcblxcdHZhciBtdWx0aXBsaWVyID0gMjtcXG5cXHR2YXIgd2lkdGggPSBpbWFnZURhdGEud2lkdGg7XFxuXFx0dmFyIGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQ7XFxuXFx0dmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcXG5cXHR2YXIgcG9pbnRzID0gWyBdO1xcblxcdHZhciB4LCB5LCByb3csIGNvbCwgc3gsIHN5LCBzdGVwLCBzdW0sIHRvdGFsO1xcblxcblxcdGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0OyB5ICs9IG11bHRpcGxpZXIgKSB7XFxuXFx0XFx0Zm9yICggeCA9IDA7IHggPCB3aWR0aDsgeCArPSBtdWx0aXBsaWVyICkge1xcblxcdFxcdFxcdHN1bSA9IHRvdGFsID0gMDtcXG5cXG5cXHRcXHRcXHRmb3IgKCByb3cgPSAtMTsgcm93IDw9IDE7IHJvdysrICkge1xcblxcdFxcdFxcdFxcdHN5ID0geSArIHJvdztcXG5cXHRcXHRcXHRcXHRzdGVwID0gc3kgKiB3aWR0aDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHN5ID49IDAgJiYgc3kgPCBoZWlnaHQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggY29sID0gLTE7IGNvbCA8PSAxOyBjb2wrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzeCA9IHggKyBjb2w7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBzeCA+PSAwICYmIHN4IDwgd2lkdGggKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3VtICs9IGRhdGFbKCBzeCArIHN0ZXAgKSA8PCAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0b3RhbCsrO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHRvdGFsICkge1xcblxcdFxcdFxcdFxcdHN1bSAvPSB0b3RhbDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBzdW0gPiB0aHJlc2hvbGQgKSB7XFxuXFx0XFx0XFx0XFx0cG9pbnRzLnB1c2goIHsgeDogeCwgeTogeSB9ICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHBvaW50cztcXG59XFxuXFxuZnVuY3Rpb24gY2xhbXAgKCB2YWx1ZSwgbWluLCBtYXggKSB7XFxuXFx0cmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZTtcXG59XFxuXFxuZnVuY3Rpb24gYWRkVmVydGV4ICggeCwgeSwgaGFzaCApIHtcXG5cXHR2YXIgcmVzdWx0S2V5ID0geCArICd8JyArIHk7XFxuXFxuXFx0aWYgKCAhIGhhc2hbcmVzdWx0S2V5XSApIHtcXG5cXHRcXHRoYXNoW3Jlc3VsdEtleV0gPSB7IHg6IHgsIHk6IHkgfTtcXG5cXHR9XFxuXFxuXFx0cmVzdWx0S2V5ID0gbnVsbDtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0VmVydGljZXNGcm9tUG9pbnRzICggcG9pbnRzLCBtYXhQb2ludENvdW50LCBhY2N1cmFjeSwgd2lkdGgsIGhlaWdodCApIHtcXG5cXHQvLyB1c2luZyBoYXNoIGZvciBhbGwgcG9pbnRzIHRvIG1ha2Ugc3VyZSB3ZSBoYXZlIGEgc2V0IG9mIHVuaXF1ZSB2ZXJ0aWNlcy5cXG5cXHR2YXIgcmVzdWx0SGFzaCA9IHsgfTtcXG5cXG5cXHQvLyB1c2UgMjUlIG9mIG1heCBwb2ludCBjb3VudCB0byBjcmVhdGUgYSBiYWNrZ3JvdW5kIGdyaWQuXFxuXFx0Ly8gdGhpcyBhdm9pZHMgaGF2aW5nIHRvbyBtYW55IFxcXCJiaWdcXFwiIHRyaWFuZ2xlcyBpbiBhcmVhcyBvZiB0aGUgaW1hZ2Ugd2l0aCBsb3cgY29udHJhc3QgXFxuXFx0Ly8gbmV4dCB0byB2ZXJ5IHNtYWxsIG9uZXMgaW4gYXJlYXMgd2l0aCBoaWdoIGNvbnRyYXN0XFxuXFx0Ly8gZm9yIGV2ZXJ5IG90aGVyIHJvdywgc3RhcnQgdGhlIHggdmFsdWUgYXQgPiAwLCBzbyB0aGUgZ3JpZCBkb2Vzbid0IGxvb2sgdG9vIHJlZ3VsYXJcXG5cXHR2YXIgZ3JpZFBvaW50Q291bnQgPSBNYXRoLm1heCggfn4oIG1heFBvaW50Q291bnQgKiAoIDEgLSBhY2N1cmFjeSApICksIDUgKTtcXG5cXG5cXHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MTA3MDkyLzIyOTE4OVxcblxcdHZhciBncmlkQ29sdW1ucyA9IE1hdGgucm91bmQoIE1hdGguc3FydCggZ3JpZFBvaW50Q291bnQgKSApO1xcblxcdHZhciBncmlkUm93cyA9IE1hdGgucm91bmQoIE1hdGguY2VpbCggZ3JpZFBvaW50Q291bnQgLyBncmlkQ29sdW1ucyApICk7XFxuXFx0XFxuXFx0dmFyIHhJbmNyZW1lbnQgPSB+figgd2lkdGggLyBncmlkQ29sdW1ucyApO1xcblxcdHZhciB5SW5jcmVtZW50ID0gfn4oIGhlaWdodCAvIGdyaWRSb3dzICk7XFxuXFxuXFx0dmFyIHJvd0luZGV4ID0gMDtcXG5cXHR2YXIgc3RhcnRYID0gMDtcXG5cXG5cXHR2YXIgeCA9IDA7XFxuXFx0dmFyIHkgPSAwO1xcblxcblxcdGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0OyB5Kz0geUluY3JlbWVudCApIHtcXG5cXHRcXHRyb3dJbmRleCsrO1xcblxcblxcdFxcdHN0YXJ0WCA9IHJvd0luZGV4ICUgMiA9PT0gMCA/IH5+KCB4SW5jcmVtZW50IC8gMiApIDogMDsgXFxuXFxuXFx0XFx0Zm9yICggeCA9IHN0YXJ0WDsgeCA8IHdpZHRoOyB4ICs9IHhJbmNyZW1lbnQgKSB7XFxuXFx0XFx0XFx0aWYgKCB4IDwgd2lkdGggJiYgeSA8IGhlaWdodCApIHtcXG5cXHRcXHRcXHRcXHQvLyBcXFwiZGlzdG9ydGluZ1xcXCIgdGhlIGdyaWQgYSBsaXR0bGUgYml0IHNvIHRoYXQgdGhlXFxuXFx0XFx0XFx0XFx0Ly8gYmFja2dyb3VuZCB2ZXJ0aWNlcyBkb24ndCBhcHBlYXIgdG8gYmUgb24gYSBzdHJhaWdodCBsaW5lICh3aGljaCBsb29rcyBib3JpbmcpXFxuXFx0XFx0XFx0XFx0YWRkVmVydGV4KFxcblxcdFxcdFxcdFxcdFxcdH5+KCB4ICsgKCBNYXRoLmNvcyggeSApICogKCB5SW5jcmVtZW50ICkgKSApLFxcblxcdFxcdFxcdFxcdFxcdH5+KCB5ICsgKCBNYXRoLnNpbiggeCApICogKCB4SW5jcmVtZW50ICkgKSApLFxcblxcdFxcdFxcdFxcdFxcdHJlc3VsdEhhc2hcXG5cXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcdFxcblxcdC8vIGFkZCBwb2ludHMgaW4gdGhlIGNvcm5lcnNcXG5cXHRhZGRWZXJ0ZXgoIDAsIDAsIHJlc3VsdEhhc2ggKTtcXG5cXHRhZGRWZXJ0ZXgoIHdpZHRoIC0gMSwgMCwgcmVzdWx0SGFzaCApO1xcblxcdGFkZFZlcnRleCggd2lkdGggLSAxLCBoZWlnaHQgLSAxLCByZXN1bHRIYXNoICk7XFxuXFx0YWRkVmVydGV4KCAwLCBoZWlnaHQgLSAxLCByZXN1bHRIYXNoICk7XFxuXFxuXFx0Ly8gYWRkIHBvaW50cyBmcm9tIGFsbCBlZGdlIHBvaW50c1xcblxcdHZhciByZW1haW5pbmdQb2ludENvdW50ID0gbWF4UG9pbnRDb3VudCAtIE9iamVjdC5rZXlzKCByZXN1bHRIYXNoICkubGVuZ3RoO1xcblxcdHZhciBlZGdlUG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XFxuXFx0dmFyIGluY3JlbWVudCA9IH5+KCBlZGdlUG9pbnRDb3VudCAvIHJlbWFpbmluZ1BvaW50Q291bnQgKTtcXG5cXG5cXHRpZiAoIG1heFBvaW50Q291bnQgPiAwICYmIGluY3JlbWVudCA+IDAgKSB7XFxuXFx0XFx0dmFyIGkgPSAwO1xcblxcblxcdFxcdGZvciAoIGkgPSAwOyBpIDwgZWRnZVBvaW50Q291bnQ7IGkgKz0gaW5jcmVtZW50ICkge1xcblxcdFxcdFxcdGFkZFZlcnRleCggcG9pbnRzW2ldLngsIHBvaW50c1tpXS55LCByZXN1bHRIYXNoICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRwb2ludHMgPSBudWxsO1xcblxcblxcdHJldHVybiBPYmplY3Qua2V5cyggcmVzdWx0SGFzaCApLm1hcCggZnVuY3Rpb24gKGtleSkge1xcblxcdFxcdHJldHVybiByZXN1bHRIYXNoW2tleV07XFxuXFx0fSApO1xcbn1cXG5cXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0JveCAocG9pbnRzKSB7XFxuXFx0dmFyIHhNaW4gPSBJbmZpbml0eTtcXG5cXHR2YXIgeE1heCA9IC1JbmZpbml0eTtcXG5cXHR2YXIgeU1pbiA9IEluZmluaXR5O1xcblxcdHZhciB5TWF4ID0gLUluZmluaXR5O1xcblxcblxcdHBvaW50cy5mb3JFYWNoKCBmdW5jdGlvbiAocCkge1xcblxcdFxcdGlmICggcC54IDwgeE1pbiApIHtcXG5cXHRcXHRcXHR4TWluID0gcC54O1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIHAueSA8IHlNaW4gKSB7XFxuXFx0XFx0XFx0eU1pbiA9IHAueTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBwLnggPiB4TWF4ICkge1xcblxcdFxcdFxcdHhNYXggPSBwLng7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggcC55ID4geU1heCApIHtcXG5cXHRcXHRcXHR5TWF4ID0gcC55O1xcblxcdFxcdH1cXG5cXHR9ICk7XFxuXFxuXFx0cmV0dXJuIHtcXG5cXHRcXHR4OiB4TWluLFxcblxcdFxcdHk6IHlNaW4sXFxuXFx0XFx0d2lkdGg6IHhNYXggLSB4TWluLFxcblxcdFxcdGhlaWdodDogeU1heCAtIHlNaW5cXG5cXHR9O1xcbn1cXG5cXG5mdW5jdGlvbiBhZGRCb3VuZGluZ0JveGVzVG9Qb2x5Z29ucyAoIHBvbHlnb25zLCBjb2xvckRhdGEsIHBhcmFtcyApIHtcXG5cXHRwb2x5Z29ucy5mb3JFYWNoKCBmdW5jdGlvbiAocG9seWdvbikge1xcblxcdFxcdHBvbHlnb24uYm91bmRpbmdCb3ggPSBnZXRCb3VuZGluZ0JveCggWyBwb2x5Z29uLmEsIHBvbHlnb24uYiwgcG9seWdvbi5jIF0gKTtcXG5cXHR9ICk7XFxuXFxuXFx0cmV0dXJuIHBvbHlnb25zLmZpbHRlciggZnVuY3Rpb24gKHBvbHlnb24pIHtcXG5cXHRcXHRyZXR1cm4gcG9seWdvbi5ib3VuZGluZ0JveC53aWR0aCA+IDAgJiYgcG9seWdvbi5ib3VuZGluZ0JveC5oZWlnaHQgPiAwO1xcblxcdH0gKTtcXG59XFxuXFxuLyoqXFxuICogR2V0IGNvbG9yIG9iamVjdCBieSBwb3NpdGlvblxcbiAqIEBwYXJhbSAge09iamVjdH0gcG9zICAgICAgICAge3gseX0gb2JqZWN0XFxuICogQHBhcmFtICB7T2JqZWN0fSBjb2xvckRhdGEgICBJbWFnZSBjb2xvciBkYXRhIG9iamVjdFxcbiAqIEBwYXJhbSAge09iamVjdH0gW3RyYW5zcGFyZW50Q29sb3JdIChvcHRpb25hbCkgUkdCQSBjb2xvciBvYmplY3QuIFVzZWQgdG8gc2V0IHNwZWNpZmljIGNvbG9yIHRvIHRyYW5zcGFyZW50IHBpeGVsc1xcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgUkdCQSBjb2xvciBvYmplY3RcXG4gKi9cXG5mdW5jdGlvbiBnZXRDb2xvckJ5UG9zICggcG9zLCBjb2xvckRhdGEsIHRyYW5zcGFyZW50Q29sb3IgKSB7XFxuXFx0dmFyIHggPSBjbGFtcCggcG9zLngsIDEsIGNvbG9yRGF0YS53aWR0aCAtIDIgKTtcXG5cXHR2YXIgeSA9IGNsYW1wKCBwb3MueSwgMSwgY29sb3JEYXRhLmhlaWdodCAtIDIgKTtcXG5cXHR2YXIgaW5kZXggPSAoICggeCB8IDAgKSArICggeSB8IDAgKSAqIGNvbG9yRGF0YS53aWR0aCApIDw8IDI7XFxuXFxuXFx0aWYgKCBpbmRleCA+PSBjb2xvckRhdGEuZGF0YS5sZW5ndGggKSB7XFxuXFx0XFx0aW5kZXggPSBjb2xvckRhdGEuZGF0YS5sZW5ndGggLSA1O1xcblxcdH1cXG5cXG5cXHR2YXIgYWxwaGEgPSBjb2xvckRhdGEuZGF0YVtpbmRleCArIDNdIC8gMjU1O1xcblxcblxcdC8vIFJldHVybiBSR0JBIGNvbG9yIG9iamVjdFxcblxcdHJldHVybiAoIHRyYW5zcGFyZW50Q29sb3IgJiYgYWxwaGEgPT09IDAgKSA/IHRyYW5zcGFyZW50Q29sb3IgOiB7XFxuXFx0XFx0cjogY29sb3JEYXRhLmRhdGFbaW5kZXhdLFxcblxcdFxcdGc6IGNvbG9yRGF0YS5kYXRhW2luZGV4ICsgMV0sXFxuXFx0XFx0YjogY29sb3JEYXRhLmRhdGFbaW5kZXggKyAyXSxcXG5cXHRcXHRhOiBhbHBoYVxcblxcdH07XFxufVxcblxcbi8qKlxcbiAqIEdldCBwb2x5Z29uJ3MgY2VudGVyIHBvaW50XFxuICogQHBhcmFtICB7T2JqZWN0fSBwb2x5Z29uIFBvbHlnb24gb2JqZWN0XFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIFBvaW50IGNvb3JkaW5hdGVzIHt4LHl9XFxuICovXFxuZnVuY3Rpb24gcG9seWdvbkNlbnRlciAocG9seWdvbikge1xcblxcdHJldHVybiB7XFxuXFx0XFx0eDogKCBwb2x5Z29uLmEueCArIHBvbHlnb24uYi54ICsgcG9seWdvbi5jLnggKSAqIDAuMzMzMzMsXFxuXFx0XFx0eTogKCBwb2x5Z29uLmEueSArIHBvbHlnb24uYi55ICsgcG9seWdvbi5jLnkgKSAqIDAuMzMzMzNcXG5cXHR9O1xcbn1cXG5cXG4vKipcXG4gKiBJcyBjb2xvciB0cmFuc3BhcmVudCA/XFxuICogQHBhcmFtICB7T2JqZWN0fSBjb2xvciBDb2xvciBvYmplY3RcXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIElzIHRyYW5zcGFyZW50P1xcbiAqL1xcbmZ1bmN0aW9uIGlzVHJhbnNwYXJlbnQgKGNvbG9yKSB7XFxuXFx0cmV0dXJuIGNvbG9yLmEgPT09IDA7XFxufVxcblxcbi8vIGltcG9ydCBvYmplY3RBc3NpZ24gZnJvbSAnb2JqZWN0LWFzc2lnbidcXG5cXG4vLyBodHRwczovL2dpc3QuZ2l0aHVidXNlcmNvbnRlbnQuY29tL29yaWFkYW0vMzk2YTRiZWFhYWQ0NjVjYTkyMTYxOGYyZjI0NDRkNDkvcmF3Lzc2YjBkZTZjYWZmYWFjNTlmOGFmMmI0ZGZhMGUwYjYzOTdjZjQ0N2QvY29sb3JWYWx1ZXMuanNcXG4vLyByZXR1cm4gYXJyYXkgb2YgW3IsZyxiLGFdIGZyb20gYW55IHZhbGlkIGNvbG9yLiBpZiBmYWlsZWQgcmV0dXJucyB1bmRlZmluZWRcXG5mdW5jdGlvbiBzdHJUb0NvbG9yQXJyICggY29sb3IgKSB7XFxuXFx0aWYgKCB0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnICkge1xcblxcdFxcdHZhciByZXN1bHQgPSBbIDAsIDAsIDAsIDAgXTtcXG5cXHRcXHRcXG5cXHRcXHRpZiAoIGNvbG9yWzBdID09PSAnIycgKVxcdHtcXG5cXHRcXHRcXHQvLyBjb252ZXJ0ICNSR0IgYW5kICNSR0JBIHRvICNSUkdHQkIgYW5kICNSUkdHQkJBQVxcblxcdFxcdFxcdGlmICggY29sb3IubGVuZ3RoIDwgNyApIHtcXG5cXHRcXHRcXHRcXHRjb2xvciA9IFxcXCIjXFxcIiArIChjb2xvclsxXSkgKyAoY29sb3JbMV0pICsgKGNvbG9yWzJdKSArIChjb2xvclsyXSkgKyAoY29sb3JbM10pICsgKGNvbG9yWzNdKSArIChjb2xvci5sZW5ndGggPiA0ID8gY29sb3JbNF0gKyBjb2xvcls0XSA6ICcnKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmVzdWx0ID0gW1xcblxcdFxcdFxcdFxcdHBhcnNlSW50KGNvbG9yLnN1YnN0ciggMSwgMiApLCAxNiksXFxuXFx0XFx0XFx0XFx0cGFyc2VJbnQoY29sb3Iuc3Vic3RyKCAzLCAyICksIDE2KSxcXG5cXHRcXHRcXHRcXHRwYXJzZUludChjb2xvci5zdWJzdHIoIDUsIDIgKSwgMTYpLFxcblxcdFxcdFxcdFxcdGNvbG9yLmxlbmd0aCA+IDcgPyBwYXJzZUludCggY29sb3Iuc3Vic3RyKCA3LCAyICksIDE2ICkgLyAyNTUgOiAxXFxuXFx0XFx0XFx0XTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBjb2xvci5pbmRleE9mKCdyZ2InKSA9PT0gMCApIHtcXG5cXHRcXHRcXHQvLyBjb252ZXJ0ICdyZ2IoUixHLEIpJyB0byAncmdiKFIsRyxCKUEnIHdoaWNoIGxvb2tzIGF3ZnVsIGJ1dCB3aWxsIHBhc3MgdGhlIHJlZ3hlcCBiZWxvd1xcblxcdFxcdFxcdGlmICggISBjb2xvci5pbmNsdWRlcyggJ3JnYmEnICkgKSB7XFxuXFx0XFx0XFx0XFx0Y29sb3IgKz0gJywxJztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmVzdWx0ID0gY29sb3JcXG5cXHRcXHRcXHRcXHQubWF0Y2goIC9bXFxcXC5cXFxcZF0rL2cgKVxcblxcdFxcdFxcdFxcdC5tYXAoIGZ1bmN0aW9uIChhKSB7IHJldHVybiArYTsgfSApO1xcblxcdFxcdH1cXG5cXHRcXHRcXG5cXHRcXHRyZXR1cm4gcmVzdWx0O1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0cmV0dXJuO1xcblxcdH1cXG5cXG59XFxuXFxuZnVuY3Rpb24gc3RyVG9Db2xvciAoIHN0ciApIHtcXG5cXHR2YXIgY29sb3IgPSBzdHJUb0NvbG9yQXJyKCBzdHIgKTtcXG5cXG5cXHRpZiAoIGNvbG9yICkge1xcblxcdFxcdHZhciByID0gY29sb3JbMF07XFxuXFx0XFx0dmFyIGcgPSBjb2xvclsxXTtcXG5cXHRcXHR2YXIgYiA9IGNvbG9yWzJdO1xcblxcdFxcdHZhciBhID0gY29sb3JbM107XFxuXFx0XFx0cmV0dXJuIHsgcjogciwgZzogZywgYjogYiwgYTogYSB9O1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0cmV0dXJuO1xcblxcdH1cXG59XFxuXFxuZnVuY3Rpb24gYWRkQ29sb3JUb1BvbHlnb25zICggcG9seWdvbnMsIGNvbG9yRGF0YSwgcGFyYW1zICkge1xcblxcdHZhciBmaWxsID0gcGFyYW1zLmZpbGw7XFxuXFx0dmFyIHN0cm9rZSA9IHBhcmFtcy5zdHJva2U7XFxuXFx0dmFyIHN0cm9rZVdpZHRoID0gcGFyYW1zLnN0cm9rZVdpZHRoO1xcblxcdHZhciBsaW5lSm9pbiA9IHBhcmFtcy5saW5lSm9pbjtcXG5cXHR2YXIgdHJhbnNwYXJlbnRDb2xvciA9IHBhcmFtcy50cmFuc3BhcmVudENvbG9yO1xcblxcdHZhciBmaWxsQ29sb3IgPSBmaWxsID8gc3RyVG9Db2xvciggZmlsbCApIDogZmFsc2U7XFxuXFx0dmFyIHN0cm9rZUNvbG9yID0gc3Ryb2tlID8gc3RyVG9Db2xvciggc3Ryb2tlICkgOiBmYWxzZTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDb2xvciBvdmVycmlkZSBsb2dpY1xcblxcdCAqIEBwYXJhbSAge09iamVjdH0gY29sb3IgICAgQ29sb3Igb2JqZWN0XFxuXFx0ICogQHBhcmFtICB7U3RyaW5nfSBvdmVycmlkZSBPdmVycmlkZSBjb2xvciAoZmlsbENvbG9yL3N0cm9rZUNvbG9yKVxcblxcdCAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgQ1NTIGZvcm1hdHRlZCBjb2xvciAocmdiYSwuLilcXG5cXHQgKi9cXG5cXHR2YXIgZ2V0Q29sb3IgPSBmdW5jdGlvbiAoIGNvbG9yLCBvdmVycmlkZSApIHtcXG5cXHRcXHR2YXIgdCA9ICggaXNUcmFuc3BhcmVudCggY29sb3IgKSAmJiB0cmFuc3BhcmVudENvbG9yICk7XFx0Ly8gQ29sb3IgaXMgdHJhbnNwYXJlbnQsIGFuZCB0cmFuc3BhcmVudENvbG9yIG92ZXJyaWRlIGlzIGRlZmluZWRcXG5cXHRcXHR2YXIgYyA9IHQgPyB0cmFuc3BhcmVudENvbG9yIDogY29sb3I7XFxuXFx0XFx0cmV0dXJuICggb3ZlcnJpZGUgJiYgIXQgKSA/IG92ZXJyaWRlIDogYztcXHRcXHQvLyBQcmlvcml0eTogdHJhbnNwYXJlbnRDb2xvciAtPiBvdmVycmlkZSAtPiBzdXBwbGllZCBjb2xvclxcblxcdH07XFxuXFxuXFx0cG9seWdvbnMuZm9yRWFjaCggZnVuY3Rpb24gKHBvbHlnb24pIHtcXG5cXHRcXHR2YXIgY29sb3IgPSBnZXRDb2xvckJ5UG9zKCBwb2x5Z29uQ2VudGVyKCBwb2x5Z29uICksIGNvbG9yRGF0YSApO1xcblxcblxcdFxcdGlmICggZmlsbCApIHtcXG5cXHRcXHRcXHRwb2x5Z29uLmZpbGwgPSBnZXRDb2xvciggY29sb3IsIGZpbGxDb2xvciApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIHN0cm9rZSApIHtcXG5cXHRcXHRcXHRwb2x5Z29uLnN0cm9rZUNvbG9yID0gZ2V0Q29sb3IoY29sb3IsIHN0cm9rZUNvbG9yKTtcXG5cXHRcXHRcXHRwb2x5Z29uLnN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGg7XFxuXFx0XFx0XFx0cG9seWdvbi5saW5lSm9pbiA9IGxpbmVKb2luO1xcblxcdFxcdH1cXG5cXHR9ICk7XFxuXFxuXFx0cmV0dXJuIHBvbHlnb25zO1xcbn1cXG5cXG4vLyAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTczMzQyMC8yMjkxODlcXG5mdW5jdGlvbiBsdW1pbmFuY2UgKGNvbG9yKSB7XFxuXFx0dmFyIGEgPSBbIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgXS5tYXAoIGZ1bmN0aW9uICh2KSB7XFxuXFx0XFx0diAvPSAyNTU7XFxuXFx0XFx0cmV0dXJuICggdiA8PSAwLjAzOTI4ICkgPyB2IC8gMTIuOTIgOiBNYXRoLnBvdyggKCAoIHYgKyAwLjA1NSApIC8gMS4wNTUgKSwgMi40ICk7XFxuXFx0fSApO1xcblxcblxcdHJldHVybiBhWzBdICogMC4yMTI2ICsgYVsxXSAqIDAuNzE1MiArIGFbMl0gKiAwLjA3MjI7XFxufVxcblxcbmZ1bmN0aW9uIGRpc3RhbmNlICggYSwgYiApIHtcXG5cXHR2YXIgZHggPSBiLnggLSBhLng7XFxuXFx0dmFyIGR5ID0gYi55IC0gYS55O1xcblxcblxcdHJldHVybiBNYXRoLnNxcnQoICggZHggKiBkeCApICsgKCBkeSAqIGR5ICkgKTtcXG59XFxuXFxuZnVuY3Rpb24gYWRkR3JhZGllbnRzVG9Qb2x5Z29ucyAoIHBvbHlnb25zLCBjb2xvckRhdGEsIHBhcmFtcyApIHtcXG5cXHRwb2x5Z29ucy5mb3JFYWNoKCBmdW5jdGlvbiAocG9seWdvbikge1xcblxcdFxcdHZhciBkYXRhID0geyB9O1xcblxcblxcdFxcdCdhYmMnLnNwbGl0KCAnJyApLmZvckVhY2goIGZ1bmN0aW9uIChrZXkpIHtcXG5cXHRcXHRcXHR2YXIgY29sb3IgPSBnZXRDb2xvckJ5UG9zKCBwb2x5Z29uW2tleV0sIGNvbG9yRGF0YSwgcGFyYW1zLnRyYW5zcGFyZW50Q29sb3IgKTtcXG5cXHRcXHRcXHRcXG5cXHRcXHRcXHRkYXRhW2tleV0gPSB7XFxuXFx0XFx0XFx0XFx0a2V5OiBrZXksXFxuXFx0XFx0XFx0XFx0Y29sb3I6IGNvbG9yLFxcblxcdFxcdFxcdFxcdHg6IHBvbHlnb25ba2V5XS54LFxcblxcdFxcdFxcdFxcdHk6IHBvbHlnb25ba2V5XS55XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRkYXRhW2tleV0ubHVtaW5hbmNlID0gbHVtaW5hbmNlKCBkYXRhW2tleV0uY29sb3IgKTtcXG5cXG5cXHRcXHRcXHR2YXIgb3RoZXJLZXlzID0gJ2FiYycucmVwbGFjZSgga2V5LCAnJyApLnNwbGl0KCAnJyApO1xcblxcblxcdFxcdFxcdGRhdGFba2V5XS5tZWRpYW4gPSB7XFxuXFx0XFx0XFx0XFx0eDogKCBwb2x5Z29uW290aGVyS2V5c1swXV0ueCArIHBvbHlnb25bb3RoZXJLZXlzWzFdXS54ICkgLyAyLFxcblxcdFxcdFxcdFxcdHk6ICggcG9seWdvbltvdGhlcktleXNbMF1dLnkgKyBwb2x5Z29uW290aGVyS2V5c1sxXV0ueSApIC8gMlxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0ZGF0YVtrZXldLm1lZGlhbkNvbG9yID0gZ2V0Q29sb3JCeVBvcyggZGF0YVtrZXldLm1lZGlhbiwgY29sb3JEYXRhLCBwYXJhbXMudHJhbnNwYXJlbnRDb2xvciApO1xcblxcdFxcdFxcdGRhdGFba2V5XS5tZWRpYW5MdW1pbmFuY2UgPSBsdW1pbmFuY2UoIGRhdGFba2V5XS5tZWRpYW5Db2xvciApO1xcblxcdFxcdH0gKTtcXG5cXG5cXHRcXHQvLyBzb3J0IGJ5IGF4aXMgb2YgbW9zdCBkaWZmZXJlbmNlIGluIGx1bWluYW5jZVxcblxcdFxcdHZhciBwb2ludHNCeURlbHRhSW5MdW1pbmFuY2UgPSBbIGRhdGEuYSwgZGF0YS5iLCBkYXRhLmMgXS5zb3J0KCBmdW5jdGlvbiAoIHUsIHYgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguYWJzKCB1Lmx1bWluYW5jZSAtIHUubWVkaWFuTHVtaW5hbmNlICkgLSBNYXRoLmFicyggdi5sdW1pbmFuY2UgLSB2Lm1lZGlhbkx1bWluYW5jZSApO1xcblxcdFxcdH0gKTtcXG5cXG5cXHRcXHR2YXIgcG9pbnRXaXRoTW9zdERlbHRhSW5MdW1pbmFuY2UgPSBwb2ludHNCeURlbHRhSW5MdW1pbmFuY2VbMF07XFxuXFx0XFx0dmFyIHN0YXJ0UG9pbnQgPSBwb2ludHNCeURlbHRhSW5MdW1pbmFuY2VbMF07XFxuXFx0XFx0dmFyIGVuZFBvaW50ID0gcG9pbnRXaXRoTW9zdERlbHRhSW5MdW1pbmFuY2UubWVkaWFuO1xcblxcblxcdFxcdHZhciBncmFkaWVuU3RvcFBvc2l0aW9ucyA9IFsgc3RhcnRQb2ludCBdO1xcblxcblxcdFxcdHZhciBzdGFydFRvRW5kRGlzdGFuY2UgPSBkaXN0YW5jZSggc3RhcnRQb2ludCwgZW5kUG9pbnQgKTtcXG5cXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDEsIGxlbiA9IHBhcmFtcy5ncmFkaWVudFN0b3BzIC0gMjsgaSA8IGxlbjsgaSsrICkge1xcblxcdFxcdFxcdHZhciBwb2ludERpc3RhbmNlID0gaSAqICggc3RhcnRUb0VuZERpc3RhbmNlIC8gcGFyYW1zLmdyYWRpZW50U3RvcHMgKTtcXG5cXHRcXHRcXHR2YXIgcG9pbnRQZXJjZW50ID0gcG9pbnREaXN0YW5jZSAvIHN0YXJ0VG9FbmREaXN0YW5jZTtcXG5cXHRcXHRcXHRcXG5cXHRcXHRcXHR2YXIgcG9pbnQgPSB7XFxuXFx0XFx0XFx0XFx0eDogc3RhcnRQb2ludC54ICsgcG9pbnRQZXJjZW50ICogKCBlbmRQb2ludC54IC0gc3RhcnRQb2ludC54ICksIFxcblxcdFxcdFxcdFxcdHk6IHN0YXJ0UG9pbnQueSArIHBvaW50UGVyY2VudCAqICggZW5kUG9pbnQueSAtIHN0YXJ0UG9pbnQueSApXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRncmFkaWVuU3RvcFBvc2l0aW9ucy5wdXNoKCBwb2ludCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRncmFkaWVuU3RvcFBvc2l0aW9ucy5wdXNoKCBlbmRQb2ludCApO1xcblxcblxcdFxcdHBvbHlnb24uZ3JhZGllbnQgPSB7XFxuXFx0XFx0XFx0eDE6IHBvaW50V2l0aE1vc3REZWx0YUluTHVtaW5hbmNlLngsXFxuXFx0XFx0XFx0eTE6IHBvaW50V2l0aE1vc3REZWx0YUluTHVtaW5hbmNlLnksXFxuXFx0XFx0XFx0eDI6IHBvaW50V2l0aE1vc3REZWx0YUluTHVtaW5hbmNlLm1lZGlhbi54LFxcblxcdFxcdFxcdHkyOiBwb2ludFdpdGhNb3N0RGVsdGFJbkx1bWluYW5jZS5tZWRpYW4ueSxcXG5cXHRcXHRcXHRjb2xvcnM6IGdyYWRpZW5TdG9wUG9zaXRpb25zLm1hcCggZnVuY3Rpb24gKHBvcykge1xcblxcdFxcdFxcdFxcdHJldHVybiBnZXRDb2xvckJ5UG9zKCBwb3MsIGNvbG9yRGF0YSwgcGFyYW1zLnRyYW5zcGFyZW50Q29sb3IgKTtcXG5cXHRcXHRcXHR9IClcXG5cXHRcXHR9O1xcblxcblxcdFxcdGlmICggcGFyYW1zLnN0cm9rZSApIHtcXG5cXHRcXHRcXHRwb2x5Z29uLnN0cm9rZVdpZHRoID0gcGFyYW1zLnN0cm9rZVdpZHRoO1xcblxcdFxcdFxcdHBvbHlnb24ubGluZUpvaW4gPSBwYXJhbXMubGluZUpvaW47XFxuXFx0XFx0fVxcblxcblxcdFxcdGRhdGEgPSBudWxsO1xcblxcdH0gKTtcXG5cXG5cXHRyZXR1cm4gcG9seWdvbnM7XFxufVxcblxcbi8qKlxcbiAqIEZpbHRlciBwb2x5Z29ucyB3aXRoIHRyYW5zcGFyZW50IGNvbG9yXFxuICogQHBhcmFtICB7QXJyYXl9IHBvbHlnb25zICAgIFBvbHlnb25zIGFycmF5XFxuICogQHBhcmFtICB7T2JqZWN0fSBjb2xvckRhdGEgIENvbG9yIGRhdGFcXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgRmlsdGVyZWQgcG9seWdvbnMgYXJyYXlcXG4gKi9cXG5mdW5jdGlvbiBmaWx0ZXJUcmFuc3BhcmVudFBvbHlnb25zICggcG9seWdvbnMsIGNvbG9yRGF0YSApIHtcXG5cXHRyZXR1cm4gcG9seWdvbnMuZmlsdGVyKCBmdW5jdGlvbiAocG9seWdvbikge1xcblxcdFxcdHZhciBjb2xvciA9IGdldENvbG9yQnlQb3MoIHBvbHlnb25DZW50ZXIoIHBvbHlnb24gKSwgY29sb3JEYXRhICk7XFxuXFx0XFx0cmV0dXJuICEgaXNUcmFuc3BhcmVudCggY29sb3IgKTtcXG5cXHR9KTtcXG59XFxuXFxuZnVuY3Rpb24gaW1hZ2VEYXRhVG9Qb2x5Z29ucyAoIGltYWdlRGF0YSwgcGFyYW1zICkge1xcblxcdGlmICggaXNJbWFnZURhdGEoIGltYWdlRGF0YSApICkge1xcblxcdFxcdHZhciBpbWFnZVNpemUgPSB7IHdpZHRoOiBpbWFnZURhdGEud2lkdGgsIGhlaWdodDogaW1hZ2VEYXRhLmhlaWdodCB9O1xcblxcdFxcdHZhciB0bXBJbWFnZURhdGEgPSBjb3B5SW1hZ2VEYXRhKCBpbWFnZURhdGEgKTtcXG5cXHRcXHR2YXIgY29sb3JJbWFnZURhdGEgPSBjb3B5SW1hZ2VEYXRhKCBpbWFnZURhdGEgKTtcXG5cXHRcXHR2YXIgYmx1cnJlZEltYWdlRGF0YSA9IHN0YWNrYmx1ciggdG1wSW1hZ2VEYXRhLCAwLCAwLCBpbWFnZVNpemUud2lkdGgsIGltYWdlU2l6ZS5oZWlnaHQsIHBhcmFtcy5ibHVyICk7XFxuXFx0XFx0dmFyIGdyZXlzY2FsZUltYWdlRGF0YSA9IGdyZXlzY2FsZSggYmx1cnJlZEltYWdlRGF0YSApO1xcblxcdFxcdHZhciBlZGdlc0ltYWdlRGF0YSA9IHNvYmVsKCBncmV5c2NhbGVJbWFnZURhdGEgKS50b0ltYWdlRGF0YSgpO1xcblxcdFxcdHZhciBlZGdlUG9pbnRzID0gZ2V0RWRnZVBvaW50cyggZWRnZXNJbWFnZURhdGEsIHBhcmFtcy50aHJlc2hvbGQgKTtcXG5cXHRcXHR2YXIgZWRnZVZlcnRpY2VzID0gZ2V0VmVydGljZXNGcm9tUG9pbnRzKCBlZGdlUG9pbnRzLCBwYXJhbXMudmVydGV4Q291bnQsIHBhcmFtcy5hY2N1cmFjeSwgaW1hZ2VTaXplLndpZHRoLCBpbWFnZVNpemUuaGVpZ2h0ICk7XFxuXFx0XFx0dmFyIHBvbHlnb25zID0gZGVsYXVuYXlfMiggZWRnZVZlcnRpY2VzICk7XFxuXFx0XFx0XFxuXFx0XFx0cG9seWdvbnMgPSBhZGRCb3VuZGluZ0JveGVzVG9Qb2x5Z29ucyggcG9seWdvbnMgKTtcXG5cXHRcXHRcXG5cXHRcXHRpZiAoICEgcGFyYW1zLnRyYW5zcGFyZW50Q29sb3IgKSB7XFxuXFx0XFx0XFx0cG9seWdvbnMgPSBmaWx0ZXJUcmFuc3BhcmVudFBvbHlnb25zKCBwb2x5Z29ucywgY29sb3JJbWFnZURhdGEgKTtcXG5cXHRcXHR9XFxuXFx0XFx0XFxuXFx0XFx0aWYgKCBwYXJhbXMuZmlsbCA9PT0gdHJ1ZSAmJiBwYXJhbXMuZ3JhZGllbnRzID09PSB0cnVlICkge1xcblxcdFxcdFxcdHBvbHlnb25zID0gYWRkR3JhZGllbnRzVG9Qb2x5Z29ucyggcG9seWdvbnMsIGNvbG9ySW1hZ2VEYXRhLCBwYXJhbXMgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHBvbHlnb25zID0gYWRkQ29sb3JUb1BvbHlnb25zKCBwb2x5Z29ucywgY29sb3JJbWFnZURhdGEsIHBhcmFtcyApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcG9seWdvbnM7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHR0aHJvdyBuZXcgRXJyb3IoIFxcXCJDYW4ndCB3b3JrIHdpdGggdGhlIGltYWdlRGF0YSBwcm92aWRlZC4gSXQgc2VlbXMgdG8gYmUgY29ycnVwdC5cXFwiICk7XFxuXFx0XFx0cmV0dXJuO1xcblxcdH1cXG59XFxuXFxub25tZXNzYWdlID0gZnVuY3Rpb24gKG1zZykge1xcblxcdGlmICggbXNnLmRhdGEuaW1hZ2VEYXRhICYmIG1zZy5kYXRhLnBhcmFtcyApIHtcXG5cXHRcXHR0cnkge1xcblxcdFxcdFxcdHZhciBpbWFnZURhdGEgPSBtc2cuZGF0YS5pbWFnZURhdGE7XFxuXFxuXFx0XFx0XFx0Ly8gcGhhbnRvbWpzIHNlZW1zIHRvIGhhdmUgc29tZSBtZW1vcnkgbG9zcyBzbyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZVxcblxcdFxcdFxcdGlmICggdHlwZW9mIGltYWdlRGF0YS53aWR0aCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1zZy5kYXRhLmltYWdlRGF0YVdpZHRoID09PSAnbnVtYmVyJyApIHtcXG5cXHRcXHRcXHRcXHRpbWFnZURhdGEud2lkdGggPSBtc2cuZGF0YS5pbWFnZURhdGFXaWR0aDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB0eXBlb2YgaW1hZ2VEYXRhLmhlaWdodCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1zZy5kYXRhLmltYWdlRGF0YUhlaWdodCA9PT0gJ251bWJlcicgKSB7XFxuXFx0XFx0XFx0XFx0aW1hZ2VEYXRhLmhlaWdodCA9IG1zZy5kYXRhLmltYWdlRGF0YUhlaWdodDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFxuXFx0XFx0XFx0dmFyIHBvbHlnb25zID0gaW1hZ2VEYXRhVG9Qb2x5Z29ucyggbXNnLmRhdGEuaW1hZ2VEYXRhLCBtc2cuZGF0YS5wYXJhbXMgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXG5cXHRcXHRcXHRzZWxmLnBvc3RNZXNzYWdlKCB7XFxuXFx0XFx0XFx0XFx0cG9seWdvbkpTT05TdHI6IEpTT04uc3RyaW5naWZ5KCBwb2x5Z29ucyApXFxuXFx0XFx0XFx0fSApO1xcblxcdFxcdH0gY2F0Y2ggKCBlcnIgKSB7XFxuXFx0XFx0XFx0c2VsZi5wb3N0TWVzc2FnZSggeyBlcnI6IGVyci5tZXNzYWdlIHx8IGVyciB9ICk7XFxuXFx0XFx0fVxcblxcblxcdH0gZWxzZSB7XFxuXFx0XFx0aWYgKCBtc2cuZGF0YS5pbWFnZURhdGEgKSB7XFxuXFx0XFx0XFx0c2VsZi5wb3N0TWVzc2FnZSggeyBlcnI6ICdQYXJhbWV0ZXJzIGFyZSBtaXNzaW5nLicgfSApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0c2VsZi5wb3N0TWVzc2FnZSggeyBlcnI6ICdJbWFnZURhdGEgaXMgbWlzc2luZy4nIH0gKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcdFxcblxcdHNlbGYuY2xvc2UoKTtcXG59O1xcblwiXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSkpKSxpPXtnZXRQYXJhbXM6ZnVuY3Rpb24oKXtyZXR1cm4gdH0sZ2V0SW5wdXQ6dSxnZXRPdXRwdXQ6Y30scz17ZnJvbUltYWdlOmZ1bmN0aW9uKHQpe3JldHVybiBkKHksdCl9LGZyb21JbWFnZVN5bmM6ZnVuY3Rpb24odCl7cmV0dXJuIGQoeSx0LCEwKX0sZnJvbUltYWdlRGF0YTpmdW5jdGlvbih0KXtyZXR1cm4gZCgoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSx0KX0sZnJvbUltYWdlRGF0YVN5bmM6ZnVuY3Rpb24odCl7cmV0dXJuIGQoKGZ1bmN0aW9uKHQpe3JldHVybiB0fSksdCwhMCl9fSxsPXt0b0RhdGE6ZnVuY3Rpb24odCl7cmV0dXJuIHAoKGZ1bmN0aW9uKHQpe3JldHVybiB0fSksdCl9LHRvRGF0YVN5bmM6ZnVuY3Rpb24odCl7cmV0dXJuIHAoKGZ1bmN0aW9uKHQpe3JldHVybiB0fSksdCwhMCl9LHRvRGF0YVVSTDpmdW5jdGlvbih0KXtyZXR1cm4gcCh3LHQpfSx0b0RhdGFVUkxTeW5jOmZ1bmN0aW9uKHQpe3JldHVybiBwKHcsdCwhMCl9LHRvSW1hZ2VEYXRhOmZ1bmN0aW9uKHQpe3JldHVybiBwKHYsdCl9LHRvSW1hZ2VEYXRhU3luYzpmdW5jdGlvbih0KXtyZXR1cm4gcCh2LHQsITApfSx0b1NWRzpmdW5jdGlvbih0KXtyZXR1cm4gcChELHQpfSx0b1NWR1N5bmM6ZnVuY3Rpb24odCl7cmV0dXJuIHAoRCx0LCEwKX19O2Z1bmN0aW9uIHUoKXt2YXIgdD1mKHt9LGkpO3JldHVybiBufHxmKHQscyksdH1mdW5jdGlvbiBjKCl7dmFyIHQ9Zih7fSxpKTtyZXR1cm4gZXx8Zih0LGwpLHR9ZnVuY3Rpb24gZCh0LGUscil7cmV0dXJuIGE9ISFyLG49ZnVuY3Rpb24oKXtyZXR1cm4gYT90KGUpOm5ldyBQcm9taXNlKChmdW5jdGlvbihuLGEpe3RyeXtuKHQoZSkpfWNhdGNoKHQpe2EodCl9fSkpfSxnKCk/aCgpOmMoKX1mdW5jdGlvbiBwKHQsbixhKXtyZXR1cm4gcj0hIWEsZT1mdW5jdGlvbihlLGEpe3JldHVybiByP3QoZSxhLG4pOm5ldyBQcm9taXNlKChmdW5jdGlvbihyLG8pe3RyeXtyKHQoZSxhLG4pKX1jYXRjaCh0KXtvKHQpfX0pKX0sZygpP2goKTp1KCl9ZnVuY3Rpb24gZygpe3JldHVybiBuJiZlfWZ1bmN0aW9uIGgoKXtpZihhJiZyKXt2YXIgaT1uKHQpLHM9RyhpLHQpO3JldHVybiBlKHMsaSl9cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihpLHMpe3ZhciBsLHU7bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7aWYoYSl0cnl7dChuKHUpKX1jYXRjaCh0KXtlKHQpfWVsc2Ugbih1KS50aGVuKHQsZSl9KSkudGhlbigoZnVuY3Rpb24obil7cmV0dXJuIGZ1bmN0aW9uKHQsbil7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihlLGEpe28uYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwoZnVuY3Rpb24odCl7aWYodC5kYXRhJiZ0LmRhdGEucG9seWdvbkpTT05TdHIpe3ZhciBuPUpTT04ucGFyc2UodC5kYXRhLnBvbHlnb25KU09OU3RyKTtlKG4pfWVsc2UgdC5kYXRhJiZ0LmRhdGEuZXJyP2EodC5kYXRhLmVycik6YSh0KX0pKSxvLnBvc3RNZXNzYWdlKHtwYXJhbXM6bixpbWFnZURhdGE6dCxpbWFnZURhdGFXaWR0aDp0LndpZHRoLGltYWdlRGF0YUhlaWdodDp0LmhlaWdodH0pfSkpfShsPW4sdCl9KSxzKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24odCxuKXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKGEsbyl7aWYocil0cnl7YShlKHQsbikpfWNhdGNoKHQpe28odCl9ZWxzZSBlKHQsbikudGhlbihhLG8pfSkpfSh0LGwpfSkscykudGhlbigoZnVuY3Rpb24odCl7aSh0KX0pLHMpfSkpfXJldHVybiB1KCl9fSx0LmV4cG9ydHM9ZSgpfSkuY2FsbCh0aGlzLGUoMSkpfSxmdW5jdGlvbih0LG4pe3ZhciBlO2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKTt0cnl7ZT1lfHxuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfWNhdGNoKHQpe1wib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJihlPXdpbmRvdyl9dC5leHBvcnRzPWV9LGZ1bmN0aW9uKHQsbixlKXtcInVzZSBzdHJpY3RcIjtlLnIobiksZS5kKG4sXCJnZXRUcmlhbmd1bGF0aW9uRGF0YVwiLChmdW5jdGlvbigpe3JldHVybiBpfSkpLGUuZChuLFwiaW52b2tlUG9seWdvbnNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbH0pKTt2YXIgYT1lKDApLHI9ZS5uKGEpO2NvbnN0IG89dD0+e2NvbnN0IG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtyZXR1cm4gbi5pbm5lckhUTUw9dC50cmltKCksbi5maXJzdEVsZW1lbnRDaGlsZH07dmFyIGk9KHtpbWFnZTp0LHBhcmFtczpufSk9PnIoKShuKS5mcm9tSW1hZ2UodCkudG9TVkcoKS50aGVuKG8pLnRoZW4odD0+KHtoZWlnaHQ6dC5nZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiksd2lkdGg6dC5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSxwb2x5Z29uczp0LnF1ZXJ5U2VsZWN0b3JBbGwoXCJwb2x5Z29uXCIpfSkpLnRoZW4odD0+KHsuLi50LHBvbHlnb25zOkFycmF5LmZyb20odC5wb2x5Z29ucykubWFwKG49Pih7cG9pbnRzOm4uZ2V0QXR0cmlidXRlKFwicG9pbnRzXCIpLnNwbGl0KFwiIFwiKS5tYXAodD0+dC5zcGxpdChcIixcIikpLm1hcCgoW24sZV0pPT5gJHtuL3Qud2lkdGgqMTAwfSUgJHtlL3QuaGVpZ2h0KjEwMH0lYCkuam9pbihcIixcIiksY29sb3I6bi5nZXRBdHRyaWJ1dGUoXCJmaWxsXCIpfSkpfSkpO2NvbnN0IHM9e2ZhZGU6e3ByZTooe2R1cmF0aW9uOnQsY29sb3I6bixwb2ludHM6ZX0pPT5gXFxuICAgICAgY2xpcC1wYXRoOiBwb2x5Z29uKCR7ZX0pO1xcbiAgICAgIGJhY2tncm91bmQ6ICR7bn07XFxuICAgICAgbGVmdDogMDtcXG4gICAgICByaWdodDogMDtcXG4gICAgICB0b3A6IDA7XFxuICAgICAgYm90dG9tOiAwO1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICBvcGFjaXR5OiAwO1xcbiAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgJHt0fXMgY3ViaWMtYmV6aWVyKC43LC4zLDAsMSk7YCxwb3N0OigpPT5cIm9wYWNpdHk6IDE7XCJ9LGZseTp7cHJlOih7ZHVyYXRpb246dCxwb2ludHM6bn0pPT5gXFxuICAgICAgICBjbGlwLXBhdGg6IHBvbHlnb24oJHtuLnNwbGl0KFwiLFwiKS5tYXAodD0+dC5zcGxpdChcIiBcIikpLm1hcCgoW3Qsbl0pPT5gJHsxKnQucmVwbGFjZShcIiVcIixcIlwiKSszMCpNYXRoLnJhbmRvbSgpfSUgJHtufWApLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICByaWdodDogMDtcXG4gICAgICAgIHRvcDogMDtcXG4gICAgICAgIGJvdHRvbTogMDtcXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgIHRyYW5zaXRpb246IC13ZWJraXQtY2xpcC1wYXRoICR7dH1zIGN1YmljLWJlemllciguNywgLjMsIDAsIDEpLCBjbGlwLXBhdGggJHt0fXMgY3ViaWMtYmV6aWVyKC43LCAuMywgMCwgMSksIGJhY2tncm91bmQtY29sb3IgJHt0fXMgY3ViaWMtYmV6aWVyKC43LCAuMywgMCwgMSk7YCxwb3N0Oih7cG9pbnRzOnQsY29sb3I6bn0pPT5gXFxuICAgICAgY2xpcC1wYXRoOiBwb2x5Z29uKCR7dH0pO1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7bn07YH19O3ZhciBsPSh7ZGF0YTp0LGFuaW1hdGlvbjpuLGNvbnRhaW5lcjplfSk9PlByb21pc2UuYWxsKHQucG9seWdvbnMubWFwKCh0LGEpPT57Y29uc3R7cG9seWdvbjpyLHByb21pc2U6b309KCh7cG9pbnRzOnQsY29sb3I6bixpZHg6ZSx0eXBlOmE9XCJmYWRlXCIsZHVyYXRpb246cj0uNX0pPT57Y29uc3Qgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO28uY2xhc3NMaXN0LmFkZChcInBvbHlnb25cIiksby5zdHlsZT1zW2FdLnByZSh7ZHVyYXRpb246cixjb2xvcjpuLHBvaW50czp0fSk7Y29uc3QgaT1uZXcgUHJvbWlzZShpPT5zZXRUaW1lb3V0KCgpPT57by5zdHlsZT1vLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpK3NbYV0ucG9zdCh7ZHVyYXRpb246cixjb2xvcjpuLHBvaW50czp0fSksaShvKX0sMTAwKmUvMjApKTtyZXR1cm57cG9seWdvbjpvLHByb21pc2U6aX19KSh7Li4udCxpZHg6YSxkdXJhdGlvbjpuLmR1cmF0aW9uLHR5cGU6bi50eXBlfSk7cmV0dXJuIGUuYXBwZW5kKHIpLG99KSl9XSl9KSk7IiwiaW1wb3J0IHsgZ2V0VHJpYW5ndWxhdGlvbkRhdGEsIGludm9rZVBvbHlnb25zIH0gZnJvbSBcInBvbHlnb25pemUtaW1hZ2VcIjtcblxuY29uc3QgYW5pbWF0ZUltYWdlID0gYXN5bmMgKHtcbiAgaW1hZ2VTZWxlY3RvcixcbiAgY29udGFpbmVyU2VsZWN0b3IsXG4gIGFuaW1hdGlvbixcbn0pID0+IHtcbiAgY29uc3QgaW1hZ2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGltYWdlU2VsZWN0b3IpO1xuICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lclNlbGVjdG9yKTtcblxuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgYmx1cjogMCxcbiAgICB2ZXJ0ZXhDb3VudDogMzAwLFxuICAgIGFjY3VyYWN5OiAxLFxuICB9O1xuXG4gIGNvbnN0IHByZVBhcmFtcyA9IHtcbiAgICBibHVyOiAxMDAwLFxuICAgIHZlcnRleENvdW50OiA1MCxcbiAgICBhY2N1cmFjeTogMC4yLFxuICB9O1xuXG4gIGNvbnN0IGRhdGExUHJvbWlzZSA9IGdldFRyaWFuZ3VsYXRpb25EYXRhKHtcbiAgICBpbWFnZSxcbiAgICBwYXJhbXM6IHByZVBhcmFtcyxcbiAgfSk7XG5cbiAgY29uc3QgZGF0YTJQcm9taXNlID0gZ2V0VHJpYW5ndWxhdGlvbkRhdGEoe1xuICAgIGltYWdlLFxuICAgIHBhcmFtcyxcbiAgfSk7XG5cbiAgYXdhaXQgaW52b2tlUG9seWdvbnMoe1xuICAgIGRhdGE6IGF3YWl0IGRhdGExUHJvbWlzZSxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiAwLjUsXG4gICAgICB0eXBlOiBhbmltYXRpb24sXG4gICAgfSxcbiAgICBjb250YWluZXIsXG4gIH0pO1xuXG4gIGF3YWl0IGludm9rZVBvbHlnb25zKHtcbiAgICBkYXRhOiBhd2FpdCBkYXRhMlByb21pc2UsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogMC41LFxuICAgICAgdHlwZTogYW5pbWF0aW9uLFxuICAgIH0sXG4gICAgY29udGFpbmVyLFxuICB9KTtcblxuICBpbWFnZS5jbGFzc0xpc3QuYWRkKFwic2hvd1wiKTtcbn07XG5cbmNvbnN0IGluaXQgPSAoKSA9PiB7XG4gIGFuaW1hdGVJbWFnZSh7XG4gICAgaW1hZ2VTZWxlY3RvcjogXCIuaW1nXCIsXG4gICAgY29udGFpbmVyU2VsZWN0b3I6IFwiLmNvbnRhaW5lclwiLFxuICAgIGFuaW1hdGlvbjogXCJmbHlcIixcbiAgfSk7XG4gIGFuaW1hdGVJbWFnZSh7XG4gICAgaW1hZ2VTZWxlY3RvcjogXCIuaW1nLTJcIixcbiAgICBjb250YWluZXJTZWxlY3RvcjogXCIuY29udGFpbmVyLTJcIixcbiAgICBhbmltYXRpb246IFwiZmFkZVwiLFxuICB9KTtcbn07XG5cbmluaXQoKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=